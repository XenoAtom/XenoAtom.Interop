//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libshaderc
    {
        /// <summary>
        /// Source language kind.
        /// </summary>
        public enum shaderc_source_language : uint
        {
            shaderc_source_language_glsl = unchecked((uint)0),
            
            shaderc_source_language_hlsl = unchecked((uint)1),
        }
        
        public const libshaderc.shaderc_source_language shaderc_source_language_glsl = shaderc_source_language.shaderc_source_language_glsl;
        
        public const libshaderc.shaderc_source_language shaderc_source_language_hlsl = shaderc_source_language.shaderc_source_language_hlsl;
        
        public enum shaderc_shader_kind : uint
        {
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_vertex_shader = unchecked((uint)0),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_fragment_shader = unchecked((uint)1),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_compute_shader = unchecked((uint)2),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_geometry_shader = unchecked((uint)3),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_tess_control_shader = unchecked((uint)4),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_tess_evaluation_shader = unchecked((uint)5),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_vertex_shader = unchecked((uint)0),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_fragment_shader = unchecked((uint)1),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_compute_shader = unchecked((uint)2),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_geometry_shader = unchecked((uint)3),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_tess_control_shader = unchecked((uint)4),
            
            /// <summary>
            /// Forced shader kinds. These shader kinds force the compiler to compile the
            /// source code as the specified kind of shader.
            /// </summary>
            shaderc_glsl_tess_evaluation_shader = unchecked((uint)5),
            
            /// <summary>
            /// Deduce the shader kind from #pragma annotation in the source code. Compiler
            /// will emit error if #pragma annotation is not found.
            /// </summary>
            shaderc_glsl_infer_from_source = unchecked((uint)6),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_vertex_shader = unchecked((uint)7),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_fragment_shader = unchecked((uint)8),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_compute_shader = unchecked((uint)9),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_geometry_shader = unchecked((uint)10),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_tess_control_shader = unchecked((uint)11),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_tess_evaluation_shader = unchecked((uint)12),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_spirv_assembly = unchecked((uint)13),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_raygen_shader = unchecked((uint)14),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_anyhit_shader = unchecked((uint)15),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_closesthit_shader = unchecked((uint)16),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_miss_shader = unchecked((uint)17),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_intersection_shader = unchecked((uint)18),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_callable_shader = unchecked((uint)19),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_raygen_shader = unchecked((uint)14),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_anyhit_shader = unchecked((uint)15),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_closesthit_shader = unchecked((uint)16),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_miss_shader = unchecked((uint)17),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_intersection_shader = unchecked((uint)18),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_callable_shader = unchecked((uint)19),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_raygen_shader = unchecked((uint)20),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_anyhit_shader = unchecked((uint)21),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_closesthit_shader = unchecked((uint)22),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_miss_shader = unchecked((uint)23),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_intersection_shader = unchecked((uint)24),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_callable_shader = unchecked((uint)25),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_task_shader = unchecked((uint)26),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_mesh_shader = unchecked((uint)27),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_task_shader = unchecked((uint)26),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_mesh_shader = unchecked((uint)27),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_task_shader = unchecked((uint)28),
            
            /// <summary>
            /// Default shader kinds. Compiler will fall back to compile the source code as
            /// the specified kind of shader when #pragma annotation is not found in the
            /// source code.
            /// </summary>
            shaderc_glsl_default_mesh_shader = unchecked((uint)29),
        }
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_vertex_shader = shaderc_shader_kind.shaderc_vertex_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_fragment_shader = shaderc_shader_kind.shaderc_fragment_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_compute_shader = shaderc_shader_kind.shaderc_compute_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_geometry_shader = shaderc_shader_kind.shaderc_geometry_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_tess_control_shader = shaderc_shader_kind.shaderc_tess_control_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_tess_evaluation_shader = shaderc_shader_kind.shaderc_tess_evaluation_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_vertex_shader = shaderc_shader_kind.shaderc_glsl_vertex_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_fragment_shader = shaderc_shader_kind.shaderc_glsl_fragment_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_compute_shader = shaderc_shader_kind.shaderc_glsl_compute_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_geometry_shader = shaderc_shader_kind.shaderc_glsl_geometry_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_tess_control_shader = shaderc_shader_kind.shaderc_glsl_tess_control_shader;
        
        /// <summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the
        /// source code as the specified kind of shader.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_tess_evaluation_shader = shaderc_shader_kind.shaderc_glsl_tess_evaluation_shader;
        
        /// <summary>
        /// Deduce the shader kind from #pragma annotation in the source code. Compiler
        /// will emit error if #pragma annotation is not found.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_infer_from_source = shaderc_shader_kind.shaderc_glsl_infer_from_source;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_vertex_shader = shaderc_shader_kind.shaderc_glsl_default_vertex_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_fragment_shader = shaderc_shader_kind.shaderc_glsl_default_fragment_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_compute_shader = shaderc_shader_kind.shaderc_glsl_default_compute_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_geometry_shader = shaderc_shader_kind.shaderc_glsl_default_geometry_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_tess_control_shader = shaderc_shader_kind.shaderc_glsl_default_tess_control_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_tess_evaluation_shader = shaderc_shader_kind.shaderc_glsl_default_tess_evaluation_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_spirv_assembly = shaderc_shader_kind.shaderc_spirv_assembly;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_raygen_shader = shaderc_shader_kind.shaderc_raygen_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_anyhit_shader = shaderc_shader_kind.shaderc_anyhit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_closesthit_shader = shaderc_shader_kind.shaderc_closesthit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_miss_shader = shaderc_shader_kind.shaderc_miss_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_intersection_shader = shaderc_shader_kind.shaderc_intersection_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_callable_shader = shaderc_shader_kind.shaderc_callable_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_raygen_shader = shaderc_shader_kind.shaderc_glsl_raygen_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_anyhit_shader = shaderc_shader_kind.shaderc_glsl_anyhit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_closesthit_shader = shaderc_shader_kind.shaderc_glsl_closesthit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_miss_shader = shaderc_shader_kind.shaderc_glsl_miss_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_intersection_shader = shaderc_shader_kind.shaderc_glsl_intersection_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_callable_shader = shaderc_shader_kind.shaderc_glsl_callable_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_raygen_shader = shaderc_shader_kind.shaderc_glsl_default_raygen_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_anyhit_shader = shaderc_shader_kind.shaderc_glsl_default_anyhit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_closesthit_shader = shaderc_shader_kind.shaderc_glsl_default_closesthit_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_miss_shader = shaderc_shader_kind.shaderc_glsl_default_miss_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_intersection_shader = shaderc_shader_kind.shaderc_glsl_default_intersection_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_callable_shader = shaderc_shader_kind.shaderc_glsl_default_callable_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_task_shader = shaderc_shader_kind.shaderc_task_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_mesh_shader = shaderc_shader_kind.shaderc_mesh_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_task_shader = shaderc_shader_kind.shaderc_glsl_task_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_mesh_shader = shaderc_shader_kind.shaderc_glsl_mesh_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_task_shader = shaderc_shader_kind.shaderc_glsl_default_task_shader;
        
        /// <summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as
        /// the specified kind of shader when #pragma annotation is not found in the
        /// source code.
        /// </summary>
        public const libshaderc.shaderc_shader_kind shaderc_glsl_default_mesh_shader = shaderc_shader_kind.shaderc_glsl_default_mesh_shader;
        
        public enum shaderc_profile : uint
        {
            /// <summary>
            /// Used if and only if GLSL version did not specify
            /// profiles.
            /// </summary>
            shaderc_profile_none = unchecked((uint)0),
            
            shaderc_profile_core = unchecked((uint)1),
            
            /// <summary>
            /// Disabled. This generates an error
            /// </summary>
            shaderc_profile_compatibility = unchecked((uint)2),
            
            shaderc_profile_es = unchecked((uint)3),
        }
        
        /// <summary>
        /// Used if and only if GLSL version did not specify
        /// profiles.
        /// </summary>
        public const libshaderc.shaderc_profile shaderc_profile_none = shaderc_profile.shaderc_profile_none;
        
        public const libshaderc.shaderc_profile shaderc_profile_core = shaderc_profile.shaderc_profile_core;
        
        /// <summary>
        /// Disabled. This generates an error
        /// </summary>
        public const libshaderc.shaderc_profile shaderc_profile_compatibility = shaderc_profile.shaderc_profile_compatibility;
        
        public const libshaderc.shaderc_profile shaderc_profile_es = shaderc_profile.shaderc_profile_es;
        
        /// <summary>
        /// Optimization level.
        /// </summary>
        public enum shaderc_optimization_level : uint
        {
            /// <summary>
            /// no optimization
            /// </summary>
            shaderc_optimization_level_zero = unchecked((uint)0),
            
            /// <summary>
            /// optimize towards reducing code size
            /// </summary>
            shaderc_optimization_level_size = unchecked((uint)1),
            
            /// <summary>
            /// optimize towards performance
            /// </summary>
            shaderc_optimization_level_performance = unchecked((uint)2),
        }
        
        /// <summary>
        /// no optimization
        /// </summary>
        public const libshaderc.shaderc_optimization_level shaderc_optimization_level_zero = shaderc_optimization_level.shaderc_optimization_level_zero;
        
        /// <summary>
        /// optimize towards reducing code size
        /// </summary>
        public const libshaderc.shaderc_optimization_level shaderc_optimization_level_size = shaderc_optimization_level.shaderc_optimization_level_size;
        
        /// <summary>
        /// optimize towards performance
        /// </summary>
        public const libshaderc.shaderc_optimization_level shaderc_optimization_level_performance = shaderc_optimization_level.shaderc_optimization_level_performance;
        
        /// <summary>
        /// Resource limits.
        /// </summary>
        public enum shaderc_limit : uint
        {
            shaderc_limit_max_lights = unchecked((uint)0),
            
            shaderc_limit_max_clip_planes = unchecked((uint)1),
            
            shaderc_limit_max_texture_units = unchecked((uint)2),
            
            shaderc_limit_max_texture_coords = unchecked((uint)3),
            
            shaderc_limit_max_vertex_attribs = unchecked((uint)4),
            
            shaderc_limit_max_vertex_uniform_components = unchecked((uint)5),
            
            shaderc_limit_max_varying_floats = unchecked((uint)6),
            
            shaderc_limit_max_vertex_texture_image_units = unchecked((uint)7),
            
            shaderc_limit_max_combined_texture_image_units = unchecked((uint)8),
            
            shaderc_limit_max_texture_image_units = unchecked((uint)9),
            
            shaderc_limit_max_fragment_uniform_components = unchecked((uint)10),
            
            shaderc_limit_max_draw_buffers = unchecked((uint)11),
            
            shaderc_limit_max_vertex_uniform_vectors = unchecked((uint)12),
            
            shaderc_limit_max_varying_vectors = unchecked((uint)13),
            
            shaderc_limit_max_fragment_uniform_vectors = unchecked((uint)14),
            
            shaderc_limit_max_vertex_output_vectors = unchecked((uint)15),
            
            shaderc_limit_max_fragment_input_vectors = unchecked((uint)16),
            
            shaderc_limit_min_program_texel_offset = unchecked((uint)17),
            
            shaderc_limit_max_program_texel_offset = unchecked((uint)18),
            
            shaderc_limit_max_clip_distances = unchecked((uint)19),
            
            shaderc_limit_max_compute_work_group_count_x = unchecked((uint)20),
            
            shaderc_limit_max_compute_work_group_count_y = unchecked((uint)21),
            
            shaderc_limit_max_compute_work_group_count_z = unchecked((uint)22),
            
            shaderc_limit_max_compute_work_group_size_x = unchecked((uint)23),
            
            shaderc_limit_max_compute_work_group_size_y = unchecked((uint)24),
            
            shaderc_limit_max_compute_work_group_size_z = unchecked((uint)25),
            
            shaderc_limit_max_compute_uniform_components = unchecked((uint)26),
            
            shaderc_limit_max_compute_texture_image_units = unchecked((uint)27),
            
            shaderc_limit_max_compute_image_uniforms = unchecked((uint)28),
            
            shaderc_limit_max_compute_atomic_counters = unchecked((uint)29),
            
            shaderc_limit_max_compute_atomic_counter_buffers = unchecked((uint)30),
            
            shaderc_limit_max_varying_components = unchecked((uint)31),
            
            shaderc_limit_max_vertex_output_components = unchecked((uint)32),
            
            shaderc_limit_max_geometry_input_components = unchecked((uint)33),
            
            shaderc_limit_max_geometry_output_components = unchecked((uint)34),
            
            shaderc_limit_max_fragment_input_components = unchecked((uint)35),
            
            shaderc_limit_max_image_units = unchecked((uint)36),
            
            shaderc_limit_max_combined_image_units_and_fragment_outputs = unchecked((uint)37),
            
            shaderc_limit_max_combined_shader_output_resources = unchecked((uint)38),
            
            shaderc_limit_max_image_samples = unchecked((uint)39),
            
            shaderc_limit_max_vertex_image_uniforms = unchecked((uint)40),
            
            shaderc_limit_max_tess_control_image_uniforms = unchecked((uint)41),
            
            shaderc_limit_max_tess_evaluation_image_uniforms = unchecked((uint)42),
            
            shaderc_limit_max_geometry_image_uniforms = unchecked((uint)43),
            
            shaderc_limit_max_fragment_image_uniforms = unchecked((uint)44),
            
            shaderc_limit_max_combined_image_uniforms = unchecked((uint)45),
            
            shaderc_limit_max_geometry_texture_image_units = unchecked((uint)46),
            
            shaderc_limit_max_geometry_output_vertices = unchecked((uint)47),
            
            shaderc_limit_max_geometry_total_output_components = unchecked((uint)48),
            
            shaderc_limit_max_geometry_uniform_components = unchecked((uint)49),
            
            shaderc_limit_max_geometry_varying_components = unchecked((uint)50),
            
            shaderc_limit_max_tess_control_input_components = unchecked((uint)51),
            
            shaderc_limit_max_tess_control_output_components = unchecked((uint)52),
            
            shaderc_limit_max_tess_control_texture_image_units = unchecked((uint)53),
            
            shaderc_limit_max_tess_control_uniform_components = unchecked((uint)54),
            
            shaderc_limit_max_tess_control_total_output_components = unchecked((uint)55),
            
            shaderc_limit_max_tess_evaluation_input_components = unchecked((uint)56),
            
            shaderc_limit_max_tess_evaluation_output_components = unchecked((uint)57),
            
            shaderc_limit_max_tess_evaluation_texture_image_units = unchecked((uint)58),
            
            shaderc_limit_max_tess_evaluation_uniform_components = unchecked((uint)59),
            
            shaderc_limit_max_tess_patch_components = unchecked((uint)60),
            
            shaderc_limit_max_patch_vertices = unchecked((uint)61),
            
            shaderc_limit_max_tess_gen_level = unchecked((uint)62),
            
            shaderc_limit_max_viewports = unchecked((uint)63),
            
            shaderc_limit_max_vertex_atomic_counters = unchecked((uint)64),
            
            shaderc_limit_max_tess_control_atomic_counters = unchecked((uint)65),
            
            shaderc_limit_max_tess_evaluation_atomic_counters = unchecked((uint)66),
            
            shaderc_limit_max_geometry_atomic_counters = unchecked((uint)67),
            
            shaderc_limit_max_fragment_atomic_counters = unchecked((uint)68),
            
            shaderc_limit_max_combined_atomic_counters = unchecked((uint)69),
            
            shaderc_limit_max_atomic_counter_bindings = unchecked((uint)70),
            
            shaderc_limit_max_vertex_atomic_counter_buffers = unchecked((uint)71),
            
            shaderc_limit_max_tess_control_atomic_counter_buffers = unchecked((uint)72),
            
            shaderc_limit_max_tess_evaluation_atomic_counter_buffers = unchecked((uint)73),
            
            shaderc_limit_max_geometry_atomic_counter_buffers = unchecked((uint)74),
            
            shaderc_limit_max_fragment_atomic_counter_buffers = unchecked((uint)75),
            
            shaderc_limit_max_combined_atomic_counter_buffers = unchecked((uint)76),
            
            shaderc_limit_max_atomic_counter_buffer_size = unchecked((uint)77),
            
            shaderc_limit_max_transform_feedback_buffers = unchecked((uint)78),
            
            shaderc_limit_max_transform_feedback_interleaved_components = unchecked((uint)79),
            
            shaderc_limit_max_cull_distances = unchecked((uint)80),
            
            shaderc_limit_max_combined_clip_and_cull_distances = unchecked((uint)81),
            
            shaderc_limit_max_samples = unchecked((uint)82),
            
            shaderc_limit_max_mesh_output_vertices_nv = unchecked((uint)83),
            
            shaderc_limit_max_mesh_output_primitives_nv = unchecked((uint)84),
            
            shaderc_limit_max_mesh_work_group_size_x_nv = unchecked((uint)85),
            
            shaderc_limit_max_mesh_work_group_size_y_nv = unchecked((uint)86),
            
            shaderc_limit_max_mesh_work_group_size_z_nv = unchecked((uint)87),
            
            shaderc_limit_max_task_work_group_size_x_nv = unchecked((uint)88),
            
            shaderc_limit_max_task_work_group_size_y_nv = unchecked((uint)89),
            
            shaderc_limit_max_task_work_group_size_z_nv = unchecked((uint)90),
            
            shaderc_limit_max_mesh_view_count_nv = unchecked((uint)91),
            
            shaderc_limit_max_mesh_output_vertices_ext = unchecked((uint)92),
            
            shaderc_limit_max_mesh_output_primitives_ext = unchecked((uint)93),
            
            shaderc_limit_max_mesh_work_group_size_x_ext = unchecked((uint)94),
            
            shaderc_limit_max_mesh_work_group_size_y_ext = unchecked((uint)95),
            
            shaderc_limit_max_mesh_work_group_size_z_ext = unchecked((uint)96),
            
            shaderc_limit_max_task_work_group_size_x_ext = unchecked((uint)97),
            
            shaderc_limit_max_task_work_group_size_y_ext = unchecked((uint)98),
            
            shaderc_limit_max_task_work_group_size_z_ext = unchecked((uint)99),
            
            shaderc_limit_max_mesh_view_count_ext = unchecked((uint)100),
            
            shaderc_limit_max_dual_source_draw_buffers_ext = unchecked((uint)101),
        }
        
        public const libshaderc.shaderc_limit shaderc_limit_max_lights = shaderc_limit.shaderc_limit_max_lights;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_clip_planes = shaderc_limit.shaderc_limit_max_clip_planes;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_texture_units = shaderc_limit.shaderc_limit_max_texture_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_texture_coords = shaderc_limit.shaderc_limit_max_texture_coords;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_attribs = shaderc_limit.shaderc_limit_max_vertex_attribs;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_uniform_components = shaderc_limit.shaderc_limit_max_vertex_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_varying_floats = shaderc_limit.shaderc_limit_max_varying_floats;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_texture_image_units = shaderc_limit.shaderc_limit_max_vertex_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_texture_image_units = shaderc_limit.shaderc_limit_max_combined_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_texture_image_units = shaderc_limit.shaderc_limit_max_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_uniform_components = shaderc_limit.shaderc_limit_max_fragment_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_draw_buffers = shaderc_limit.shaderc_limit_max_draw_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_uniform_vectors = shaderc_limit.shaderc_limit_max_vertex_uniform_vectors;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_varying_vectors = shaderc_limit.shaderc_limit_max_varying_vectors;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_uniform_vectors = shaderc_limit.shaderc_limit_max_fragment_uniform_vectors;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_output_vectors = shaderc_limit.shaderc_limit_max_vertex_output_vectors;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_input_vectors = shaderc_limit.shaderc_limit_max_fragment_input_vectors;
        
        public const libshaderc.shaderc_limit shaderc_limit_min_program_texel_offset = shaderc_limit.shaderc_limit_min_program_texel_offset;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_program_texel_offset = shaderc_limit.shaderc_limit_max_program_texel_offset;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_clip_distances = shaderc_limit.shaderc_limit_max_clip_distances;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_count_x = shaderc_limit.shaderc_limit_max_compute_work_group_count_x;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_count_y = shaderc_limit.shaderc_limit_max_compute_work_group_count_y;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_count_z = shaderc_limit.shaderc_limit_max_compute_work_group_count_z;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_size_x = shaderc_limit.shaderc_limit_max_compute_work_group_size_x;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_size_y = shaderc_limit.shaderc_limit_max_compute_work_group_size_y;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_work_group_size_z = shaderc_limit.shaderc_limit_max_compute_work_group_size_z;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_uniform_components = shaderc_limit.shaderc_limit_max_compute_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_texture_image_units = shaderc_limit.shaderc_limit_max_compute_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_image_uniforms = shaderc_limit.shaderc_limit_max_compute_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_atomic_counters = shaderc_limit.shaderc_limit_max_compute_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_compute_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_compute_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_varying_components = shaderc_limit.shaderc_limit_max_varying_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_output_components = shaderc_limit.shaderc_limit_max_vertex_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_input_components = shaderc_limit.shaderc_limit_max_geometry_input_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_output_components = shaderc_limit.shaderc_limit_max_geometry_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_input_components = shaderc_limit.shaderc_limit_max_fragment_input_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_image_units = shaderc_limit.shaderc_limit_max_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_image_units_and_fragment_outputs = shaderc_limit.shaderc_limit_max_combined_image_units_and_fragment_outputs;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_shader_output_resources = shaderc_limit.shaderc_limit_max_combined_shader_output_resources;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_image_samples = shaderc_limit.shaderc_limit_max_image_samples;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_image_uniforms = shaderc_limit.shaderc_limit_max_vertex_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_image_uniforms = shaderc_limit.shaderc_limit_max_tess_control_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_image_uniforms = shaderc_limit.shaderc_limit_max_tess_evaluation_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_image_uniforms = shaderc_limit.shaderc_limit_max_geometry_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_image_uniforms = shaderc_limit.shaderc_limit_max_fragment_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_image_uniforms = shaderc_limit.shaderc_limit_max_combined_image_uniforms;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_texture_image_units = shaderc_limit.shaderc_limit_max_geometry_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_output_vertices = shaderc_limit.shaderc_limit_max_geometry_output_vertices;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_total_output_components = shaderc_limit.shaderc_limit_max_geometry_total_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_uniform_components = shaderc_limit.shaderc_limit_max_geometry_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_varying_components = shaderc_limit.shaderc_limit_max_geometry_varying_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_input_components = shaderc_limit.shaderc_limit_max_tess_control_input_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_output_components = shaderc_limit.shaderc_limit_max_tess_control_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_texture_image_units = shaderc_limit.shaderc_limit_max_tess_control_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_uniform_components = shaderc_limit.shaderc_limit_max_tess_control_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_total_output_components = shaderc_limit.shaderc_limit_max_tess_control_total_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_input_components = shaderc_limit.shaderc_limit_max_tess_evaluation_input_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_output_components = shaderc_limit.shaderc_limit_max_tess_evaluation_output_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_texture_image_units = shaderc_limit.shaderc_limit_max_tess_evaluation_texture_image_units;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_uniform_components = shaderc_limit.shaderc_limit_max_tess_evaluation_uniform_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_patch_components = shaderc_limit.shaderc_limit_max_tess_patch_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_patch_vertices = shaderc_limit.shaderc_limit_max_patch_vertices;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_gen_level = shaderc_limit.shaderc_limit_max_tess_gen_level;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_viewports = shaderc_limit.shaderc_limit_max_viewports;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_atomic_counters = shaderc_limit.shaderc_limit_max_vertex_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_atomic_counters = shaderc_limit.shaderc_limit_max_tess_control_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_atomic_counters = shaderc_limit.shaderc_limit_max_tess_evaluation_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_atomic_counters = shaderc_limit.shaderc_limit_max_geometry_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_atomic_counters = shaderc_limit.shaderc_limit_max_fragment_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_atomic_counters = shaderc_limit.shaderc_limit_max_combined_atomic_counters;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_atomic_counter_bindings = shaderc_limit.shaderc_limit_max_atomic_counter_bindings;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_vertex_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_vertex_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_control_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_tess_control_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_tess_evaluation_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_tess_evaluation_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_geometry_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_geometry_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_fragment_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_fragment_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_atomic_counter_buffers = shaderc_limit.shaderc_limit_max_combined_atomic_counter_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_atomic_counter_buffer_size = shaderc_limit.shaderc_limit_max_atomic_counter_buffer_size;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_transform_feedback_buffers = shaderc_limit.shaderc_limit_max_transform_feedback_buffers;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_transform_feedback_interleaved_components = shaderc_limit.shaderc_limit_max_transform_feedback_interleaved_components;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_cull_distances = shaderc_limit.shaderc_limit_max_cull_distances;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_combined_clip_and_cull_distances = shaderc_limit.shaderc_limit_max_combined_clip_and_cull_distances;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_samples = shaderc_limit.shaderc_limit_max_samples;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_output_vertices_nv = shaderc_limit.shaderc_limit_max_mesh_output_vertices_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_output_primitives_nv = shaderc_limit.shaderc_limit_max_mesh_output_primitives_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_x_nv = shaderc_limit.shaderc_limit_max_mesh_work_group_size_x_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_y_nv = shaderc_limit.shaderc_limit_max_mesh_work_group_size_y_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_z_nv = shaderc_limit.shaderc_limit_max_mesh_work_group_size_z_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_x_nv = shaderc_limit.shaderc_limit_max_task_work_group_size_x_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_y_nv = shaderc_limit.shaderc_limit_max_task_work_group_size_y_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_z_nv = shaderc_limit.shaderc_limit_max_task_work_group_size_z_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_view_count_nv = shaderc_limit.shaderc_limit_max_mesh_view_count_nv;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_output_vertices_ext = shaderc_limit.shaderc_limit_max_mesh_output_vertices_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_output_primitives_ext = shaderc_limit.shaderc_limit_max_mesh_output_primitives_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_x_ext = shaderc_limit.shaderc_limit_max_mesh_work_group_size_x_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_y_ext = shaderc_limit.shaderc_limit_max_mesh_work_group_size_y_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_work_group_size_z_ext = shaderc_limit.shaderc_limit_max_mesh_work_group_size_z_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_x_ext = shaderc_limit.shaderc_limit_max_task_work_group_size_x_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_y_ext = shaderc_limit.shaderc_limit_max_task_work_group_size_y_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_task_work_group_size_z_ext = shaderc_limit.shaderc_limit_max_task_work_group_size_z_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_mesh_view_count_ext = shaderc_limit.shaderc_limit_max_mesh_view_count_ext;
        
        public const libshaderc.shaderc_limit shaderc_limit_max_dual_source_draw_buffers_ext = shaderc_limit.shaderc_limit_max_dual_source_draw_buffers_ext;
        
        /// <summary>
        /// Uniform resource kinds.
        /// In Vulkan, uniform resources are bound to the pipeline via descriptors
        /// with numbered bindings and sets.
        /// </summary>
        public enum shaderc_uniform_kind : uint
        {
            /// <summary>
            /// Image and image buffer.
            /// </summary>
            shaderc_uniform_kind_image = unchecked((uint)0),
            
            /// <summary>
            /// Pure sampler.
            /// </summary>
            shaderc_uniform_kind_sampler = unchecked((uint)1),
            
            /// <summary>
            /// Sampled texture in GLSL, and Shader Resource View in HLSL.
            /// </summary>
            shaderc_uniform_kind_texture = unchecked((uint)2),
            
            /// <summary>
            /// Uniform Buffer Object (UBO) in GLSL.  Cbuffer in HLSL.
            /// </summary>
            shaderc_uniform_kind_buffer = unchecked((uint)3),
            
            /// <summary>
            /// Shader Storage Buffer Object (SSBO) in GLSL.
            /// </summary>
            shaderc_uniform_kind_storage_buffer = unchecked((uint)4),
            
            /// <summary>
            /// Unordered Access View, in HLSL.  (Writable storage image or storage
            /// buffer.)
            /// </summary>
            shaderc_uniform_kind_unordered_access_view = unchecked((uint)5),
        }
        
        /// <summary>
        /// Image and image buffer.
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_image = shaderc_uniform_kind.shaderc_uniform_kind_image;
        
        /// <summary>
        /// Pure sampler.
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_sampler = shaderc_uniform_kind.shaderc_uniform_kind_sampler;
        
        /// <summary>
        /// Sampled texture in GLSL, and Shader Resource View in HLSL.
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_texture = shaderc_uniform_kind.shaderc_uniform_kind_texture;
        
        /// <summary>
        /// Uniform Buffer Object (UBO) in GLSL.  Cbuffer in HLSL.
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_buffer = shaderc_uniform_kind.shaderc_uniform_kind_buffer;
        
        /// <summary>
        /// Shader Storage Buffer Object (SSBO) in GLSL.
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_storage_buffer = shaderc_uniform_kind.shaderc_uniform_kind_storage_buffer;
        
        /// <summary>
        /// Unordered Access View, in HLSL.  (Writable storage image or storage
        /// buffer.)
        /// </summary>
        public const libshaderc.shaderc_uniform_kind shaderc_uniform_kind_unordered_access_view = shaderc_uniform_kind.shaderc_uniform_kind_unordered_access_view;
        
        /// <summary>
        /// The kinds of include requests.
        /// </summary>
        public enum shaderc_include_type : uint
        {
            /// <summary>
            /// E.g. #include "source"
            /// </summary>
            shaderc_include_type_relative = unchecked((uint)0),
            
            /// <summary>
            /// E.g. #include 
            /// &lt;source
            /// &gt;
            /// </summary>
            shaderc_include_type_standard = unchecked((uint)1),
        }
        
        /// <summary>
        /// E.g. #include "source"
        /// </summary>
        public const libshaderc.shaderc_include_type shaderc_include_type_relative = shaderc_include_type.shaderc_include_type_relative;
        
        /// <summary>
        /// E.g. #include 
        /// &lt;source
        /// &gt;
        /// </summary>
        public const libshaderc.shaderc_include_type shaderc_include_type_standard = shaderc_include_type.shaderc_include_type_standard;
        
        /// <summary>
        /// An include result.
        /// </summary>
        public partial struct shaderc_include_result
        {
            /// <summary>
            /// The name of the source file.  The name should be fully resolved
            /// in the sense that it should be a unique name in the context of the
            /// includer.  For example, if the includer maps source names to files in
            /// a filesystem, then this name should be the absolute path of the file.
            /// For a failed inclusion, this string is empty.
            /// </summary>
            public byte* source_name;
            
            public nuint source_name_length;
            
            /// <summary>
            /// The text contents of the source file in the normal case.
            /// For a failed inclusion, this contains the error message.
            /// </summary>
            public byte* content;
            
            public nuint content_length;
            
            /// <summary>
            /// User data to be passed along with this request.
            /// </summary>
            public void* user_data;
        }
        
        /// <summary>
        /// An opaque handle to an object that manages all compiler state.
        /// </summary>
        public readonly partial struct shaderc_compiler_t : IEquatable<libshaderc.shaderc_compiler_t>
        {
            public shaderc_compiler_t(libshaderc.shaderc_compiler value) => this.Value = value;
            
            public libshaderc.shaderc_compiler Value { get; }
            
            public override bool Equals(object obj) => obj is shaderc_compiler_t other && Equals(other);
            
            public bool Equals(shaderc_compiler_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libshaderc.shaderc_compiler (libshaderc.shaderc_compiler_t from) => from.Value;
            
            public static implicit operator libshaderc.shaderc_compiler_t (libshaderc.shaderc_compiler from) => new libshaderc.shaderc_compiler_t(from);
            
            public static bool operator ==(shaderc_compiler_t left, shaderc_compiler_t right) => left.Equals(right);
            
            public static bool operator !=(shaderc_compiler_t left, shaderc_compiler_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An opaque handle to an object that manages options to a single compilation
        /// result.
        /// </summary>
        public readonly partial struct shaderc_compile_options_t : IEquatable<libshaderc.shaderc_compile_options_t>
        {
            public shaderc_compile_options_t(libshaderc.shaderc_compile_options value) => this.Value = value;
            
            public libshaderc.shaderc_compile_options Value { get; }
            
            public override bool Equals(object obj) => obj is shaderc_compile_options_t other && Equals(other);
            
            public bool Equals(shaderc_compile_options_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libshaderc.shaderc_compile_options (libshaderc.shaderc_compile_options_t from) => from.Value;
            
            public static implicit operator libshaderc.shaderc_compile_options_t (libshaderc.shaderc_compile_options from) => new libshaderc.shaderc_compile_options_t(from);
            
            public static bool operator ==(shaderc_compile_options_t left, shaderc_compile_options_t right) => left.Equals(right);
            
            public static bool operator !=(shaderc_compile_options_t left, shaderc_compile_options_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An includer callback type for mapping an #include request to an include
        /// result.  The user_data parameter specifies the client context.  The
        /// requested_source parameter specifies the name of the source being requested.
        /// The type parameter specifies the kind of inclusion request being made.
        /// The requesting_source parameter specifies the name of the source containing
        /// the #include request.  The includer owns the result object and its contents,
        /// and both must remain valid until the release callback is called on the result
        /// object.
        /// </summary>
        public readonly partial struct shaderc_include_resolve_fn : IEquatable<libshaderc.shaderc_include_resolve_fn>
        {
            public shaderc_include_resolve_fn(delegate*unmanaged[Stdcall]<void*, byte*, int, byte*, nuint, libshaderc.shaderc_include_result*> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<void*, byte*, int, byte*, nuint, libshaderc.shaderc_include_result*> Value { get; }
            
            public override bool Equals(object obj) => obj is shaderc_include_resolve_fn other && Equals(other);
            
            public bool Equals(shaderc_include_resolve_fn other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<void*, byte*, int, byte*, nuint, libshaderc.shaderc_include_result*> (libshaderc.shaderc_include_resolve_fn from) => from.Value;
            
            public static implicit operator libshaderc.shaderc_include_resolve_fn (delegate*unmanaged[Stdcall]<void*, byte*, int, byte*, nuint, libshaderc.shaderc_include_result*> from) => new libshaderc.shaderc_include_resolve_fn(from);
            
            public static bool operator ==(shaderc_include_resolve_fn left, shaderc_include_resolve_fn right) => left.Equals(right);
            
            public static bool operator !=(shaderc_include_resolve_fn left, shaderc_include_resolve_fn right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An includer callback type for destroying an include result.
        /// </summary>
        public readonly partial struct shaderc_include_result_release_fn : IEquatable<libshaderc.shaderc_include_result_release_fn>
        {
            public shaderc_include_result_release_fn(delegate*unmanaged[Stdcall]<void*, libshaderc.shaderc_include_result*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<void*, libshaderc.shaderc_include_result*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is shaderc_include_result_release_fn other && Equals(other);
            
            public bool Equals(shaderc_include_result_release_fn other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<void*, libshaderc.shaderc_include_result*, void> (libshaderc.shaderc_include_result_release_fn from) => from.Value;
            
            public static implicit operator libshaderc.shaderc_include_result_release_fn (delegate*unmanaged[Stdcall]<void*, libshaderc.shaderc_include_result*, void> from) => new libshaderc.shaderc_include_result_release_fn(from);
            
            public static bool operator ==(shaderc_include_result_release_fn left, shaderc_include_result_release_fn right) => left.Equals(right);
            
            public static bool operator !=(shaderc_include_result_release_fn left, shaderc_include_result_release_fn right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An opaque handle to the results of a call to any shaderc_compile_into_*()
        /// function.
        /// </summary>
        public readonly partial struct shaderc_compilation_result_t : IEquatable<libshaderc.shaderc_compilation_result_t>
        {
            public shaderc_compilation_result_t(libshaderc.shaderc_compilation_result value) => this.Value = value;
            
            public libshaderc.shaderc_compilation_result Value { get; }
            
            public override bool Equals(object obj) => obj is shaderc_compilation_result_t other && Equals(other);
            
            public bool Equals(shaderc_compilation_result_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libshaderc.shaderc_compilation_result (libshaderc.shaderc_compilation_result_t from) => from.Value;
            
            public static implicit operator libshaderc.shaderc_compilation_result_t (libshaderc.shaderc_compilation_result from) => new libshaderc.shaderc_compilation_result_t(from);
            
            public static bool operator ==(shaderc_compilation_result_t left, shaderc_compilation_result_t right) => left.Equals(right);
            
            public static bool operator !=(shaderc_compilation_result_t left, shaderc_compilation_result_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Returns a shaderc_compiler_t that can be used to compile modules.
        /// A return of NULL indicates that there was an error initializing the compiler.
        /// Any function operating on shaderc_compiler_t must offer the basic
        /// thread-safety guarantee.
        /// [http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/]
        /// That is: concurrent invocation of these functions on DIFFERENT objects needs
        /// no synchronization; concurrent invocation of these functions on the SAME
        /// object requires synchronization IF AND ONLY IF some of them take a non-const
        /// argument.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compiler_initialize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compiler_t shaderc_compiler_initialize();
        
        /// <summary>
        /// Releases the resources held by the shaderc_compiler_t.
        /// After this call it is invalid to make any future calls to functions
        /// involving this shaderc_compiler_t.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compiler_release")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compiler_release(libshaderc.shaderc_compiler_t arg0);
        
        /// <summary>
        /// Returns a default-initialized shaderc_compile_options_t that can be used
        /// to modify the functionality of a compiled module.
        /// A return of NULL indicates that there was an error initializing the options.
        /// Any function operating on shaderc_compile_options_t must offer the
        /// basic thread-safety guarantee.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_initialize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compile_options_t shaderc_compile_options_initialize();
        
        /// <summary>
        /// Returns a copy of the given shaderc_compile_options_t.
        /// If NULL is passed as the parameter the call is the same as
        /// shaderc_compile_options_init.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_clone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compile_options_t shaderc_compile_options_clone(libshaderc.shaderc_compile_options_t options);
        
        /// <summary>
        /// Releases the compilation options. It is invalid to use the given
        /// shaderc_compile_options_t object in any future calls. It is safe to pass
        /// NULL to this function, and doing such will have no effect.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_release")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_release(libshaderc.shaderc_compile_options_t options);
        
        /// <summary>
        /// Adds a predefined macro to the compilation options. This has the same
        /// effect as passing -Dname=value to the command-line compiler.  If value
        /// is NULL, it has the same effect as passing -Dname to the command-line
        /// compiler. If a macro definition with the same name has previously been
        /// added, the value is replaced with the new value. The macro name and
        /// value are passed in with char pointers, which point to their data, and
        /// the lengths of their data. The strings that the name and value pointers
        /// point to must remain valid for the duration of the call, but can be
        /// modified or deleted after this function has returned. In case of adding
        /// a valueless macro, the value argument should be a null pointer or the
        /// value_length should be 0u.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_add_macro_definition")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_add_macro_definition(libshaderc.shaderc_compile_options_t options, byte* name, nuint name_length, byte* value, nuint value_length);
        
        /// <summary>
        /// Adds a predefined macro to the compilation options. This has the same
        /// effect as passing -Dname=value to the command-line compiler.  If value
        /// is NULL, it has the same effect as passing -Dname to the command-line
        /// compiler. If a macro definition with the same name has previously been
        /// added, the value is replaced with the new value. The macro name and
        /// value are passed in with char pointers, which point to their data, and
        /// the lengths of their data. The strings that the name and value pointers
        /// point to must remain valid for the duration of the call, but can be
        /// modified or deleted after this function has returned. In case of adding
        /// a valueless macro, the value argument should be a null pointer or the
        /// value_length should be 0u.
        /// </summary>
        public static void shaderc_compile_options_add_macro_definition(libshaderc.shaderc_compile_options_t options, ReadOnlySpan<char> name, ReadOnlySpan<char> value)
        {
            byte* name__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn name__marshaller = new();
            byte* value__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn value__marshaller = new();
            try
            {
                name__marshaller.FromManaged(name, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                name__ = name__marshaller.ToUnmanaged();
                value__marshaller.FromManaged(value, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                value__ = value__marshaller.ToUnmanaged();
                shaderc_compile_options_add_macro_definition(options, name__, (nuint)name__marshaller.Length, value__, (nuint)value__marshaller.Length);
            }
            finally
            {
                name__marshaller.Free();
                value__marshaller.Free();
            }
        }
        
        /// <summary>
        /// Sets the source language.  The default is GLSL.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_source_language")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_source_language(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_source_language lang);
        
        /// <summary>
        /// Sets the compiler mode to generate debug information in the output.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_generate_debug_info")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_generate_debug_info(libshaderc.shaderc_compile_options_t options);
        
        /// <summary>
        /// Sets the compiler optimization level to the given level. Only the last one
        /// takes effect if multiple calls of this function exist.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_optimization_level")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_optimization_level(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_optimization_level level);
        
        /// <summary>
        /// Forces the GLSL language version and profile to a given pair. The version
        /// number is the same as would appear in the #version annotation in the source.
        /// Version and profile specified here overrides the #version annotation in the
        /// source. Use profile: 'shaderc_profile_none' for GLSL versions that do not
        /// define profiles, e.g. versions below 150.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_forced_version_profile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_forced_version_profile(libshaderc.shaderc_compile_options_t options, int version, libshaderc.shaderc_profile profile);
        
        /// <summary>
        /// Sets includer callback functions.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_include_callbacks")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_include_callbacks(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_include_resolve_fn resolver, libshaderc.shaderc_include_result_release_fn result_releaser, void* user_data);
        
        /// <summary>
        /// Sets the compiler mode to suppress warnings, overriding warnings-as-errors
        /// mode. When both suppress-warnings and warnings-as-errors modes are
        /// turned on, warning messages will be inhibited, and will not be emitted
        /// as error messages.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_suppress_warnings")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_suppress_warnings(libshaderc.shaderc_compile_options_t options);
        
        /// <summary>
        /// Sets the target shader environment, affecting which warnings or errors will
        /// be issued.  The version will be for distinguishing between different versions
        /// of the target environment.  The version value should be either 0 or
        /// a value listed in shaderc_env_version.  The 0 value maps to Vulkan 1.0 if
        /// |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_target_env")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_target_env(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_target_env target, uint version);
        
        /// <summary>
        /// Sets the target SPIR-V version. The generated module will use this version
        /// of SPIR-V.  Each target environment determines what versions of SPIR-V
        /// it can consume.  Defaults to the highest version of SPIR-V 1.0 which is
        /// required to be supported by the target environment.  E.g. Default to SPIR-V
        /// 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_target_spirv")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_target_spirv(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_spirv_version version);
        
        /// <summary>
        /// Sets the compiler mode to treat all warnings as errors. Note the
        /// suppress-warnings mode overrides this option, i.e. if both
        /// warning-as-errors and suppress-warnings modes are set, warnings will not
        /// be emitted as error messages.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_warnings_as_errors")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_warnings_as_errors(libshaderc.shaderc_compile_options_t options);
        
        /// <summary>
        /// Sets a resource limit.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_limit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_limit(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_limit limit, int value);
        
        /// <summary>
        /// Sets whether the compiler should automatically assign bindings to uniforms
        /// that aren't already explicitly bound in the shader source.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_auto_bind_uniforms")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_auto_bind_uniforms(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool auto_bind);
        
        /// <summary>
        /// Sets whether the compiler should automatically remove sampler variables
        /// and convert image variables to combined image-sampler variables.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_auto_combined_image_sampler")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_auto_combined_image_sampler(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool upgrade);
        
        /// <summary>
        /// Sets whether the compiler should use HLSL IO mapping rules for bindings.
        /// Defaults to false.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_io_mapping")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_io_mapping(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool hlsl_iomap);
        
        /// <summary>
        /// Sets whether the compiler should determine block member offsets using HLSL
        /// packing rules instead of standard GLSL rules.  Defaults to false.  Only
        /// affects GLSL compilation.  HLSL rules are always used when compiling HLSL.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_offsets")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_offsets(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool hlsl_offsets);
        
        /// <summary>
        /// Sets the base binding number used for for a uniform resource type when
        /// automatically assigning bindings.  For GLSL compilation, sets the lowest
        /// automatically assigned number.  For HLSL compilation, the regsiter number
        /// assigned to the resource is added to this specified base.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_binding_base")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_binding_base(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_uniform_kind kind, uint @base);
        
        /// <summary>
        /// Like shaderc_compile_options_set_binding_base, but only takes effect when
        /// compiling a given shader stage.  The stage is assumed to be one of vertex,
        /// fragment, tessellation evaluation, tesselation control, geometry, or compute.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_binding_base_for_stage")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_binding_base_for_stage(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_shader_kind shader_kind, libshaderc.shaderc_uniform_kind kind, uint @base);
        
        /// <summary>
        /// Sets whether the compiler should preserve all bindings, even when those
        /// bindings are not used.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_preserve_bindings")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_preserve_bindings(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool preserve_bindings);
        
        /// <summary>
        /// Sets whether the compiler should automatically assign locations to
        /// uniform variables that don't have explicit locations in the shader source.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_auto_map_locations")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_auto_map_locations(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool auto_map);
        
        /// <summary>
        /// Sets a descriptor set and binding for an HLSL register in the given stage.
        /// This method keeps a copy of the string data.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_shader_kind shader_kind, byte* reg, byte* set, byte* binding);
        
        /// <summary>
        /// Sets a descriptor set and binding for an HLSL register in the given stage.
        /// This method keeps a copy of the string data.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage(libshaderc.shaderc_compile_options_t options, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> reg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> set, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> binding);
        
        /// <summary>
        /// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,
        /// but affects all shader stages.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_register_set_and_binding")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_register_set_and_binding(libshaderc.shaderc_compile_options_t options, byte* reg, byte* set, byte* binding);
        
        /// <summary>
        /// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,
        /// but affects all shader stages.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_register_set_and_binding")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_register_set_and_binding(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> reg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> set, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> binding);
        
        /// <summary>
        /// Sets whether the compiler should enable extension
        /// SPV_GOOGLE_hlsl_functionality1.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_functionality1")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_functionality1(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool enable);
        
        /// <summary>
        /// Sets whether 16-bit types are supported in HLSL or not.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_hlsl_16bit_types")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_hlsl_16bit_types(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool enable);
        
        /// <summary>
        /// Sets whether the compiler should invert position.Y output in vertex shader.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_invert_y")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_invert_y(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool enable);
        
        /// <summary>
        /// Sets whether the compiler generates code for max and min builtins which,
        /// if given a NaN operand, will return the other operand. Similarly, the clamp
        /// builtin will favour the non-NaN operands, as if clamp were implemented
        /// as a composition of max and min.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_options_set_nan_clamp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_compile_options_set_nan_clamp(libshaderc.shaderc_compile_options_t options, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)] bool enable);
        
        /// <summary>
        /// Takes a GLSL source string and the associated shader kind, input file
        /// name, compiles it according to the given additional_options. If the shader
        /// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,
        /// the compiler will try to deduce the shader kind from the source
        /// string and a failure in deducing will generate an error. Currently only
        /// #pragma annotation is supported. If the shader kind is set to one of the
        /// default shader kinds, the compiler will fall back to the default shader
        /// kind in case it failed to deduce the shader kind from source string.
        /// The input_file_name is a null-termintated string. It is used as a tag to
        /// identify the source string in cases like emitting error messages. It
        /// doesn't have to be a 'file name'.
        /// The source string will be compiled into SPIR-V binary and a
        /// shaderc_compilation_result will be returned to hold the results.
        /// The entry_point_name null-terminated string defines the name of the entry
        /// point to associate with this GLSL source. If the additional_options
        /// parameter is not null, then the compilation is modified by any options
        /// present.  May be safely called from multiple threads without explicit
        /// synchronization. If there was failure in allocating the compiler object,
        /// null will be returned.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_spv")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, byte* input_file_name, byte* entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Takes a GLSL source string and the associated shader kind, input file
        /// name, compiles it according to the given additional_options. If the shader
        /// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,
        /// the compiler will try to deduce the shader kind from the source
        /// string and a failure in deducing will generate an error. Currently only
        /// #pragma annotation is supported. If the shader kind is set to one of the
        /// default shader kinds, the compiler will fall back to the default shader
        /// kind in case it failed to deduce the shader kind from source string.
        /// The input_file_name is a null-termintated string. It is used as a tag to
        /// identify the source string in cases like emitting error messages. It
        /// doesn't have to be a 'file name'.
        /// The source string will be compiled into SPIR-V binary and a
        /// shaderc_compilation_result will be returned to hold the results.
        /// The entry_point_name null-terminated string defines the name of the entry
        /// point to associate with this GLSL source. If the additional_options
        /// parameter is not null, then the compilation is modified by any options
        /// present.  May be safely called from multiple threads without explicit
        /// synchronization. If there was failure in allocating the compiler object,
        /// null will be returned.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_spv")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Takes a GLSL source string and the associated shader kind, input file
        /// name, compiles it according to the given additional_options. If the shader
        /// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,
        /// the compiler will try to deduce the shader kind from the source
        /// string and a failure in deducing will generate an error. Currently only
        /// #pragma annotation is supported. If the shader kind is set to one of the
        /// default shader kinds, the compiler will fall back to the default shader
        /// kind in case it failed to deduce the shader kind from source string.
        /// The input_file_name is a null-termintated string. It is used as a tag to
        /// identify the source string in cases like emitting error messages. It
        /// doesn't have to be a 'file name'.
        /// The source string will be compiled into SPIR-V binary and a
        /// shaderc_compilation_result will be returned to hold the results.
        /// The entry_point_name null-terminated string defines the name of the entry
        /// point to associate with this GLSL source. If the additional_options
        /// parameter is not null, then the compilation is modified by any options
        /// present.  May be safely called from multiple threads without explicit
        /// synchronization. If there was failure in allocating the compiler object,
        /// null will be returned.
        /// </summary>
        public static libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv(libshaderc.shaderc_compiler_t compiler, ReadOnlySpan<char> source_text, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options)
        {
            byte* source_text__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn source_text__marshaller = new();
            try
            {
                source_text__marshaller.FromManaged(source_text, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                source_text__ = source_text__marshaller.ToUnmanaged();
                return shaderc_compile_into_spv(compiler, source_text__, (nuint)source_text__marshaller.Length, shader_kind, input_file_name, entry_point_name, additional_options);
            }
            finally
            {
                source_text__marshaller.Free();
            }
        }
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text
        /// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined
        /// by the SPIRV-Tools open source project.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_spv_assembly")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv_assembly(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, byte* input_file_name, byte* entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text
        /// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined
        /// by the SPIRV-Tools open source project.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_spv_assembly")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv_assembly(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text
        /// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined
        /// by the SPIRV-Tools open source project.
        /// </summary>
        public static libshaderc.shaderc_compilation_result_t shaderc_compile_into_spv_assembly(libshaderc.shaderc_compiler_t compiler, ReadOnlySpan<char> source_text, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options)
        {
            byte* source_text__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn source_text__marshaller = new();
            try
            {
                source_text__marshaller.FromManaged(source_text, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                source_text__ = source_text__marshaller.ToUnmanaged();
                return shaderc_compile_into_spv_assembly(compiler, source_text__, (nuint)source_text__marshaller.Length, shader_kind, input_file_name, entry_point_name, additional_options);
            }
            finally
            {
                source_text__marshaller.Free();
            }
        }
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains preprocessed source
        /// code instead of a SPIR-V binary module
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_preprocessed_text")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_preprocessed_text(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, byte* input_file_name, byte* entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains preprocessed source
        /// code instead of a SPIR-V binary module
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_compile_into_preprocessed_text")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_compile_into_preprocessed_text(libshaderc.shaderc_compiler_t compiler, byte* source_text, nuint source_text_size, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Like shaderc_compile_into_spv, but the result contains preprocessed source
        /// code instead of a SPIR-V binary module
        /// </summary>
        public static libshaderc.shaderc_compilation_result_t shaderc_compile_into_preprocessed_text(libshaderc.shaderc_compiler_t compiler, ReadOnlySpan<char> source_text, libshaderc.shaderc_shader_kind shader_kind, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> input_file_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> entry_point_name, libshaderc.shaderc_compile_options_t additional_options)
        {
            byte* source_text__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn source_text__marshaller = new();
            try
            {
                source_text__marshaller.FromManaged(source_text, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                source_text__ = source_text__marshaller.ToUnmanaged();
                return shaderc_compile_into_preprocessed_text(compiler, source_text__, (nuint)source_text__marshaller.Length, shader_kind, input_file_name, entry_point_name, additional_options);
            }
            finally
            {
                source_text__marshaller.Free();
            }
        }
        
        /// <summary>
        /// Takes an assembly string of the format defined in the SPIRV-Tools project
        /// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),
        /// assembles it into SPIR-V binary and a shaderc_compilation_result will be
        /// returned to hold the results.
        /// The assembling will pick options suitable for assembling specified in the
        /// additional_options parameter.
        /// May be safely called from multiple threads without explicit synchronization.
        /// If there was failure in allocating the compiler object, null will be
        /// returned.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_assemble_into_spv")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_result_t shaderc_assemble_into_spv(libshaderc.shaderc_compiler_t compiler, byte* source_assembly, nuint source_assembly_size, libshaderc.shaderc_compile_options_t additional_options);
        
        /// <summary>
        /// Takes an assembly string of the format defined in the SPIRV-Tools project
        /// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),
        /// assembles it into SPIR-V binary and a shaderc_compilation_result will be
        /// returned to hold the results.
        /// The assembling will pick options suitable for assembling specified in the
        /// additional_options parameter.
        /// May be safely called from multiple threads without explicit synchronization.
        /// If there was failure in allocating the compiler object, null will be
        /// returned.
        /// </summary>
        public static libshaderc.shaderc_compilation_result_t shaderc_assemble_into_spv(libshaderc.shaderc_compiler_t compiler, ReadOnlySpan<char> source_assembly, libshaderc.shaderc_compile_options_t additional_options)
        {
            byte* source_assembly__ = default;
            global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn source_assembly__marshaller = new();
            try
            {
                source_assembly__marshaller.FromManaged(source_assembly, stackalloc byte[global::XenoAtom.Interop.Utf8CustomMarshaller.ManagedToUnmanagedIn.BufferSize]);
                source_assembly__ = source_assembly__marshaller.ToUnmanaged();
                return shaderc_assemble_into_spv(compiler, source_assembly__, (nuint)source_assembly__marshaller.Length, additional_options);
            }
            finally
            {
                source_assembly__marshaller.Free();
            }
        }
        
        /// <summary>
        /// Releases the resources held by the result object. It is invalid to use the
        /// result object for any further operations.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_release")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_result_release(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns the number of bytes of the compilation output data in a result
        /// object.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_length")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial nuint shaderc_result_get_length(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns the number of warnings generated during the compilation.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_num_warnings")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial nuint shaderc_result_get_num_warnings(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns the number of errors generated during the compilation.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_num_errors")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial nuint shaderc_result_get_num_errors(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns the compilation status, indicating whether the compilation succeeded,
        /// or failed due to some reasons, like invalid shader stage or compilation
        /// errors.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_compilation_status")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial libshaderc.shaderc_compilation_status shaderc_result_get_compilation_status(libshaderc.shaderc_compilation_result_t arg0);
        
        /// <summary>
        /// Returns a pointer to the start of the compilation output data bytes, either
        /// SPIR-V binary or char string. When the source string is compiled into SPIR-V
        /// binary, this is guaranteed to be castable to a uint32_t*. If the result
        /// contains assembly text or preprocessed source text, the pointer will point to
        /// the resulting array of characters.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_bytes")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial byte* shaderc_result_get_bytes(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns a null-terminated string that contains any error messages generated
        /// during the compilation.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_error_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial byte* shaderc_result_get_error_message_(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Returns a null-terminated string that contains any error messages generated
        /// during the compilation.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_result_get_error_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string shaderc_result_get_error_message(libshaderc.shaderc_compilation_result_t result);
        
        /// <summary>
        /// Provides the version 
        /// &amp;
        /// revision of the SPIR-V which will be produced
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_get_spv_version")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void shaderc_get_spv_version(out uint version, out uint revision);
        
        /// <summary>
        /// Parses the version and profile from a given null-terminated string
        /// containing both version and profile, like: '450core'. Returns false if
        /// the string can not be parsed. Returns true when the parsing succeeds. The
        /// parsed version and profile are returned through arguments.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_parse_version_profile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        [return:global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public static partial bool shaderc_parse_version_profile(byte* str, out int version, out libshaderc.shaderc_profile profile);
        
        /// <summary>
        /// Parses the version and profile from a given null-terminated string
        /// containing both version and profile, like: '450core'. Returns false if
        /// the string can not be parsed. Returns true when the parsing succeeds. The
        /// parsed version and profile are returned through arguments.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shaderc_parse_version_profile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        [return:global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.U1)]
        public static partial bool shaderc_parse_version_profile([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, out int version, out libshaderc.shaderc_profile profile);
    }
}
