//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Bitmask specifying image constraints flags
        /// </summary>
        [Flags]
        public enum VkImageConstraintsInfoFlagBitsFUCHSIA : uint
        {
            VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = unchecked((uint)1),
            
            VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = unchecked((uint)2),
            
            VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = unchecked((uint)4),
            
            VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = unchecked((uint)8),
            
            /// <summary>
            /// Specifies that protected memory is optional for the buffer collection.
            /// </summary>
            VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = unchecked((uint)16),
            
            VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_MAX_ENUM_FUCHSIA = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA;
        
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA;
        
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA;
        
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA;
        
        /// <summary>
        /// Specifies that protected memory is optional for the buffer collection.
        /// </summary>
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA;
        
        public const vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_MAX_ENUM_FUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA.VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_MAX_ENUM_FUCHSIA;
        
        /// <summary>
        /// Structure specifying parameters of a newly created ImagePipe surface object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_imagepipe_surface</para>
        /// </remarks>
        public partial struct VkImagePipeSurfaceCreateInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkImagePipeSurfaceCreateFlagsFUCHSIA flags;
            
            /// <summary>
            /// A <c>zx_handle_t</c> referring to the ImagePipe to associate with the surface.
            /// </summary>
            public uint imagePipeHandle;
        }
        
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_imagepipe_surface</para>
        /// </remarks>
        public readonly partial struct VkImagePipeSurfaceCreateFlagsFUCHSIA : IEquatable<vulkan.VkImagePipeSurfaceCreateFlagsFUCHSIA>
        {
            public VkImagePipeSurfaceCreateFlagsFUCHSIA(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkImagePipeSurfaceCreateFlagsFUCHSIA other && Equals(other);
            
            public bool Equals(VkImagePipeSurfaceCreateFlagsFUCHSIA other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkImagePipeSurfaceCreateFlagsFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.VkImagePipeSurfaceCreateFlagsFUCHSIA (vulkan.VkFlags from) => new vulkan.VkImagePipeSurfaceCreateFlagsFUCHSIA(from);
            
            public static bool operator ==(VkImagePipeSurfaceCreateFlagsFUCHSIA left, VkImagePipeSurfaceCreateFlagsFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(VkImagePipeSurfaceCreateFlagsFUCHSIA left, VkImagePipeSurfaceCreateFlagsFUCHSIA right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure specifying import parameters for Zircon handle to external memory
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        public partial struct VkImportMemoryZirconHandleInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of <see cref="M:handle"/>.
            /// </summary>
            public vulkan.VkExternalMemoryHandleTypeFlagBits handleType;
            
            /// <summary>
            /// A <c>zx_handle_t</c> (Zircon) handle to the external memory.
            /// </summary>
            public uint handle;
        }
        
        /// <summary>
        /// Structure specifying Zircon handle compatible external memory
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        public partial struct VkMemoryZirconHandlePropertiesFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask containing one bit set for every memory type which the specified handle can be imported as.
            /// </summary>
            public uint memoryTypeBits;
        }
        
        /// <summary>
        /// Structure specifying export parameters for Zircon handle to device memory
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        public partial struct VkMemoryGetZirconHandleInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkDeviceMemory"/> being exported.
            /// </summary>
            public vulkan.VkDeviceMemory memory;
            
            /// <summary>
            /// A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of the handle pointed to by <see cref="M:vkGetMemoryZirconHandleFUCHSIA"/>.
            /// </summary>
            public vulkan.VkExternalMemoryHandleTypeFlagBits handleType;
        }
        
        /// <summary>
        /// Structure specifying Zircon event handle to import to a semaphore
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        public partial struct VkImportSemaphoreZirconHandleInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The semaphore into which the payload will be imported.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkSemaphoreImportFlagBits"/> specifying additional parameters for the semaphore payload import operation.
            /// </summary>
            public vulkan.VkSemaphoreImportFlags flags;
            
            /// <summary>
            /// A <see cref="T:VkExternalSemaphoreHandleTypeFlagBits"/> value specifying the type of <see cref="M:zirconHandle"/>.
            /// </summary>
            public vulkan.VkExternalSemaphoreHandleTypeFlagBits handleType;
            
            /// <summary>
            /// The external handle to import.
            /// </summary>
            public uint zirconHandle;
        }
        
        /// <summary>
        /// Structure describing a Zircon event handle semaphore export operation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        public partial struct VkSemaphoreGetZirconHandleInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The semaphore from which state will be exported.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            /// <summary>
            /// A <see cref="T:VkExternalSemaphoreHandleTypeFlagBits"/> value specifying the type of handle requested.
            /// </summary>
            public vulkan.VkExternalSemaphoreHandleTypeFlagBits handleType;
        }
        
        /// <summary>
        /// Structure specifying desired parameters to create the buffer collection
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferCollectionCreateInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="M:zx_handle_t"/> containing the Sysmem client's buffer collection token
            /// </summary>
            public uint collectionToken;
        }
        
        /// <summary>
        /// Structure to specify the Sysmem buffer to import
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkImportMemoryBufferCollectionFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkBufferCollectionFUCHSIA"/> handle
            /// </summary>
            public vulkan.VkBufferCollectionFUCHSIA collection;
            
            /// <summary>
            /// The index of the buffer to import from <see cref="M:collection"/>
            /// </summary>
            public uint index;
        }
        
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public readonly partial struct VkBufferCollectionFUCHSIA : IEquatable<vulkan.VkBufferCollectionFUCHSIA>
        {
            public VkBufferCollectionFUCHSIA(vulkan.VkBufferCollectionFUCHSIA_T value) => this.Value = value;
            
            public vulkan.VkBufferCollectionFUCHSIA_T Value { get; }
            
            public override bool Equals(object obj) => obj is VkBufferCollectionFUCHSIA other && Equals(other);
            
            public bool Equals(VkBufferCollectionFUCHSIA other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkBufferCollectionFUCHSIA_T (vulkan.VkBufferCollectionFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.VkBufferCollectionFUCHSIA (vulkan.VkBufferCollectionFUCHSIA_T from) => new vulkan.VkBufferCollectionFUCHSIA(from);
            
            public static bool operator ==(VkBufferCollectionFUCHSIA left, VkBufferCollectionFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(VkBufferCollectionFUCHSIA left, VkBufferCollectionFUCHSIA right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Create a VkBufferCollectionFUCHSIA-compatible VkImage
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferCollectionImageCreateInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkBufferCollectionFUCHSIA"/> handle
            /// </summary>
            public vulkan.VkBufferCollectionFUCHSIA collection;
            
            /// <summary>
            /// The index of the buffer in the buffer collection from which the memory will be imported
            /// </summary>
            public uint index;
        }
        
        /// <summary>
        /// Structure of general buffer collection constraints
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferCollectionConstraintsInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The minimum number of buffers available in the collection
            /// </summary>
            public uint minBufferCount;
            
            /// <summary>
            /// The maximum number of buffers allowed in the collection
            /// </summary>
            public uint maxBufferCount;
            
            /// <summary>
            /// The per-participant minimum buffers for camping
            /// </summary>
            public uint minBufferCountForCamping;
            
            /// <summary>
            /// The per-participant minimum buffers for dedicated slack
            /// </summary>
            public uint minBufferCountForDedicatedSlack;
            
            /// <summary>
            /// The per-participant minimum buffers for shared slack
            /// </summary>
            public uint minBufferCountForSharedSlack;
        }
        
        /// <summary>
        /// Structure buffer-based buffer collection constraints
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferConstraintsInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBufferCreateInfo createInfo;
            
            /// <summary>
            /// Bitmask of <see cref="T:VkFormatFeatureFlagBits"/> required features of the buffers in the buffer collection
            /// </summary>
            public vulkan.VkFormatFeatureFlags requiredFormatFeatures;
            
            /// <summary>
            /// Used to supply parameters for the negotiation and allocation of the buffer collection
            /// </summary>
            public vulkan.VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
        }
        
        /// <summary>
        /// Create a VkBufferCollectionFUCHSIA-compatible VkBuffer
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferCollectionBufferCreateInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkBufferCollectionFUCHSIA"/> handle
            /// </summary>
            public vulkan.VkBufferCollectionFUCHSIA collection;
            
            /// <summary>
            /// The index of the buffer in the buffer collection from which the memory will be imported
            /// </summary>
            public uint index;
        }
        
        /// <summary>
        /// Structure describing the buffer collections color space
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkSysmemColorSpaceFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Value of the Sysmem <c>ColorSpaceType</c>
            /// </summary>
            public uint colorSpace;
        }
        
        /// <summary>
        /// Structure specifying the negotiated format chosen by Sysmem
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkBufferCollectionPropertiesFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask containing one bit set for every memory type which the buffer collection can be imported as buffer collection
            /// </summary>
            public uint memoryTypeBits;
            
            /// <summary>
            /// The number of buffers in the collection
            /// </summary>
            public uint bufferCount;
            
            /// <summary>
            /// As described in Sysmem chosen create infos
            /// </summary>
            public uint createInfoIndex;
            
            /// <summary>
            /// The Sysmem <c>PixelFormatType</c> as defined in `fuchsia.sysmem/image_formats.fidl`
            /// </summary>
            public ulong sysmemPixelFormat;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkFormatFeatureFlagBits"/> shared by the buffer collection
            /// </summary>
            public vulkan.VkFormatFeatureFlags formatFeatures;
            
            /// <summary>
            /// A <see cref="T:VkSysmemColorSpaceFUCHSIA"/> struct specifying the color space
            /// </summary>
            public vulkan.VkSysmemColorSpaceFUCHSIA sysmemColorSpaceIndex;
            
            /// <summary>
            /// A <see cref="T:VkComponentMapping"/> struct specifying the component mapping
            /// </summary>
            public vulkan.VkComponentMapping samplerYcbcrConversionComponents;
            
            /// <summary>
            /// A <see cref="T:VkSamplerYcbcrModelConversion"/> value specifying the suggested {YCbCr} model
            /// </summary>
            public vulkan.VkSamplerYcbcrModelConversion suggestedYcbcrModel;
            
            /// <summary>
            /// A <see cref="T:VkSamplerYcbcrRange"/> value specifying the suggested {YCbCr} range
            /// </summary>
            public vulkan.VkSamplerYcbcrRange suggestedYcbcrRange;
            
            /// <summary>
            /// A <see cref="T:VkChromaLocation"/> value specifying the suggested X chroma offset
            /// </summary>
            public vulkan.VkChromaLocation suggestedXChromaOffset;
            
            /// <summary>
            /// A <see cref="T:VkChromaLocation"/> value specifying the suggested Y chroma offset
            /// </summary>
            public vulkan.VkChromaLocation suggestedYChromaOffset;
        }
        
        /// <summary>
        /// Structure image-based buffer collection constraints
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkImageFormatConstraintsInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkImageCreateInfo"/> used to create a <see cref="T:VkImage"/> that is to use memory from the <see cref="T:VkBufferCollectionFUCHSIA"/>
            /// </summary>
            public vulkan.VkImageCreateInfo imageCreateInfo;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkFormatFeatureFlagBits"/> specifying required features of the buffers in the buffer collection
            /// </summary>
            public vulkan.VkFormatFeatureFlags requiredFormatFeatures;
            
            /// <summary>
            /// Reserved for future use
            /// </summary>
            public vulkan.VkImageFormatConstraintsFlagsFUCHSIA flags;
            
            /// <summary>
            /// A <c>PixelFormatType</c> value from the `fuchsia.sysmem/image_formats.fidl` FIDL interface
            /// </summary>
            public ulong sysmemPixelFormat;
            
            /// <summary>
            /// The element count of <see cref="M:pColorSpaces"/>
            /// </summary>
            public uint colorSpaceCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkSysmemColorSpaceFUCHSIA"/> structs of size <see cref="M:colorSpaceCount"/>
            /// </summary>
            public vulkan.VkSysmemColorSpaceFUCHSIA* pColorSpaces;
        }
        
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public readonly partial struct VkImageFormatConstraintsFlagsFUCHSIA : IEquatable<vulkan.VkImageFormatConstraintsFlagsFUCHSIA>
        {
            public VkImageFormatConstraintsFlagsFUCHSIA(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkImageFormatConstraintsFlagsFUCHSIA other && Equals(other);
            
            public bool Equals(VkImageFormatConstraintsFlagsFUCHSIA other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkImageFormatConstraintsFlagsFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.VkImageFormatConstraintsFlagsFUCHSIA (vulkan.VkFlags from) => new vulkan.VkImageFormatConstraintsFlagsFUCHSIA(from);
            
            public static bool operator ==(VkImageFormatConstraintsFlagsFUCHSIA left, VkImageFormatConstraintsFlagsFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(VkImageFormatConstraintsFlagsFUCHSIA left, VkImageFormatConstraintsFlagsFUCHSIA right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure of image-based buffer collection constraints
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public partial struct VkImageConstraintsInfoFUCHSIA()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of elements in <see cref="M:pFormatConstraints"/>.
            /// </summary>
            public uint formatConstraintsCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkImageFormatConstraintsInfoFUCHSIA"/> structures of size <see cref="M:formatConstraintsCount"/> that is used to further constrain buffer collection format selection for image-based buffer collections.
            /// </summary>
            public vulkan.VkImageFormatConstraintsInfoFUCHSIA* pFormatConstraints;
            
            /// <summary>
            /// A <see cref="T:VkBufferCollectionConstraintsInfoFUCHSIA"/> structure used to supply parameters for the negotiation and allocation for buffer-based buffer collections.
            /// </summary>
            public vulkan.VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
            
            /// <summary>
            /// A <see cref="T:VkImageConstraintsInfoFlagBitsFUCHSIA"/> value specifying hints about the type of memory Sysmem should allocate for the buffer collection.
            /// </summary>
            public vulkan.VkImageConstraintsInfoFlagsFUCHSIA flags;
        }
        
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public readonly partial struct VkImageConstraintsInfoFlagsFUCHSIA : IEquatable<vulkan.VkImageConstraintsInfoFlagsFUCHSIA>
        {
            public VkImageConstraintsInfoFlagsFUCHSIA(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkImageConstraintsInfoFlagsFUCHSIA other && Equals(other);
            
            public bool Equals(VkImageConstraintsInfoFlagsFUCHSIA other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkImageConstraintsInfoFlagsFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.VkImageConstraintsInfoFlagsFUCHSIA (vulkan.VkFlags from) => new vulkan.VkImageConstraintsInfoFlagsFUCHSIA(from);
            
            public static bool operator ==(VkImageConstraintsInfoFlagsFUCHSIA left, VkImageConstraintsInfoFlagsFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(VkImageConstraintsInfoFlagsFUCHSIA left, VkImageConstraintsInfoFlagsFUCHSIA right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA (vulkan.VkImageConstraintsInfoFlagsFUCHSIA from) => (vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA)(uint)from.Value;
            
            public static implicit operator vulkan.VkImageConstraintsInfoFlagsFUCHSIA (vulkan.VkImageConstraintsInfoFlagBitsFUCHSIA from) => new vulkan.VkImageConstraintsInfoFlagsFUCHSIA((uint)from);
        }
        
        public readonly partial struct PFN_vkCreateImagePipeSurfaceFUCHSIA : IEquatable<vulkan.PFN_vkCreateImagePipeSurfaceFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkCreateImagePipeSurfaceFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateImagePipeSurfaceFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkCreateImagePipeSurfaceFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> (vulkan.PFN_vkCreateImagePipeSurfaceFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateImagePipeSurfaceFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateImagePipeSurfaceFUCHSIA(from);
            
            public static bool operator ==(PFN_vkCreateImagePipeSurfaceFUCHSIA left, PFN_vkCreateImagePipeSurfaceFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateImagePipeSurfaceFUCHSIA left, PFN_vkCreateImagePipeSurfaceFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Create a <see cref="T:VkSurfaceKHR"/> object for a Fuchsia ImagePipe
            /// </summary>
            /// <param name="instance">The instance to associate with the surface.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkImagePipeSurfaceCreateInfoFUCHSIA"/> structure containing parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_imagepipe_surface</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkSurfaceKHR* pSurface)
            {
                return Value(instance, pCreateInfo, pAllocator, pSurface);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetMemoryZirconHandleFUCHSIA : IEquatable<vulkan.PFN_vkGetMemoryZirconHandleFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkGetMemoryZirconHandleFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetMemoryZirconHandleFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkGetMemoryZirconHandleFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> (vulkan.PFN_vkGetMemoryZirconHandleFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetMemoryZirconHandleFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetMemoryZirconHandleFUCHSIA(from);
            
            public static bool operator ==(PFN_vkGetMemoryZirconHandleFUCHSIA left, PFN_vkGetMemoryZirconHandleFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetMemoryZirconHandleFUCHSIA left, PFN_vkGetMemoryZirconHandleFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Zircon handle for an external memory object
            /// </summary>
            /// <param name="device">The <see cref="T:VkDevice"/>.</param>
            /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkMemoryGetZirconHandleInfoFUCHSIA"/> structure.</param>
            /// <param name="pZirconHandle">A pointer to a <c>zx_handle_t</c> which holds the resulting Zircon handle.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_external_memory</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, uint* pZirconHandle)
            {
                return Value(device, pGetZirconHandleInfo, pZirconHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA : IEquatable<vulkan.PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, uint, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, uint, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, uint, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, uint, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA(from);
            
            public static bool operator ==(PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA left, PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA left, PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Zircon handle properties for an external memory object
            /// </summary>
            /// <param name="device">The <see cref="T:VkDevice"/>.</param>
            /// <param name="handleType">A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of <paramref name="zirconHandle"/></param>
            /// <param name="zirconHandle">A <c>zx_handle_t</c> (Zircon) handle to the external resource.</param>
            /// <param name="pMemoryZirconHandleProperties">A pointer to a <see cref="T:VkMemoryZirconHandlePropertiesFUCHSIA"/> structure in which the result will be stored.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_external_memory</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkExternalMemoryHandleTypeFlagBits handleType, uint zirconHandle, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties)
            {
                return Value(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkImportSemaphoreZirconHandleFUCHSIA : IEquatable<vulkan.PFN_vkImportSemaphoreZirconHandleFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkImportSemaphoreZirconHandleFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkImportSemaphoreZirconHandleFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkImportSemaphoreZirconHandleFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkImportSemaphoreZirconHandleFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkImportSemaphoreZirconHandleFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkImportSemaphoreZirconHandleFUCHSIA(from);
            
            public static bool operator ==(PFN_vkImportSemaphoreZirconHandleFUCHSIA left, PFN_vkImportSemaphoreZirconHandleFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkImportSemaphoreZirconHandleFUCHSIA left, PFN_vkImportSemaphoreZirconHandleFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Import a semaphore from a Zircon event handle
            /// </summary>
            /// <param name="device">The logical device that created the semaphore.</param>
            /// <param name="pImportSemaphoreZirconHandleInfo">A pointer to a <see cref="T:VkImportSemaphoreZirconHandleInfoFUCHSIA"/> structure specifying the semaphore and import parameters.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo)
            {
                return Value(device, pImportSemaphoreZirconHandleInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetSemaphoreZirconHandleFUCHSIA : IEquatable<vulkan.PFN_vkGetSemaphoreZirconHandleFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkGetSemaphoreZirconHandleFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetSemaphoreZirconHandleFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkGetSemaphoreZirconHandleFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> (vulkan.PFN_vkGetSemaphoreZirconHandleFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetSemaphoreZirconHandleFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA*, uint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetSemaphoreZirconHandleFUCHSIA(from);
            
            public static bool operator ==(PFN_vkGetSemaphoreZirconHandleFUCHSIA left, PFN_vkGetSemaphoreZirconHandleFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetSemaphoreZirconHandleFUCHSIA left, PFN_vkGetSemaphoreZirconHandleFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Zircon event handle for a semaphore
            /// </summary>
            /// <param name="device">The logical device that created the semaphore being exported.</param>
            /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkSemaphoreGetZirconHandleInfoFUCHSIA"/> structure containing parameters of the export operation.</param>
            /// <param name="pZirconHandle">Will return the Zircon event handle representing the semaphore payload.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, uint* pZirconHandle)
            {
                return Value(device, pGetZirconHandleInfo, pZirconHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkCreateBufferCollectionFUCHSIA : IEquatable<vulkan.PFN_vkCreateBufferCollectionFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkCreateBufferCollectionFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkBufferCollectionFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkBufferCollectionFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateBufferCollectionFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkCreateBufferCollectionFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkBufferCollectionFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkCreateBufferCollectionFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateBufferCollectionFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionCreateInfoFUCHSIA*, vulkan.VkAllocationCallbacks*, vulkan.VkBufferCollectionFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateBufferCollectionFUCHSIA(from);
            
            public static bool operator ==(PFN_vkCreateBufferCollectionFUCHSIA left, PFN_vkCreateBufferCollectionFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateBufferCollectionFUCHSIA left, PFN_vkCreateBufferCollectionFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Create a new buffer collection
            /// </summary>
            /// <param name="device">The logical device that creates the <see cref="T:VkBufferCollectionFUCHSIA"/></param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkBufferCollectionCreateInfoFUCHSIA"/> structure containing parameters affecting creation of the buffer collection</param>
            /// <param name="pAllocator">A pointer to a <see cref="T:VkAllocationCallbacks"/> structure controlling host memory allocation as described in the Memory Allocation chapter This parameter is optional.</param>
            /// <param name="pBufferCollection">A pointer to a <see cref="T:VkBufferCollectionFUCHSIA"/> handle in which the resulting buffer collection object is returned</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkBufferCollectionFUCHSIA* pCollection)
            {
                return Value(device, pCreateInfo, pAllocator, pCollection);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkSetBufferCollectionImageConstraintsFUCHSIA : IEquatable<vulkan.PFN_vkSetBufferCollectionImageConstraintsFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkSetBufferCollectionImageConstraintsFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkImageConstraintsInfoFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkImageConstraintsInfoFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkSetBufferCollectionImageConstraintsFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkSetBufferCollectionImageConstraintsFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkImageConstraintsInfoFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkSetBufferCollectionImageConstraintsFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkSetBufferCollectionImageConstraintsFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkImageConstraintsInfoFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkSetBufferCollectionImageConstraintsFUCHSIA(from);
            
            public static bool operator ==(PFN_vkSetBufferCollectionImageConstraintsFUCHSIA left, PFN_vkSetBufferCollectionImageConstraintsFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkSetBufferCollectionImageConstraintsFUCHSIA left, PFN_vkSetBufferCollectionImageConstraintsFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Set image-based constraints for a buffer collection
            /// </summary>
            /// <param name="device">The logical device</param>
            /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
            /// <param name="pImageConstraintsInfo">A pointer to a <see cref="T:VkImageConstraintsInfoFUCHSIA"/> structure</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo)
            {
                return Value(device, collection, pImageConstraintsInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA : IEquatable<vulkan.PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferConstraintsInfoFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferConstraintsInfoFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferConstraintsInfoFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferConstraintsInfoFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA(from);
            
            public static bool operator ==(PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA left, PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA left, PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Set buffer-based constraints for a buffer collection
            /// </summary>
            /// <param name="device">The logical device</param>
            /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
            /// <param name="pBufferConstraintsInfo">A pointer to a <see cref="T:VkBufferConstraintsInfoFUCHSIA"/> structure</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo)
            {
                return Value(device, collection, pBufferConstraintsInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkDestroyBufferCollectionFUCHSIA : IEquatable<vulkan.PFN_vkDestroyBufferCollectionFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkDestroyBufferCollectionFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkAllocationCallbacks*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkAllocationCallbacks*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkDestroyBufferCollectionFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkDestroyBufferCollectionFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkAllocationCallbacks*, void> (vulkan.PFN_vkDestroyBufferCollectionFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkDestroyBufferCollectionFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkAllocationCallbacks*, void> from) => new vulkan.PFN_vkDestroyBufferCollectionFUCHSIA(from);
            
            public static bool operator ==(PFN_vkDestroyBufferCollectionFUCHSIA left, PFN_vkDestroyBufferCollectionFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkDestroyBufferCollectionFUCHSIA left, PFN_vkDestroyBufferCollectionFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Destroy a buffer collection
            /// </summary>
            /// <param name="device">The logical device that creates the <see cref="T:VkBufferCollectionFUCHSIA"/></param>
            /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
            /// <param name="pAllocator">A pointer to a <see cref="T:VkAllocationCallbacks"/> structure controlling host memory allocation as described in the Memory Allocation chapter This parameter is optional.</param>
            /// <remarks>
            /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
            /// </remarks>
            public void Invoke(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkAllocationCallbacks* pAllocator)
            {
                Value(device, collection, pAllocator);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetBufferCollectionPropertiesFUCHSIA : IEquatable<vulkan.PFN_vkGetBufferCollectionPropertiesFUCHSIA>, IvkFunctionPointer
        {
            public PFN_vkGetBufferCollectionPropertiesFUCHSIA(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferCollectionPropertiesFUCHSIA*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferCollectionPropertiesFUCHSIA*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetBufferCollectionPropertiesFUCHSIA other && Equals(other);
            
            public bool Equals(PFN_vkGetBufferCollectionPropertiesFUCHSIA other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferCollectionPropertiesFUCHSIA*, vulkan.VkResult> (vulkan.PFN_vkGetBufferCollectionPropertiesFUCHSIA from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetBufferCollectionPropertiesFUCHSIA (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkBufferCollectionFUCHSIA, vulkan.VkBufferCollectionPropertiesFUCHSIA*, vulkan.VkResult> from) => new vulkan.PFN_vkGetBufferCollectionPropertiesFUCHSIA(from);
            
            public static bool operator ==(PFN_vkGetBufferCollectionPropertiesFUCHSIA left, PFN_vkGetBufferCollectionPropertiesFUCHSIA right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetBufferCollectionPropertiesFUCHSIA left, PFN_vkGetBufferCollectionPropertiesFUCHSIA right) => !left.Equals(right);
            
            /// <summary>
            /// Retrieve properties from a buffer collection
            /// </summary>
            /// <param name="device">The logical device handle</param>
            /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
            /// <param name="pProperties">A pointer to the retrieved <see cref="T:VkBufferCollectionPropertiesFUCHSIA"/> struct</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
            /// </list>
            /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkBufferCollectionPropertiesFUCHSIA* pProperties)
            {
                return Value(device, collection, pProperties);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        /// <summary>
        /// Create a <see cref="T:VkSurfaceKHR"/> object for a Fuchsia ImagePipe
        /// </summary>
        /// <param name="instance">The instance to associate with the surface.</param>
        /// <param name="pCreateInfo">A pointer to a <see cref="T:VkImagePipeSurfaceCreateInfoFUCHSIA"/> structure containing parameters affecting the creation of the surface object.</param>
        /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
        /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_imagepipe_surface</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCreateImagePipeSurfaceFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkCreateImagePipeSurfaceFUCHSIA(vulkan.VkInstance instance, vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkSurfaceKHR* pSurface);
        
        /// <summary>
        /// Create a <see cref="T:VkSurfaceKHR"/> object for a Fuchsia ImagePipe
        /// </summary>
        /// <param name="instance">The instance to associate with the surface.</param>
        /// <param name="pCreateInfo">A pointer to a <see cref="T:VkImagePipeSurfaceCreateInfoFUCHSIA"/> structure containing parameters affecting the creation of the surface object.</param>
        /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
        /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_imagepipe_surface</para>
        /// </remarks>
        public static vulkan.VkResult vkCreateImagePipeSurfaceFUCHSIA(vulkan.VkInstance instance, in vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, out vulkan.VkSurfaceKHR pSurface)
        {
            fixed (vulkan.VkImagePipeSurfaceCreateInfoFUCHSIA* __pCreateInfo_local = &pCreateInfo)
            fixed (vulkan.VkSurfaceKHR* __pSurface_local = &pSurface)
            return vkCreateImagePipeSurfaceFUCHSIA(instance, __pCreateInfo_local, pAllocator, __pSurface_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateImagePipeSurfaceFUCHSIA> vkCreateImagePipeSurfaceFUCHSIA_ => new("vkCreateImagePipeSurfaceFUCHSIA"u8);
        
        /// <summary>
        /// Get a Zircon handle for an external memory object
        /// </summary>
        /// <param name="device">The <see cref="T:VkDevice"/>.</param>
        /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkMemoryGetZirconHandleInfoFUCHSIA"/> structure.</param>
        /// <param name="pZirconHandle">A pointer to a <c>zx_handle_t</c> which holds the resulting Zircon handle.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetMemoryZirconHandleFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetMemoryZirconHandleFUCHSIA(vulkan.VkDevice device, vulkan.VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, uint* pZirconHandle);
        
        /// <summary>
        /// Get a Zircon handle for an external memory object
        /// </summary>
        /// <param name="device">The <see cref="T:VkDevice"/>.</param>
        /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkMemoryGetZirconHandleInfoFUCHSIA"/> structure.</param>
        /// <param name="pZirconHandle">A pointer to a <c>zx_handle_t</c> which holds the resulting Zircon handle.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        public static vulkan.VkResult vkGetMemoryZirconHandleFUCHSIA(vulkan.VkDevice device, in vulkan.VkMemoryGetZirconHandleInfoFUCHSIA pGetZirconHandleInfo, out uint pZirconHandle)
        {
            fixed (vulkan.VkMemoryGetZirconHandleInfoFUCHSIA* __pGetZirconHandleInfo_local = &pGetZirconHandleInfo)
            fixed (uint* __pZirconHandle_local = &pZirconHandle)
            return vkGetMemoryZirconHandleFUCHSIA(device, __pGetZirconHandleInfo_local, __pZirconHandle_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetMemoryZirconHandleFUCHSIA> vkGetMemoryZirconHandleFUCHSIA_ => new("vkGetMemoryZirconHandleFUCHSIA"u8);
        
        /// <summary>
        /// Get a Zircon handle properties for an external memory object
        /// </summary>
        /// <param name="device">The <see cref="T:VkDevice"/>.</param>
        /// <param name="handleType">A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of <paramref name="zirconHandle"/></param>
        /// <param name="zirconHandle">A <c>zx_handle_t</c> (Zircon) handle to the external resource.</param>
        /// <param name="pMemoryZirconHandleProperties">A pointer to a <see cref="T:VkMemoryZirconHandlePropertiesFUCHSIA"/> structure in which the result will be stored.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetMemoryZirconHandlePropertiesFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetMemoryZirconHandlePropertiesFUCHSIA(vulkan.VkDevice device, vulkan.VkExternalMemoryHandleTypeFlagBits handleType, uint zirconHandle, vulkan.VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties);
        
        /// <summary>
        /// Get a Zircon handle properties for an external memory object
        /// </summary>
        /// <param name="device">The <see cref="T:VkDevice"/>.</param>
        /// <param name="handleType">A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of <paramref name="zirconHandle"/></param>
        /// <param name="zirconHandle">A <c>zx_handle_t</c> (Zircon) handle to the external resource.</param>
        /// <param name="pMemoryZirconHandleProperties">A pointer to a <see cref="T:VkMemoryZirconHandlePropertiesFUCHSIA"/> structure in which the result will be stored.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_memory</para>
        /// </remarks>
        public static vulkan.VkResult vkGetMemoryZirconHandlePropertiesFUCHSIA(vulkan.VkDevice device, vulkan.VkExternalMemoryHandleTypeFlagBits handleType, uint zirconHandle, ref vulkan.VkMemoryZirconHandlePropertiesFUCHSIA pMemoryZirconHandleProperties)
        {
            fixed (vulkan.VkMemoryZirconHandlePropertiesFUCHSIA* __pMemoryZirconHandleProperties_local = &pMemoryZirconHandleProperties)
            return vkGetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, __pMemoryZirconHandleProperties_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA> vkGetMemoryZirconHandlePropertiesFUCHSIA_ => new("vkGetMemoryZirconHandlePropertiesFUCHSIA"u8);
        
        /// <summary>
        /// Import a semaphore from a Zircon event handle
        /// </summary>
        /// <param name="device">The logical device that created the semaphore.</param>
        /// <param name="pImportSemaphoreZirconHandleInfo">A pointer to a <see cref="T:VkImportSemaphoreZirconHandleInfoFUCHSIA"/> structure specifying the semaphore and import parameters.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkImportSemaphoreZirconHandleFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkImportSemaphoreZirconHandleFUCHSIA(vulkan.VkDevice device, vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo);
        
        /// <summary>
        /// Import a semaphore from a Zircon event handle
        /// </summary>
        /// <param name="device">The logical device that created the semaphore.</param>
        /// <param name="pImportSemaphoreZirconHandleInfo">A pointer to a <see cref="T:VkImportSemaphoreZirconHandleInfoFUCHSIA"/> structure specifying the semaphore and import parameters.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        public static vulkan.VkResult vkImportSemaphoreZirconHandleFUCHSIA(vulkan.VkDevice device, in vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA pImportSemaphoreZirconHandleInfo)
        {
            fixed (vulkan.VkImportSemaphoreZirconHandleInfoFUCHSIA* __pImportSemaphoreZirconHandleInfo_local = &pImportSemaphoreZirconHandleInfo)
            return vkImportSemaphoreZirconHandleFUCHSIA(device, __pImportSemaphoreZirconHandleInfo_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkImportSemaphoreZirconHandleFUCHSIA> vkImportSemaphoreZirconHandleFUCHSIA_ => new("vkImportSemaphoreZirconHandleFUCHSIA"u8);
        
        /// <summary>
        /// Get a Zircon event handle for a semaphore
        /// </summary>
        /// <param name="device">The logical device that created the semaphore being exported.</param>
        /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkSemaphoreGetZirconHandleInfoFUCHSIA"/> structure containing parameters of the export operation.</param>
        /// <param name="pZirconHandle">Will return the Zircon event handle representing the semaphore payload.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetSemaphoreZirconHandleFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetSemaphoreZirconHandleFUCHSIA(vulkan.VkDevice device, vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, uint* pZirconHandle);
        
        /// <summary>
        /// Get a Zircon event handle for a semaphore
        /// </summary>
        /// <param name="device">The logical device that created the semaphore being exported.</param>
        /// <param name="pGetZirconHandleInfo">A pointer to a <see cref="T:VkSemaphoreGetZirconHandleInfoFUCHSIA"/> structure containing parameters of the export operation.</param>
        /// <param name="pZirconHandle">Will return the Zircon event handle representing the semaphore payload.</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_external_semaphore</para>
        /// </remarks>
        public static vulkan.VkResult vkGetSemaphoreZirconHandleFUCHSIA(vulkan.VkDevice device, in vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA pGetZirconHandleInfo, out uint pZirconHandle)
        {
            fixed (vulkan.VkSemaphoreGetZirconHandleInfoFUCHSIA* __pGetZirconHandleInfo_local = &pGetZirconHandleInfo)
            fixed (uint* __pZirconHandle_local = &pZirconHandle)
            return vkGetSemaphoreZirconHandleFUCHSIA(device, __pGetZirconHandleInfo_local, __pZirconHandle_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetSemaphoreZirconHandleFUCHSIA> vkGetSemaphoreZirconHandleFUCHSIA_ => new("vkGetSemaphoreZirconHandleFUCHSIA"u8);
        
        /// <summary>
        /// Create a new buffer collection
        /// </summary>
        /// <param name="device">The logical device that creates the <see cref="T:VkBufferCollectionFUCHSIA"/></param>
        /// <param name="pCreateInfo">A pointer to a <see cref="T:VkBufferCollectionCreateInfoFUCHSIA"/> structure containing parameters affecting creation of the buffer collection</param>
        /// <param name="pAllocator">A pointer to a <see cref="T:VkAllocationCallbacks"/> structure controlling host memory allocation as described in the Memory Allocation chapter This parameter is optional.</param>
        /// <param name="pBufferCollection">A pointer to a <see cref="T:VkBufferCollectionFUCHSIA"/> handle in which the resulting buffer collection object is returned</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCreateBufferCollectionFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkCreateBufferCollectionFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkBufferCollectionFUCHSIA* pCollection);
        
        /// <summary>
        /// Create a new buffer collection
        /// </summary>
        /// <param name="device">The logical device that creates the <see cref="T:VkBufferCollectionFUCHSIA"/></param>
        /// <param name="pCreateInfo">A pointer to a <see cref="T:VkBufferCollectionCreateInfoFUCHSIA"/> structure containing parameters affecting creation of the buffer collection</param>
        /// <param name="pAllocator">A pointer to a <see cref="T:VkAllocationCallbacks"/> structure controlling host memory allocation as described in the Memory Allocation chapter This parameter is optional.</param>
        /// <param name="pBufferCollection">A pointer to a <see cref="T:VkBufferCollectionFUCHSIA"/> handle in which the resulting buffer collection object is returned</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public static vulkan.VkResult vkCreateBufferCollectionFUCHSIA(vulkan.VkDevice device, in vulkan.VkBufferCollectionCreateInfoFUCHSIA pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, out vulkan.VkBufferCollectionFUCHSIA pCollection)
        {
            fixed (vulkan.VkBufferCollectionCreateInfoFUCHSIA* __pCreateInfo_local = &pCreateInfo)
            fixed (vulkan.VkBufferCollectionFUCHSIA* __pCollection_local = &pCollection)
            return vkCreateBufferCollectionFUCHSIA(device, __pCreateInfo_local, pAllocator, __pCollection_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateBufferCollectionFUCHSIA> vkCreateBufferCollectionFUCHSIA_ => new("vkCreateBufferCollectionFUCHSIA"u8);
        
        /// <summary>
        /// Set image-based constraints for a buffer collection
        /// </summary>
        /// <param name="device">The logical device</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pImageConstraintsInfo">A pointer to a <see cref="T:VkImageConstraintsInfoFUCHSIA"/> structure</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkSetBufferCollectionImageConstraintsFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkSetBufferCollectionImageConstraintsFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo);
        
        /// <summary>
        /// Set image-based constraints for a buffer collection
        /// </summary>
        /// <param name="device">The logical device</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pImageConstraintsInfo">A pointer to a <see cref="T:VkImageConstraintsInfoFUCHSIA"/> structure</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public static vulkan.VkResult vkSetBufferCollectionImageConstraintsFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, in vulkan.VkImageConstraintsInfoFUCHSIA pImageConstraintsInfo)
        {
            fixed (vulkan.VkImageConstraintsInfoFUCHSIA* __pImageConstraintsInfo_local = &pImageConstraintsInfo)
            return vkSetBufferCollectionImageConstraintsFUCHSIA(device, collection, __pImageConstraintsInfo_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkSetBufferCollectionImageConstraintsFUCHSIA> vkSetBufferCollectionImageConstraintsFUCHSIA_ => new("vkSetBufferCollectionImageConstraintsFUCHSIA"u8);
        
        /// <summary>
        /// Set buffer-based constraints for a buffer collection
        /// </summary>
        /// <param name="device">The logical device</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pBufferConstraintsInfo">A pointer to a <see cref="T:VkBufferConstraintsInfoFUCHSIA"/> structure</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkSetBufferCollectionBufferConstraintsFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkSetBufferCollectionBufferConstraintsFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo);
        
        /// <summary>
        /// Set buffer-based constraints for a buffer collection
        /// </summary>
        /// <param name="device">The logical device</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pBufferConstraintsInfo">A pointer to a <see cref="T:VkBufferConstraintsInfoFUCHSIA"/> structure</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_FORMAT_NOT_SUPPORTED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public static vulkan.VkResult vkSetBufferCollectionBufferConstraintsFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, in vulkan.VkBufferConstraintsInfoFUCHSIA pBufferConstraintsInfo)
        {
            fixed (vulkan.VkBufferConstraintsInfoFUCHSIA* __pBufferConstraintsInfo_local = &pBufferConstraintsInfo)
            return vkSetBufferCollectionBufferConstraintsFUCHSIA(device, collection, __pBufferConstraintsInfo_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA> vkSetBufferCollectionBufferConstraintsFUCHSIA_ => new("vkSetBufferCollectionBufferConstraintsFUCHSIA"u8);
        
        /// <summary>
        /// Destroy a buffer collection
        /// </summary>
        /// <param name="device">The logical device that creates the <see cref="T:VkBufferCollectionFUCHSIA"/></param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pAllocator">A pointer to a <see cref="T:VkAllocationCallbacks"/> structure controlling host memory allocation as described in the Memory Allocation chapter This parameter is optional.</param>
        /// <remarks>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkDestroyBufferCollectionFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkDestroyBufferCollectionFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkAllocationCallbacks* pAllocator);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkDestroyBufferCollectionFUCHSIA> vkDestroyBufferCollectionFUCHSIA_ => new("vkDestroyBufferCollectionFUCHSIA"u8);
        
        /// <summary>
        /// Retrieve properties from a buffer collection
        /// </summary>
        /// <param name="device">The logical device handle</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pProperties">A pointer to the retrieved <see cref="T:VkBufferCollectionPropertiesFUCHSIA"/> struct</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetBufferCollectionPropertiesFUCHSIA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetBufferCollectionPropertiesFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, vulkan.VkBufferCollectionPropertiesFUCHSIA* pProperties);
        
        /// <summary>
        /// Retrieve properties from a buffer collection
        /// </summary>
        /// <param name="device">The logical device handle</param>
        /// <param name="collection">The <see cref="T:VkBufferCollectionFUCHSIA"/> handle</param>
        /// <param name="pProperties">A pointer to the retrieved <see cref="T:VkBufferCollectionPropertiesFUCHSIA"/> struct</param>
        /// <remarks>
        /// <list type="bullet">
        /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
        /// </list>
        /// <list type="bullet">
        /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
        /// </list>
        /// <para>Extension: VK_FUCHSIA_buffer_collection</para>
        /// </remarks>
        public static vulkan.VkResult vkGetBufferCollectionPropertiesFUCHSIA(vulkan.VkDevice device, vulkan.VkBufferCollectionFUCHSIA collection, ref vulkan.VkBufferCollectionPropertiesFUCHSIA pProperties)
        {
            fixed (vulkan.VkBufferCollectionPropertiesFUCHSIA* __pProperties_local = &pProperties)
            return vkGetBufferCollectionPropertiesFUCHSIA(device, collection, __pProperties_local);
        }
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetBufferCollectionPropertiesFUCHSIA> vkGetBufferCollectionPropertiesFUCHSIA_ => new("vkGetBufferCollectionPropertiesFUCHSIA"u8);
    }
}
