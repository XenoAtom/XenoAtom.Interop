//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Hint values an application can specify affecting full-screen transition behavior
        /// </summary>
        public enum VkFullScreenExclusiveEXT : uint
        {
            VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = unchecked((uint)0),
            
            VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = unchecked((uint)1),
            
            VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = unchecked((uint)2),
            
            VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = unchecked((uint)3),
            
            VK_FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkFullScreenExclusiveEXT VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = VkFullScreenExclusiveEXT.VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT;
        
        public const vulkan.VkFullScreenExclusiveEXT VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = VkFullScreenExclusiveEXT.VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT;
        
        public const vulkan.VkFullScreenExclusiveEXT VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = VkFullScreenExclusiveEXT.VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT;
        
        public const vulkan.VkFullScreenExclusiveEXT VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = VkFullScreenExclusiveEXT.VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT;
        
        public const vulkan.VkFullScreenExclusiveEXT VK_FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT = VkFullScreenExclusiveEXT.VK_FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT;
        
        /// <summary>
        /// Structure specifying parameters of a newly created Win32 surface object
        /// </summary>
        public partial struct VkWin32SurfaceCreateInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkWin32SurfaceCreateFlagsKHR flags;
            
            /// <summary>
            /// The Win32 <c>HINSTANCE</c> for the window to associate the surface with.
            /// </summary>
            public nint hinstance;
            
            /// <summary>
            /// The Win32 <c>HWND</c> for the window to associate the surface with.
            /// </summary>
            public nint hwnd;
        }
        
        public readonly partial struct VkWin32SurfaceCreateFlagsKHR : IEquatable<VkWin32SurfaceCreateFlagsKHR>
        {
            public VkWin32SurfaceCreateFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkWin32SurfaceCreateFlagsKHR other && Equals(other);
            
            public bool Equals(VkWin32SurfaceCreateFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkWin32SurfaceCreateFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkWin32SurfaceCreateFlagsKHR (vulkan.VkFlags from) => new vulkan.VkWin32SurfaceCreateFlagsKHR(from);
            
            public static bool operator ==(VkWin32SurfaceCreateFlagsKHR left, VkWin32SurfaceCreateFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkWin32SurfaceCreateFlagsKHR left, VkWin32SurfaceCreateFlagsKHR right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Import Win32 memory created on the same physical device
        /// </summary>
        public partial struct VkImportMemoryWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of <see cref="M:handle"/> or <see cref="M:name"/>.
            /// </summary>
            public vulkan.VkExternalMemoryHandleTypeFlagBits handleType;
            
            /// <summary>
            /// `NULL` or the external handle to import.
            /// </summary>
            public nint handle;
            
            /// <summary>
            /// `NULL` or a null-terminated UTF-16 string naming the payload to import.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Structure specifying additional attributes of Windows handles exported from a memory
        /// </summary>
        public partial struct VkExportMemoryWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a Windows <c>SECURITY_ATTRIBUTES</c> structure specifying security attributes of the handle.
            /// </summary>
            public void* pAttributes;
            
            /// <summary>
            /// A <c>DWORD</c> specifying access rights of the handle.
            /// </summary>
            public uint dwAccess;
            
            /// <summary>
            /// A null-terminated UTF-16 string to associate with the payload referenced by NT handles exported from the created memory.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Properties of External Memory Windows Handles
        /// </summary>
        public partial struct VkMemoryWin32HandlePropertiesKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask containing one bit set for every memory type which the specified windows handle can: be imported as.
            /// </summary>
            public uint memoryTypeBits;
        }
        
        /// <summary>
        /// Structure describing a Win32 handle memory export operation
        /// </summary>
        public partial struct VkMemoryGetWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The memory object from which the handle will be exported.
            /// </summary>
            public vulkan.VkDeviceMemory memory;
            
            /// <summary>
            /// A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of handle requested.
            /// </summary>
            public vulkan.VkExternalMemoryHandleTypeFlagBits handleType;
        }
        
        /// <summary>
        /// Use the Windows keyed mutex mechanism to synchronize work
        /// </summary>
        public partial struct VkWin32KeyedMutexAcquireReleaseInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pAcquireSyncs"/>, <see cref="M:pAcquireKeys"/>, and <see cref="M:pAcquireTimeouts"/> arrays.
            /// </summary>
            public uint acquireCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkDeviceMemory"/> objects which were imported from Direct3D 11 resources.
            /// </summary>
            public vulkan.VkDeviceMemory* pAcquireSyncs;
            
            /// <summary>
            /// A pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in <see cref="M:pAcquireSyncs"/>.
            /// </summary>
            public ulong* pAcquireKeys;
            
            /// <summary>
            /// A pointer to an array of timeout values, in millisecond units, for each acquire specified in <see cref="M:pAcquireKeys"/>.
            /// </summary>
            public uint* pAcquireTimeouts;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pReleaseSyncs"/> and <see cref="M:pReleaseKeys"/> arrays.
            /// </summary>
            public uint releaseCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkDeviceMemory"/> objects which were imported from Direct3D 11 resources.
            /// </summary>
            public vulkan.VkDeviceMemory* pReleaseSyncs;
            
            /// <summary>
            /// A pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in <see cref="M:pReleaseSyncs"/>.
            /// </summary>
            public ulong* pReleaseKeys;
        }
        
        /// <summary>
        /// Structure specifying Windows handle to import to a semaphore
        /// </summary>
        public partial struct VkImportSemaphoreWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The semaphore into which the payload will be imported.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkSemaphoreImportFlagBits"/> specifying additional parameters for the semaphore payload import operation.
            /// </summary>
            public vulkan.VkSemaphoreImportFlags flags;
            
            /// <summary>
            /// A <see cref="T:VkExternalSemaphoreHandleTypeFlagBits"/> value specifying the type of <see cref="M:handle"/>.
            /// </summary>
            public vulkan.VkExternalSemaphoreHandleTypeFlagBits handleType;
            
            /// <summary>
            /// `NULL` or the external handle to import.
            /// </summary>
            public nint handle;
            
            /// <summary>
            /// `NULL` or a null-terminated UTF-16 string naming the underlying synchronization primitive to import.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Structure specifying additional attributes of Windows handles exported from a semaphore
        /// </summary>
        public partial struct VkExportSemaphoreWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a Windows <c>SECURITY_ATTRIBUTES</c> structure specifying security attributes of the handle.
            /// </summary>
            public void* pAttributes;
            
            /// <summary>
            /// A <c>DWORD</c> specifying access rights of the handle.
            /// </summary>
            public uint dwAccess;
            
            /// <summary>
            /// A null-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Structure specifying values for Direct3D 12 fence-backed semaphores
        /// </summary>
        public partial struct VkD3D12FenceSubmitInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of semaphore wait values specified in <see cref="M:pWaitSemaphoreValues"/>.
            /// </summary>
            public uint waitSemaphoreValuesCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:waitSemaphoreValuesCount"/> values for the corresponding semaphores in <see cref="T:VkSubmitInfo.pWaitSemaphores"/> to wait for.
            /// </summary>
            public ulong* pWaitSemaphoreValues;
            
            /// <summary>
            /// The number of semaphore signal values specified in <see cref="M:pSignalSemaphoreValues"/>.
            /// </summary>
            public uint signalSemaphoreValuesCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:signalSemaphoreValuesCount"/> values for the corresponding semaphores in <see cref="T:VkSubmitInfo.pSignalSemaphores"/> to set when signaled.
            /// </summary>
            public ulong* pSignalSemaphoreValues;
        }
        
        /// <summary>
        /// Structure describing a Win32 handle semaphore export operation
        /// </summary>
        public partial struct VkSemaphoreGetWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The semaphore from which state will be exported.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            /// <summary>
            /// A <see cref="T:VkExternalSemaphoreHandleTypeFlagBits"/> value specifying the type of handle requested.
            /// </summary>
            public vulkan.VkExternalSemaphoreHandleTypeFlagBits handleType;
        }
        
        /// <summary>
        /// (None)
        /// </summary>
        public partial struct VkImportFenceWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The fence into which the state will be imported.
            /// </summary>
            public vulkan.VkFence fence;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkFenceImportFlagBits"/> specifying additional parameters for the fence payload import operation.
            /// </summary>
            public vulkan.VkFenceImportFlags flags;
            
            /// <summary>
            /// A <see cref="T:VkExternalFenceHandleTypeFlagBits"/> value specifying the type of <see cref="M:handle"/>.
            /// </summary>
            public vulkan.VkExternalFenceHandleTypeFlagBits handleType;
            
            /// <summary>
            /// `NULL` or the external handle to import.
            /// </summary>
            public nint handle;
            
            /// <summary>
            /// `NULL` or a null-terminated UTF-16 string naming the underlying synchronization primitive to import.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Structure specifying additional attributes of Windows handles exported from a fence
        /// </summary>
        public partial struct VkExportFenceWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a Windows <c>SECURITY_ATTRIBUTES</c> structure specifying security attributes of the handle.
            /// </summary>
            public void* pAttributes;
            
            /// <summary>
            /// A <c>DWORD</c> specifying access rights of the handle.
            /// </summary>
            public uint dwAccess;
            
            /// <summary>
            /// A null-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
            /// </summary>
            public char* name;
        }
        
        /// <summary>
        /// Structure describing a Win32 handle fence export operation
        /// </summary>
        public partial struct VkFenceGetWin32HandleInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The fence from which state will be exported.
            /// </summary>
            public vulkan.VkFence fence;
            
            /// <summary>
            /// A <see cref="T:VkExternalFenceHandleTypeFlagBits"/> value specifying the type of handle requested.
            /// </summary>
            public vulkan.VkExternalFenceHandleTypeFlagBits handleType;
        }
        
        /// <summary>
        /// Import Win32 memory created on the same physical device
        /// </summary>
        public partial struct VkImportMemoryWin32HandleInfoNV
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// `0` or a <see cref="T:VkExternalMemoryHandleTypeFlagBitsNV"/> value specifying the type of memory handle in <see cref="M:handle"/>.
            /// </summary>
            public vulkan.VkExternalMemoryHandleTypeFlagsNV handleType;
            
            /// <summary>
            /// A Windows <c>HANDLE</c> referring to the memory.
            /// </summary>
            public nint handle;
        }
        
        /// <summary>
        /// Specify security attributes and access rights for Win32 memory handles
        /// </summary>
        public partial struct VkExportMemoryWin32HandleInfoNV
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a Windows <c>SECURITY_ATTRIBUTES</c> structure specifying security attributes of the handle.
            /// </summary>
            public void* pAttributes;
            
            /// <summary>
            /// A <c>DWORD</c> specifying access rights of the handle.
            /// </summary>
            public uint dwAccess;
        }
        
        /// <summary>
        /// Use Windows keyex mutex mechanism to synchronize work
        /// </summary>
        public partial struct VkWin32KeyedMutexAcquireReleaseInfoNV
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pAcquireSyncs"/>, <see cref="M:pAcquireKeys"/>, and <see cref="M:pAcquireTimeoutMilliseconds"/> arrays.
            /// </summary>
            public uint acquireCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkDeviceMemory"/> objects which were imported from Direct3D 11 resources.
            /// </summary>
            public vulkan.VkDeviceMemory* pAcquireSyncs;
            
            /// <summary>
            /// A pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in <see cref="M:pAcquireSyncs"/>.
            /// </summary>
            public ulong* pAcquireKeys;
            
            /// <summary>
            /// A pointer to an array of timeout values, in millisecond units, for each acquire specified in <see cref="M:pAcquireKeys"/>.
            /// </summary>
            public uint* pAcquireTimeoutMilliseconds;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pReleaseSyncs"/> and <see cref="M:pReleaseKeys"/> arrays.
            /// </summary>
            public uint releaseCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkDeviceMemory"/> objects which were imported from Direct3D 11 resources.
            /// </summary>
            public vulkan.VkDeviceMemory* pReleaseSyncs;
            
            /// <summary>
            /// A pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in <see cref="M:pReleaseSyncs"/>.
            /// </summary>
            public ulong* pReleaseKeys;
        }
        
        /// <summary>
        /// Structure specifying the preferred full-screen transition behavior
        /// </summary>
        public partial struct VkSurfaceFullScreenExclusiveInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkFullScreenExclusiveEXT"/> value specifying the preferred full-screen transition behavior.
            /// </summary>
            public vulkan.VkFullScreenExclusiveEXT fullScreenExclusive;
        }
        
        /// <summary>
        /// Structure describing full screen exclusive capabilities of a surface
        /// </summary>
        public partial struct VkSurfaceCapabilitiesFullScreenExclusiveEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBool32 fullScreenExclusiveSupported;
        }
        
        /// <summary>
        /// Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode
        /// </summary>
        public partial struct VkSurfaceFullScreenExclusiveWin32InfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Win32 <c>HMONITOR</c> handle identifying the display to create the surface with.
            /// </summary>
            public nint hmonitor;
        }
        
        public readonly partial struct PFN_vkCreateWin32SurfaceKHR : IEquatable<PFN_vkCreateWin32SurfaceKHR>, IvkFunctionPointer
        {
            public PFN_vkCreateWin32SurfaceKHR(delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkWin32SurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkWin32SurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateWin32SurfaceKHR other && Equals(other);
            
            public bool Equals(PFN_vkCreateWin32SurfaceKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkWin32SurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> (vulkan.PFN_vkCreateWin32SurfaceKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateWin32SurfaceKHR (delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkWin32SurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateWin32SurfaceKHR(from);
            
            public static bool operator ==(PFN_vkCreateWin32SurfaceKHR left, PFN_vkCreateWin32SurfaceKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateWin32SurfaceKHR left, PFN_vkCreateWin32SurfaceKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Create a VkSurfaceKHR object for an Win32 native window
            /// </summary>
            /// <param name="instance">The instance to associate the surface with.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkWin32SurfaceCreateInfoKHR"/> structure containing parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, vulkan.VkWin32SurfaceCreateInfoKHR* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkSurfaceKHR* pSurface)
            {
                return Value(instance, pCreateInfo, pAllocator, pSurface);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Create a VkSurfaceKHR object for an Win32 native window
            /// </summary>
            /// <param name="instance">The instance to associate the surface with.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkWin32SurfaceCreateInfoKHR"/> structure containing parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, in vulkan.VkWin32SurfaceCreateInfoKHR pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, out vulkan.VkSurfaceKHR pSurface)
            {
                fixed (vulkan.VkWin32SurfaceCreateInfoKHR* __pCreateInfo_local = &pCreateInfo)
                fixed (vulkan.VkSurfaceKHR* __pSurface_local = &pSurface)
                return this.Invoke(instance, __pCreateInfo_local, pAllocator, __pSurface_local);
            }
        }
        
        public readonly partial struct PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR : IEquatable<PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR>, IvkFunctionPointer
        {
            public PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkBool32> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkBool32> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkBool32> (vulkan.PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkBool32> from) => new vulkan.PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR(from);
            
            public static bool operator ==(PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR left, PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR left, PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Query queue family support for presentation on a Win32 display
            /// </summary>
            /// <param name="physicalDevice">The physical device.</param>
            /// <param name="queueFamilyIndex">The queue family index.</param>
            public vulkan.VkBool32 Invoke(vulkan.VkPhysicalDevice physicalDevice, uint queueFamilyIndex)
            {
                return Value(physicalDevice, queueFamilyIndex);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetMemoryWin32HandleKHR : IEquatable<PFN_vkGetMemoryWin32HandleKHR>, IvkFunctionPointer
        {
            public PFN_vkGetMemoryWin32HandleKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetMemoryWin32HandleKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetMemoryWin32HandleKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> (vulkan.PFN_vkGetMemoryWin32HandleKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetMemoryWin32HandleKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkMemoryGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetMemoryWin32HandleKHR(from);
            
            public static bool operator ==(PFN_vkGetMemoryWin32HandleKHR left, PFN_vkGetMemoryWin32HandleKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetMemoryWin32HandleKHR left, PFN_vkGetMemoryWin32HandleKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Windows HANDLE for a memory object
            /// </summary>
            /// <param name="device">The logical device that created the device memory being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkMemoryGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the payload of the device memory object.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, nint* pHandle)
            {
                return Value(device, pGetWin32HandleInfo, pHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Get a Windows HANDLE for a memory object
            /// </summary>
            /// <param name="device">The logical device that created the device memory being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkMemoryGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the payload of the device memory object.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo, out nint pHandle)
            {
                fixed (vulkan.VkMemoryGetWin32HandleInfoKHR* __pGetWin32HandleInfo_local = &pGetWin32HandleInfo)
                fixed (nint* __pHandle_local = &pHandle)
                return this.Invoke(device, __pGetWin32HandleInfo_local, __pHandle_local);
            }
        }
        
        public readonly partial struct PFN_vkGetMemoryWin32HandlePropertiesKHR : IEquatable<PFN_vkGetMemoryWin32HandlePropertiesKHR>, IvkFunctionPointer
        {
            public PFN_vkGetMemoryWin32HandlePropertiesKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, nint, vulkan.VkMemoryWin32HandlePropertiesKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, nint, vulkan.VkMemoryWin32HandlePropertiesKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetMemoryWin32HandlePropertiesKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetMemoryWin32HandlePropertiesKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, nint, vulkan.VkMemoryWin32HandlePropertiesKHR*, vulkan.VkResult> (vulkan.PFN_vkGetMemoryWin32HandlePropertiesKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetMemoryWin32HandlePropertiesKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExternalMemoryHandleTypeFlagBits, nint, vulkan.VkMemoryWin32HandlePropertiesKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetMemoryWin32HandlePropertiesKHR(from);
            
            public static bool operator ==(PFN_vkGetMemoryWin32HandlePropertiesKHR left, PFN_vkGetMemoryWin32HandlePropertiesKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetMemoryWin32HandlePropertiesKHR left, PFN_vkGetMemoryWin32HandlePropertiesKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Get Properties of External Memory Win32 Handles
            /// </summary>
            /// <param name="device">The logical device that will be importing <paramref name="handle"/>.</param>
            /// <param name="handleType">A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of the handle <paramref name="handle"/>.</param>
            /// <param name="handle">The handle which will be imported.</param>
            /// <param name="pMemoryWin32HandleProperties">A pointer to a <see cref="T:VkMemoryWin32HandlePropertiesKHR"/> structure in which properties of <paramref name="handle"/> are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkExternalMemoryHandleTypeFlagBits handleType, nint handle, vulkan.VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
            {
                return Value(device, handleType, handle, pMemoryWin32HandleProperties);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Get Properties of External Memory Win32 Handles
            /// </summary>
            /// <param name="device">The logical device that will be importing <paramref name="handle"/>.</param>
            /// <param name="handleType">A <see cref="T:VkExternalMemoryHandleTypeFlagBits"/> value specifying the type of the handle <paramref name="handle"/>.</param>
            /// <param name="handle">The handle which will be imported.</param>
            /// <param name="pMemoryWin32HandleProperties">A pointer to a <see cref="T:VkMemoryWin32HandlePropertiesKHR"/> structure in which properties of <paramref name="handle"/> are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkExternalMemoryHandleTypeFlagBits handleType, nint handle, out vulkan.VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties)
            {
                fixed (vulkan.VkMemoryWin32HandlePropertiesKHR* __pMemoryWin32HandleProperties_local = &pMemoryWin32HandleProperties)
                return this.Invoke(device, handleType, handle, __pMemoryWin32HandleProperties_local);
            }
        }
        
        public readonly partial struct PFN_vkImportSemaphoreWin32HandleKHR : IEquatable<PFN_vkImportSemaphoreWin32HandleKHR>, IvkFunctionPointer
        {
            public PFN_vkImportSemaphoreWin32HandleKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreWin32HandleInfoKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreWin32HandleInfoKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkImportSemaphoreWin32HandleKHR other && Equals(other);
            
            public bool Equals(PFN_vkImportSemaphoreWin32HandleKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreWin32HandleInfoKHR*, vulkan.VkResult> (vulkan.PFN_vkImportSemaphoreWin32HandleKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkImportSemaphoreWin32HandleKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportSemaphoreWin32HandleInfoKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkImportSemaphoreWin32HandleKHR(from);
            
            public static bool operator ==(PFN_vkImportSemaphoreWin32HandleKHR left, PFN_vkImportSemaphoreWin32HandleKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkImportSemaphoreWin32HandleKHR left, PFN_vkImportSemaphoreWin32HandleKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Import a semaphore from a Windows HANDLE
            /// </summary>
            /// <param name="device">The logical device that created the semaphore.</param>
            /// <param name="pImportSemaphoreWin32HandleInfo">A pointer to a <see cref="T:VkImportSemaphoreWin32HandleInfoKHR"/> structure specifying the semaphore and import parameters.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
            {
                return Value(device, pImportSemaphoreWin32HandleInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Import a semaphore from a Windows HANDLE
            /// </summary>
            /// <param name="device">The logical device that created the semaphore.</param>
            /// <param name="pImportSemaphoreWin32HandleInfo">A pointer to a <see cref="T:VkImportSemaphoreWin32HandleInfoKHR"/> structure specifying the semaphore and import parameters.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkImportSemaphoreWin32HandleInfoKHR pImportSemaphoreWin32HandleInfo)
            {
                fixed (vulkan.VkImportSemaphoreWin32HandleInfoKHR* __pImportSemaphoreWin32HandleInfo_local = &pImportSemaphoreWin32HandleInfo)
                return this.Invoke(device, __pImportSemaphoreWin32HandleInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkGetSemaphoreWin32HandleKHR : IEquatable<PFN_vkGetSemaphoreWin32HandleKHR>, IvkFunctionPointer
        {
            public PFN_vkGetSemaphoreWin32HandleKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetSemaphoreWin32HandleKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetSemaphoreWin32HandleKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> (vulkan.PFN_vkGetSemaphoreWin32HandleKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetSemaphoreWin32HandleKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSemaphoreGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetSemaphoreWin32HandleKHR(from);
            
            public static bool operator ==(PFN_vkGetSemaphoreWin32HandleKHR left, PFN_vkGetSemaphoreWin32HandleKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetSemaphoreWin32HandleKHR left, PFN_vkGetSemaphoreWin32HandleKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Windows HANDLE for a semaphore
            /// </summary>
            /// <param name="device">The logical device that created the semaphore being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkSemaphoreGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the semaphore state.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, nint* pHandle)
            {
                return Value(device, pGetWin32HandleInfo, pHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Get a Windows HANDLE for a semaphore
            /// </summary>
            /// <param name="device">The logical device that created the semaphore being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkSemaphoreGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the semaphore state.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo, out nint pHandle)
            {
                fixed (vulkan.VkSemaphoreGetWin32HandleInfoKHR* __pGetWin32HandleInfo_local = &pGetWin32HandleInfo)
                fixed (nint* __pHandle_local = &pHandle)
                return this.Invoke(device, __pGetWin32HandleInfo_local, __pHandle_local);
            }
        }
        
        public readonly partial struct PFN_vkImportFenceWin32HandleKHR : IEquatable<PFN_vkImportFenceWin32HandleKHR>, IvkFunctionPointer
        {
            public PFN_vkImportFenceWin32HandleKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportFenceWin32HandleInfoKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportFenceWin32HandleInfoKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkImportFenceWin32HandleKHR other && Equals(other);
            
            public bool Equals(PFN_vkImportFenceWin32HandleKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportFenceWin32HandleInfoKHR*, vulkan.VkResult> (vulkan.PFN_vkImportFenceWin32HandleKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkImportFenceWin32HandleKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkImportFenceWin32HandleInfoKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkImportFenceWin32HandleKHR(from);
            
            public static bool operator ==(PFN_vkImportFenceWin32HandleKHR left, PFN_vkImportFenceWin32HandleKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkImportFenceWin32HandleKHR left, PFN_vkImportFenceWin32HandleKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Import a fence from a Windows HANDLE
            /// </summary>
            /// <param name="device">The logical device that created the fence.</param>
            /// <param name="pImportFenceWin32HandleInfo">A pointer to a <see cref="T:VkImportFenceWin32HandleInfoKHR"/> structure specifying the fence and import parameters.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
            {
                return Value(device, pImportFenceWin32HandleInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Import a fence from a Windows HANDLE
            /// </summary>
            /// <param name="device">The logical device that created the fence.</param>
            /// <param name="pImportFenceWin32HandleInfo">A pointer to a <see cref="T:VkImportFenceWin32HandleInfoKHR"/> structure specifying the fence and import parameters.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_INVALID_EXTERNAL_HANDLE</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkImportFenceWin32HandleInfoKHR pImportFenceWin32HandleInfo)
            {
                fixed (vulkan.VkImportFenceWin32HandleInfoKHR* __pImportFenceWin32HandleInfo_local = &pImportFenceWin32HandleInfo)
                return this.Invoke(device, __pImportFenceWin32HandleInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkGetFenceWin32HandleKHR : IEquatable<PFN_vkGetFenceWin32HandleKHR>, IvkFunctionPointer
        {
            public PFN_vkGetFenceWin32HandleKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkFenceGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkFenceGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetFenceWin32HandleKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetFenceWin32HandleKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkFenceGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> (vulkan.PFN_vkGetFenceWin32HandleKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetFenceWin32HandleKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkFenceGetWin32HandleInfoKHR*, nint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetFenceWin32HandleKHR(from);
            
            public static bool operator ==(PFN_vkGetFenceWin32HandleKHR left, PFN_vkGetFenceWin32HandleKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetFenceWin32HandleKHR left, PFN_vkGetFenceWin32HandleKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Get a Windows HANDLE for a fence
            /// </summary>
            /// <param name="device">The logical device that created the fence being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkFenceGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the fence state.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, nint* pHandle)
            {
                return Value(device, pGetWin32HandleInfo, pHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Get a Windows HANDLE for a fence
            /// </summary>
            /// <param name="device">The logical device that created the fence being exported.</param>
            /// <param name="pGetWin32HandleInfo">A pointer to a <see cref="T:VkFenceGetWin32HandleInfoKHR"/> structure containing parameters of the export operation.</param>
            /// <param name="pHandle">Will return the Windows handle representing the fence state.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkFenceGetWin32HandleInfoKHR pGetWin32HandleInfo, out nint pHandle)
            {
                fixed (vulkan.VkFenceGetWin32HandleInfoKHR* __pGetWin32HandleInfo_local = &pGetWin32HandleInfo)
                fixed (nint* __pHandle_local = &pHandle)
                return this.Invoke(device, __pGetWin32HandleInfo_local, __pHandle_local);
            }
        }
        
        public readonly partial struct PFN_vkGetMemoryWin32HandleNV : IEquatable<PFN_vkGetMemoryWin32HandleNV>, IvkFunctionPointer
        {
            public PFN_vkGetMemoryWin32HandleNV(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkDeviceMemory, vulkan.VkExternalMemoryHandleTypeFlagsNV, nint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkDeviceMemory, vulkan.VkExternalMemoryHandleTypeFlagsNV, nint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetMemoryWin32HandleNV other && Equals(other);
            
            public bool Equals(PFN_vkGetMemoryWin32HandleNV other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkDeviceMemory, vulkan.VkExternalMemoryHandleTypeFlagsNV, nint*, vulkan.VkResult> (vulkan.PFN_vkGetMemoryWin32HandleNV from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetMemoryWin32HandleNV (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkDeviceMemory, vulkan.VkExternalMemoryHandleTypeFlagsNV, nint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetMemoryWin32HandleNV(from);
            
            public static bool operator ==(PFN_vkGetMemoryWin32HandleNV left, PFN_vkGetMemoryWin32HandleNV right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetMemoryWin32HandleNV left, PFN_vkGetMemoryWin32HandleNV right) => !left.Equals(right);
            
            /// <summary>
            /// Retrieve Win32 handle to a device memory object
            /// </summary>
            /// <param name="device">The logical device that owns the memory.</param>
            /// <param name="memory">The <see cref="T:VkDeviceMemory"/> object.</param>
            /// <param name="handleType">A bitmask of <see cref="T:VkExternalMemoryHandleTypeFlagBitsNV"/> containing a single bit specifying the type of handle requested.</param>
            /// <param name="handle">A pointer to a Windows <c>HANDLE</c> in which the handle is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkDeviceMemory memory, vulkan.VkExternalMemoryHandleTypeFlagsNV handleType, nint* pHandle)
            {
                return Value(device, memory, handleType, pHandle);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Retrieve Win32 handle to a device memory object
            /// </summary>
            /// <param name="device">The logical device that owns the memory.</param>
            /// <param name="memory">The <see cref="T:VkDeviceMemory"/> object.</param>
            /// <param name="handleType">A bitmask of <see cref="T:VkExternalMemoryHandleTypeFlagBitsNV"/> containing a single bit specifying the type of handle requested.</param>
            /// <param name="handle">A pointer to a Windows <c>HANDLE</c> in which the handle is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_TOO_MANY_OBJECTS</c></description></item><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkDeviceMemory memory, vulkan.VkExternalMemoryHandleTypeFlagsNV handleType, out nint pHandle)
            {
                fixed (nint* __pHandle_local = &pHandle)
                return this.Invoke(device, memory, handleType, __pHandle_local);
            }
        }
        
        public readonly partial struct PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT : IEquatable<PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT>, IvkFunctionPointer
        {
            public PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, uint*, vulkan.VkPresentModeKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, uint*, vulkan.VkPresentModeKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT other && Equals(other);
            
            public bool Equals(PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, uint*, vulkan.VkPresentModeKHR*, vulkan.VkResult> (vulkan.PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, uint*, vulkan.VkPresentModeKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT(from);
            
            public static bool operator ==(PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT left, PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT left, PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT right) => !left.Equals(right);
            
            /// <summary>
            /// Query supported presentation modes
            /// </summary>
            /// <param name="physicalDevice">The physical device that will be associated with the swapchain to be created, as described for <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pSurfaceInfo">A pointer to a <see cref="T:VkPhysicalDeviceSurfaceInfo2KHR"/> structure describing the surface and other fixed parameters that would be consumed by <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pPresentModeCount">A pointer to an integer related to the number of presentation modes available or queried, as described below.</param>
            /// <param name="pPresentModes">Either `NULL` or a pointer to an array of <see cref="T:VkPresentModeKHR"/> values, indicating the supported presentation modes. This parameter is optional.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_INCOMPLETE</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint* pPresentModeCount, vulkan.VkPresentModeKHR* pPresentModes)
            {
                return Value(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query supported presentation modes
            /// </summary>
            /// <param name="physicalDevice">The physical device that will be associated with the swapchain to be created, as described for <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pSurfaceInfo">A pointer to a <see cref="T:VkPhysicalDeviceSurfaceInfo2KHR"/> structure describing the surface and other fixed parameters that would be consumed by <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pPresentModeCount">A pointer to an integer related to the number of presentation modes available or queried, as described below.</param>
            /// <param name="pPresentModes">Either `NULL` or a pointer to an array of <see cref="T:VkPresentModeKHR"/> values, indicating the supported presentation modes. This parameter is optional.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_INCOMPLETE</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, in vulkan.VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo, Span<vulkan.VkPresentModeKHR> pPresentModes)
            {
                uint __pPresentModeCount_local = checked((uint)pPresentModes.Length);
                fixed (vulkan.VkPhysicalDeviceSurfaceInfo2KHR* __pSurfaceInfo_local = &pSurfaceInfo)
                fixed (vulkan.VkPresentModeKHR* __pPresentModes_local = pPresentModes)
                return this.Invoke(physicalDevice, __pSurfaceInfo_local, &__pPresentModeCount_local, __pPresentModes_local);
            }
            
            /// <summary>
            /// Query supported presentation modes
            /// </summary>
            /// <param name="physicalDevice">The physical device that will be associated with the swapchain to be created, as described for <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pSurfaceInfo">A pointer to a <see cref="T:VkPhysicalDeviceSurfaceInfo2KHR"/> structure describing the surface and other fixed parameters that would be consumed by <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pPresentModeCount">A pointer to an integer related to the number of presentation modes available or queried, as described below.</param>
            /// <param name="pPresentModes">Either `NULL` or a pointer to an array of <see cref="T:VkPresentModeKHR"/> values, indicating the supported presentation modes. This parameter is optional.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_INCOMPLETE</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, in vulkan.VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo, out uint pPresentModeCount)
            {
                pPresentModeCount = default;
                fixed (vulkan.VkPhysicalDeviceSurfaceInfo2KHR* __pSurfaceInfo_local = &pSurfaceInfo)
                fixed (uint* __pPresentModeCount_local = &pPresentModeCount)
                return this.Invoke(physicalDevice, __pSurfaceInfo_local, __pPresentModeCount_local, default);
            }
        }
        
        public readonly partial struct PFN_vkAcquireFullScreenExclusiveModeEXT : IEquatable<PFN_vkAcquireFullScreenExclusiveModeEXT>, IvkFunctionPointer
        {
            public PFN_vkAcquireFullScreenExclusiveModeEXT(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkAcquireFullScreenExclusiveModeEXT other && Equals(other);
            
            public bool Equals(PFN_vkAcquireFullScreenExclusiveModeEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> (vulkan.PFN_vkAcquireFullScreenExclusiveModeEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkAcquireFullScreenExclusiveModeEXT (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> from) => new vulkan.PFN_vkAcquireFullScreenExclusiveModeEXT(from);
            
            public static bool operator ==(PFN_vkAcquireFullScreenExclusiveModeEXT left, PFN_vkAcquireFullScreenExclusiveModeEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkAcquireFullScreenExclusiveModeEXT left, PFN_vkAcquireFullScreenExclusiveModeEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Acquire full-screen exclusive mode for a swapchain
            /// </summary>
            /// <param name="device">The device associated with <paramref name="swapchain"/>.</param>
            /// <param name="swapchain">The swapchain to acquire exclusive full-screen access for.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkSwapchainKHR swapchain)
            {
                return Value(device, swapchain);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkReleaseFullScreenExclusiveModeEXT : IEquatable<PFN_vkReleaseFullScreenExclusiveModeEXT>, IvkFunctionPointer
        {
            public PFN_vkReleaseFullScreenExclusiveModeEXT(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkReleaseFullScreenExclusiveModeEXT other && Equals(other);
            
            public bool Equals(PFN_vkReleaseFullScreenExclusiveModeEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> (vulkan.PFN_vkReleaseFullScreenExclusiveModeEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkReleaseFullScreenExclusiveModeEXT (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkSwapchainKHR, vulkan.VkResult> from) => new vulkan.PFN_vkReleaseFullScreenExclusiveModeEXT(from);
            
            public static bool operator ==(PFN_vkReleaseFullScreenExclusiveModeEXT left, PFN_vkReleaseFullScreenExclusiveModeEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkReleaseFullScreenExclusiveModeEXT left, PFN_vkReleaseFullScreenExclusiveModeEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Release full-screen exclusive mode from a swapchain
            /// </summary>
            /// <param name="device">The device associated with <paramref name="swapchain"/>.</param>
            /// <param name="swapchain">The swapchain to release exclusive full-screen access from.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkSwapchainKHR swapchain)
            {
                return Value(device, swapchain);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetDeviceGroupSurfacePresentModes2EXT : IEquatable<PFN_vkGetDeviceGroupSurfacePresentModes2EXT>, IvkFunctionPointer
        {
            public PFN_vkGetDeviceGroupSurfacePresentModes2EXT(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, vulkan.VkDeviceGroupPresentModeFlagsKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, vulkan.VkDeviceGroupPresentModeFlagsKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetDeviceGroupSurfacePresentModes2EXT other && Equals(other);
            
            public bool Equals(PFN_vkGetDeviceGroupSurfacePresentModes2EXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, vulkan.VkDeviceGroupPresentModeFlagsKHR*, vulkan.VkResult> (vulkan.PFN_vkGetDeviceGroupSurfacePresentModes2EXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetDeviceGroupSurfacePresentModes2EXT (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPhysicalDeviceSurfaceInfo2KHR*, vulkan.VkDeviceGroupPresentModeFlagsKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetDeviceGroupSurfacePresentModes2EXT(from);
            
            public static bool operator ==(PFN_vkGetDeviceGroupSurfacePresentModes2EXT left, PFN_vkGetDeviceGroupSurfacePresentModes2EXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetDeviceGroupSurfacePresentModes2EXT left, PFN_vkGetDeviceGroupSurfacePresentModes2EXT right) => !left.Equals(right);
            
            /// <summary>
            /// Query device group present capabilities for a surface
            /// </summary>
            /// <param name="device">The logical device.</param>
            /// <param name="pSurfaceInfo">A pointer to a <see cref="T:VkPhysicalDeviceSurfaceInfo2KHR"/> structure describing the surface and other fixed parameters that would be consumed by <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pModes">A pointer to a tlink:VkDeviceGroupPresentModeFlagsKHR in which the supported device group present modes for the surface are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, vulkan.VkDeviceGroupPresentModeFlagsKHR* pModes)
            {
                return Value(device, pSurfaceInfo, pModes);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query device group present capabilities for a surface
            /// </summary>
            /// <param name="device">The logical device.</param>
            /// <param name="pSurfaceInfo">A pointer to a <see cref="T:VkPhysicalDeviceSurfaceInfo2KHR"/> structure describing the surface and other fixed parameters that would be consumed by <see cref="M:vkCreateSwapchainKHR"/>.</param>
            /// <param name="pModes">A pointer to a tlink:VkDeviceGroupPresentModeFlagsKHR in which the supported device group present modes for the surface are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_SURFACE_LOST_KHR</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo, vulkan.VkDeviceGroupPresentModeFlagsKHR* pModes)
            {
                fixed (vulkan.VkPhysicalDeviceSurfaceInfo2KHR* __pSurfaceInfo_local = &pSurfaceInfo)
                return this.Invoke(device, __pSurfaceInfo_local, pModes);
            }
        }
        
        public readonly partial struct PFN_vkAcquireWinrtDisplayNV : IEquatable<PFN_vkAcquireWinrtDisplayNV>, IvkFunctionPointer
        {
            public PFN_vkAcquireWinrtDisplayNV(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkDisplayKHR, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkDisplayKHR, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkAcquireWinrtDisplayNV other && Equals(other);
            
            public bool Equals(PFN_vkAcquireWinrtDisplayNV other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkDisplayKHR, vulkan.VkResult> (vulkan.PFN_vkAcquireWinrtDisplayNV from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkAcquireWinrtDisplayNV (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkDisplayKHR, vulkan.VkResult> from) => new vulkan.PFN_vkAcquireWinrtDisplayNV(from);
            
            public static bool operator ==(PFN_vkAcquireWinrtDisplayNV left, PFN_vkAcquireWinrtDisplayNV right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkAcquireWinrtDisplayNV left, PFN_vkAcquireWinrtDisplayNV right) => !left.Equals(right);
            
            /// <summary>
            /// Acquire access to a VkDisplayKHR
            /// </summary>
            /// <param name="physicalDevice">The physical device the display is on.</param>
            /// <param name="display">The display the caller wishes to control in Vulkan.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_DEVICE_LOST</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, vulkan.VkDisplayKHR display)
            {
                return Value(physicalDevice, display);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetWinrtDisplayNV : IEquatable<PFN_vkGetWinrtDisplayNV>, IvkFunctionPointer
        {
            public PFN_vkGetWinrtDisplayNV(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkDisplayKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkDisplayKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetWinrtDisplayNV other && Equals(other);
            
            public bool Equals(PFN_vkGetWinrtDisplayNV other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkDisplayKHR*, vulkan.VkResult> (vulkan.PFN_vkGetWinrtDisplayNV from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetWinrtDisplayNV (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, vulkan.VkDisplayKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetWinrtDisplayNV(from);
            
            public static bool operator ==(PFN_vkGetWinrtDisplayNV left, PFN_vkGetWinrtDisplayNV right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetWinrtDisplayNV left, PFN_vkGetWinrtDisplayNV right) => !left.Equals(right);
            
            /// <summary>
            /// Query the VkDisplayKHR corresponding to a WinRT DisplayTarget
            /// </summary>
            /// <param name="physicalDevice">The physical device on which to query the display handle.</param>
            /// <param name="deviceRelativeId">The value of the https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget.adapterrelativeid["`AdapterRelativeId`"] property of a https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget["`DisplayTarget`"] that is enumerated by a https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter["`DisplayAdapter`"] with an https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter.id["`Id`"] property matching the <paramref name="deviceLUID"/> property of a <see cref="T:VkPhysicalDeviceIDProperties"/> for <paramref name="physicalDevice"/>.</param>
            /// <param name="pDisplay">The corresponding <see cref="T:VkDisplayKHR"/> handle will be returned here.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_DEVICE_LOST</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, uint deviceRelativeId, vulkan.VkDisplayKHR* pDisplay)
            {
                return Value(physicalDevice, deviceRelativeId, pDisplay);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query the VkDisplayKHR corresponding to a WinRT DisplayTarget
            /// </summary>
            /// <param name="physicalDevice">The physical device on which to query the display handle.</param>
            /// <param name="deviceRelativeId">The value of the https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget.adapterrelativeid["`AdapterRelativeId`"] property of a https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget["`DisplayTarget`"] that is enumerated by a https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter["`DisplayAdapter`"] with an https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter.id["`Id`"] property matching the <paramref name="deviceLUID"/> property of a <see cref="T:VkPhysicalDeviceIDProperties"/> for <paramref name="physicalDevice"/>.</param>
            /// <param name="pDisplay">The corresponding <see cref="T:VkDisplayKHR"/> handle will be returned here.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_DEVICE_LOST</c></description></item><item><description><c>VK_ERROR_INITIALIZATION_FAILED</c></description></item>
            /// </list>
            /// 
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, uint deviceRelativeId, out vulkan.VkDisplayKHR pDisplay)
            {
                fixed (vulkan.VkDisplayKHR* __pDisplay_local = &pDisplay)
                return this.Invoke(physicalDevice, deviceRelativeId, __pDisplay_local);
            }
        }
        
        public const int VK_KHR_win32_surface = 1;
        
        public const int VK_KHR_WIN32_SURFACE_SPEC_VERSION = 6;
        
        public static ReadOnlySpanUtf8 VK_KHR_WIN32_SURFACE_EXTENSION_NAME => "VK_KHR_win32_surface"u8;
        
        public const int VK_KHR_external_memory_win32 = 1;
        
        public const int VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME => "VK_KHR_external_memory_win32"u8;
        
        public const int VK_KHR_win32_keyed_mutex = 1;
        
        public const int VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME => "VK_KHR_win32_keyed_mutex"u8;
        
        public const int VK_KHR_external_semaphore_win32 = 1;
        
        public const int VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME => "VK_KHR_external_semaphore_win32"u8;
        
        public const int VK_KHR_external_fence_win32 = 1;
        
        public const int VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME => "VK_KHR_external_fence_win32"u8;
        
        public const int VK_NV_external_memory_win32 = 1;
        
        public const int VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME => "VK_NV_external_memory_win32"u8;
        
        public const int VK_NV_win32_keyed_mutex = 1;
        
        public const int VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION = 2;
        
        public static ReadOnlySpanUtf8 VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME => "VK_NV_win32_keyed_mutex"u8;
        
        public const int VK_EXT_full_screen_exclusive = 1;
        
        public const int VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION = 4;
        
        public static ReadOnlySpanUtf8 VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME => "VK_EXT_full_screen_exclusive"u8;
        
        public const int VK_NV_acquire_winrt_display = 1;
        
        public const int VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME => "VK_NV_acquire_winrt_display"u8;
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateWin32SurfaceKHR> vkCreateWin32SurfaceKHR_ => new("vkCreateWin32SurfaceKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR> vkGetPhysicalDeviceWin32PresentationSupportKHR_ => new("vkGetPhysicalDeviceWin32PresentationSupportKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetMemoryWin32HandleKHR> vkGetMemoryWin32HandleKHR_ => new("vkGetMemoryWin32HandleKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetMemoryWin32HandlePropertiesKHR> vkGetMemoryWin32HandlePropertiesKHR_ => new("vkGetMemoryWin32HandlePropertiesKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkImportSemaphoreWin32HandleKHR> vkImportSemaphoreWin32HandleKHR_ => new("vkImportSemaphoreWin32HandleKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetSemaphoreWin32HandleKHR> vkGetSemaphoreWin32HandleKHR_ => new("vkGetSemaphoreWin32HandleKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkImportFenceWin32HandleKHR> vkImportFenceWin32HandleKHR_ => new("vkImportFenceWin32HandleKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetFenceWin32HandleKHR> vkGetFenceWin32HandleKHR_ => new("vkGetFenceWin32HandleKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetMemoryWin32HandleNV> vkGetMemoryWin32HandleNV_ => new("vkGetMemoryWin32HandleNV"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT> vkGetPhysicalDeviceSurfacePresentModes2EXT_ => new("vkGetPhysicalDeviceSurfacePresentModes2EXT"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkAcquireFullScreenExclusiveModeEXT> vkAcquireFullScreenExclusiveModeEXT_ => new("vkAcquireFullScreenExclusiveModeEXT"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkReleaseFullScreenExclusiveModeEXT> vkReleaseFullScreenExclusiveModeEXT_ => new("vkReleaseFullScreenExclusiveModeEXT"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetDeviceGroupSurfacePresentModes2EXT> vkGetDeviceGroupSurfacePresentModes2EXT_ => new("vkGetDeviceGroupSurfacePresentModes2EXT"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkAcquireWinrtDisplayNV> vkAcquireWinrtDisplayNV_ => new("vkAcquireWinrtDisplayNV"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetWinrtDisplayNV> vkGetWinrtDisplayNV_ => new("vkGetWinrtDisplayNV"u8);
    }
}
