//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Bitmask specifying Metal object types that can be exported from a Vulkan object
        /// </summary>
        [Flags]
        public enum VkExportMetalObjectTypeFlagsEXT : uint
        {
            /// <summary>
            /// Indicates a Metal <c>MTLDevice</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = unchecked((uint)1),
            
            /// <summary>
            /// Indicates a Metal <c>MTLCommandQueue</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = unchecked((uint)2),
            
            /// <summary>
            /// Indicates a Metal <c>MTLBuffer</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = unchecked((uint)4),
            
            /// <summary>
            /// Indicates a Metal <c>MTLTexture</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = unchecked((uint)8),
            
            /// <summary>
            /// Indicates a Metal <c>IOSurface</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = unchecked((uint)16),
            
            /// <summary>
            /// Indicates a Metal <c>MTLSharedEvent</c> may be exported.
            /// </summary>
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = unchecked((uint)32),
            
            VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Indicates a Metal <c>MTLDevice</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT;
        
        /// <summary>
        /// Indicates a Metal <c>MTLCommandQueue</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT;
        
        /// <summary>
        /// Indicates a Metal <c>MTLBuffer</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT;
        
        /// <summary>
        /// Indicates a Metal <c>MTLTexture</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT;
        
        /// <summary>
        /// Indicates a Metal <c>IOSurface</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT;
        
        /// <summary>
        /// Indicates a Metal <c>MTLSharedEvent</c> may be exported.
        /// </summary>
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagsEXT VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = VkExportMetalObjectTypeFlagsEXT.VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Structure specifying parameters of a newly created Metal surface object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_surface</para>
        /// </remarks>
        public partial struct VkMetalSurfaceCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkMetalSurfaceCreateFlagsEXT flags;
            
            /// <summary>
            /// A reference to a basetype:CAMetalLayer object representing a renderable surface.
            /// </summary>
            public void* pLayer;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_surface</para>
        /// </remarks>
        public readonly partial struct VkMetalSurfaceCreateFlagsEXT : IEquatable<vulkan.VkMetalSurfaceCreateFlagsEXT>
        {
            public VkMetalSurfaceCreateFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkMetalSurfaceCreateFlagsEXT other && Equals(other);
            
            public bool Equals(VkMetalSurfaceCreateFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkMetalSurfaceCreateFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkMetalSurfaceCreateFlagsEXT (vulkan.VkFlags from) => new vulkan.VkMetalSurfaceCreateFlagsEXT(from);
            
            public static bool operator ==(VkMetalSurfaceCreateFlagsEXT left, VkMetalSurfaceCreateFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkMetalSurfaceCreateFlagsEXT left, VkMetalSurfaceCreateFlagsEXT right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies the Metal objects that can be exported from Vulkan objects
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalObjectCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkExportMetalObjectTypeFlagBitsEXT"/> indicating the type of Metal object that the application may request to be exported from the Vulkan object.
            /// </summary>
            public vulkan.VkExportMetalObjectTypeFlagsEXT exportObjectType;
        }
        
        /// <summary>
        /// Structure whose pNext chain identifies Vulkan objects and corresponding Metal objects
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalObjectsInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
        }
        
        /// <summary>
        /// Structure that identifies a VkDevice object and corresponding Metal MTLDevice object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalDeviceInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLDevice&gt;` object underlying the <see cref="T:VkPhysicalDevice"/> associated with the <see cref="T:VkDevice"/> object identified in the call. The implementation will return the <c>MTLDevice</c> in this member, or it will return `NULL` if no <c>MTLDevice</c> could be found underlying the <see cref="T:VkPhysicalDevice"/> object.
            /// </summary>
            public vulkan.MTLDevice_id mtlDevice;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct MTLDevice_id : IEquatable<vulkan.MTLDevice_id>
        {
            public MTLDevice_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLDevice_id other && Equals(other);
            
            public bool Equals(MTLDevice_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLDevice_id from) => from.Value;
            
            public static implicit operator vulkan.MTLDevice_id (void* from) => new vulkan.MTLDevice_id(from);
            
            public static bool operator ==(MTLDevice_id left, MTLDevice_id right) => left.Equals(right);
            
            public static bool operator !=(MTLDevice_id left, MTLDevice_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkQueue object and corresponding Metal MTLCommandQueue object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalCommandQueueInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkQueue"/>.
            /// </summary>
            public vulkan.VkQueue queue;
            
            /// <summary>
            /// The Metal `id&lt;MTLCommandQueue&gt;` object underlying the <see cref="T:VkQueue"/> object in <see cref="M:queue"/>. The implementation will return the <c>MTLCommandQueue</c> in this member, or it will return `NULL` if no <c>MTLCommandQueue</c> could be found underlying the <see cref="T:VkQueue"/> object.
            /// </summary>
            public vulkan.MTLCommandQueue_id mtlCommandQueue;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct MTLCommandQueue_id : IEquatable<vulkan.MTLCommandQueue_id>
        {
            public MTLCommandQueue_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLCommandQueue_id other && Equals(other);
            
            public bool Equals(MTLCommandQueue_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLCommandQueue_id from) => from.Value;
            
            public static implicit operator vulkan.MTLCommandQueue_id (void* from) => new vulkan.MTLCommandQueue_id(from);
            
            public static bool operator ==(MTLCommandQueue_id left, MTLCommandQueue_id right) => left.Equals(right);
            
            public static bool operator !=(MTLCommandQueue_id left, MTLCommandQueue_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkDeviceMemory object and corresponding Metal MTLBuffer object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalBufferInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkDeviceMemory"/>.
            /// </summary>
            public vulkan.VkDeviceMemory memory;
            
            /// <summary>
            /// The Metal `id&lt;MTLBuffer&gt;` object underlying the <see cref="T:VkDeviceMemory"/> object in <see cref="M:memory"/>. The implementation will return the <c>MTLBuffer</c> in this member, or it will return `NULL` if no <c>MTLBuffer</c> could be found underlying the <see cref="T:VkDeviceMemory"/> object.
            /// </summary>
            public vulkan.MTLBuffer_id mtlBuffer;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct MTLBuffer_id : IEquatable<vulkan.MTLBuffer_id>
        {
            public MTLBuffer_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLBuffer_id other && Equals(other);
            
            public bool Equals(MTLBuffer_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLBuffer_id from) => from.Value;
            
            public static implicit operator vulkan.MTLBuffer_id (void* from) => new vulkan.MTLBuffer_id(from);
            
            public static bool operator ==(MTLBuffer_id left, MTLBuffer_id right) => left.Equals(right);
            
            public static bool operator !=(MTLBuffer_id left, MTLBuffer_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a Metal MTLBuffer object to use when creating a VkDeviceMemory object.
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkImportMetalBufferInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLBuffer&gt;` object that is to underlie the <see cref="T:VkDeviceMemory"/>.
            /// </summary>
            public vulkan.MTLBuffer_id mtlBuffer;
        }
        
        /// <summary>
        /// Structure that identifies a VkImage, VkImageView, or VkBufferView object and corresponding Metal MTLTexture object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalTextureInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.VkImage image;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkImageView"/>.
            /// </summary>
            public vulkan.VkImageView imageView;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkBufferView"/>.
            /// </summary>
            public vulkan.VkBufferView bufferView;
            
            /// <summary>
            /// Indicates the plane of a multi-planar <see cref="T:VkImage"/> or <see cref="T:VkImageView"/>.
            /// </summary>
            public vulkan.VkImageAspectFlags plane;
            
            /// <summary>
            /// The Metal `id&lt;MTLTexture&gt;` object underlying the <see cref="T:VkImage"/>, <see cref="T:VkImageView"/>, or <see cref="T:VkBufferView"/> object in <see cref="M:image"/>, <see cref="M:imageView"/>, or <see cref="M:bufferView"/>, respectively, at the plane indicated in <see cref="M:aspectMask"/>. The implementation will return the <c>MTLTexture</c> in this member, or it will return `NULL` if no <c>MTLTexture</c> could be found underlying the <see cref="T:VkImage"/>, <see cref="T:VkImageView"/>, or <see cref="T:VkBufferView"/> object, at the plane indicated in <see cref="M:aspectMask"/>.
            /// </summary>
            public vulkan.MTLTexture_id mtlTexture;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct MTLTexture_id : IEquatable<vulkan.MTLTexture_id>
        {
            public MTLTexture_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLTexture_id other && Equals(other);
            
            public bool Equals(MTLTexture_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLTexture_id from) => from.Value;
            
            public static implicit operator vulkan.MTLTexture_id (void* from) => new vulkan.MTLTexture_id(from);
            
            public static bool operator ==(MTLTexture_id left, MTLTexture_id right) => left.Equals(right);
            
            public static bool operator !=(MTLTexture_id left, MTLTexture_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies Metal MTLTexture objects to use when creating a VkImage.
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkImportMetalTextureInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates the plane of the <see cref="T:VkImage"/> that the `id&lt;MTLTexture&gt;` object should be attached to.
            /// </summary>
            public vulkan.VkImageAspectFlags plane;
            
            /// <summary>
            /// A the Metal `id&lt;MTLTexture&gt;` object that is to underlie the <see cref="T:VkImage"/> plane.
            /// </summary>
            public vulkan.MTLTexture_id mtlTexture;
        }
        
        /// <summary>
        /// Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalIOSurfaceInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.VkImage image;
            
            /// <summary>
            /// The Metal basetype:IOSurfaceRef object underlying the <see cref="T:VkImage"/> object in <see cref="M:image"/>. The implementation will return the basetype:IOSurfaceRef in this member, or it will return `NULL` if no basetype:IOSurfaceRef could be found underlying the <see cref="T:VkImage"/> object.
            /// </summary>
            public vulkan.IOSurfaceRef ioSurface;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct IOSurfaceRef : IEquatable<vulkan.IOSurfaceRef>
        {
            public IOSurfaceRef(vulkan.__IOSurface value) => this.Value = value;
            
            public vulkan.__IOSurface Value { get; }
            
            public override bool Equals(object obj) => obj is IOSurfaceRef other && Equals(other);
            
            public bool Equals(IOSurfaceRef other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.__IOSurface (vulkan.IOSurfaceRef from) => from.Value;
            
            public static implicit operator vulkan.IOSurfaceRef (vulkan.__IOSurface from) => new vulkan.IOSurfaceRef(from);
            
            public static bool operator ==(IOSurfaceRef left, IOSurfaceRef right) => left.Equals(right);
            
            public static bool operator !=(IOSurfaceRef left, IOSurfaceRef right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object to use.
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkImportMetalIOSurfaceInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or the Metal basetype:IOSurfaceRef object that is to underlie the <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.IOSurfaceRef ioSurface;
        }
        
        /// <summary>
        /// Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal MTLSharedEvent object
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkExportMetalSharedEventInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkSemaphore"/>.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            public vulkan.VkEvent @event;
            
            /// <summary>
            /// The Metal `id&lt;MTLSharedEvent&gt;` object underlying the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/> object in <see cref="M:semaphore"/> or <see cref="M:event"/>, respectively. The implementation will return the <c>MTLSharedEvent</c> in this member, or it will return `NULL` if no <c>MTLSharedEvent</c> could be found underlying the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/> object.
            /// </summary>
            public vulkan.MTLSharedEvent_id mtlSharedEvent;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public readonly partial struct MTLSharedEvent_id : IEquatable<vulkan.MTLSharedEvent_id>
        {
            public MTLSharedEvent_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLSharedEvent_id other && Equals(other);
            
            public bool Equals(MTLSharedEvent_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLSharedEvent_id from) => from.Value;
            
            public static implicit operator vulkan.MTLSharedEvent_id (void* from) => new vulkan.MTLSharedEvent_id(from);
            
            public static bool operator ==(MTLSharedEvent_id left, MTLSharedEvent_id right) => left.Equals(right);
            
            public static bool operator !=(MTLSharedEvent_id left, MTLSharedEvent_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal Shared Event object to use.
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_metal_objects</para>
        /// </remarks>
        public partial struct VkImportMetalSharedEventInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLSharedEvent&gt;` object that is to underlie the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/>.
            /// </summary>
            public vulkan.MTLSharedEvent_id mtlSharedEvent;
        }
        
        public readonly partial struct PFN_vkCreateMetalSurfaceEXT : IEquatable<vulkan.PFN_vkCreateMetalSurfaceEXT>, IvkInstanceFunctionPointer<vulkan.PFN_vkCreateMetalSurfaceEXT>
        {
            public PFN_vkCreateMetalSurfaceEXT(delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateMetalSurfaceEXT other && Equals(other);
            
            public bool Equals(PFN_vkCreateMetalSurfaceEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> (vulkan.PFN_vkCreateMetalSurfaceEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateMetalSurfaceEXT (delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateMetalSurfaceEXT(from);
            
            public static bool operator ==(PFN_vkCreateMetalSurfaceEXT left, PFN_vkCreateMetalSurfaceEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateMetalSurfaceEXT left, PFN_vkCreateMetalSurfaceEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCreateMetalSurfaceEXT`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCreateMetalSurfaceEXT"u8;
            
            /// <summary>
            /// Create a VkSurfaceKHR object for CAMetalLayer
            /// </summary>
            /// <param name="instance">The instance with which to associate the surface.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkMetalSurfaceCreateInfoEXT"/> structure specifying parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</c></description></item>
            /// </list>
            /// <para>Extension: VK_EXT_metal_surface</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, vulkan.VkMetalSurfaceCreateInfoEXT* pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkSurfaceKHR* pSurface)
            {
                return Value(instance, pCreateInfo, pAllocator, pSurface);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Create a VkSurfaceKHR object for CAMetalLayer
            /// </summary>
            /// <param name="instance">The instance with which to associate the surface.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkMetalSurfaceCreateInfoEXT"/> structure specifying parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation). This parameter is optional.</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</c></description></item>
            /// </list>
            /// <para>Extension: VK_EXT_metal_surface</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, in vulkan.VkMetalSurfaceCreateInfoEXT pCreateInfo, vulkan.VkAllocationCallbacks* pAllocator, out vulkan.VkSurfaceKHR pSurface)
            {
                fixed (vulkan.VkMetalSurfaceCreateInfoEXT* __pCreateInfo_local = &pCreateInfo)
                fixed (vulkan.VkSurfaceKHR* __pSurface_local = &pSurface)
                return this.Invoke(instance, __pCreateInfo_local, pAllocator, __pSurface_local);
            }
        }
        
        public readonly partial struct PFN_vkExportMetalObjectsEXT : IEquatable<vulkan.PFN_vkExportMetalObjectsEXT>, IvkDeviceFunctionPointer<vulkan.PFN_vkExportMetalObjectsEXT>
        {
            public PFN_vkExportMetalObjectsEXT(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkExportMetalObjectsEXT other && Equals(other);
            
            public bool Equals(PFN_vkExportMetalObjectsEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> (vulkan.PFN_vkExportMetalObjectsEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkExportMetalObjectsEXT (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> from) => new vulkan.PFN_vkExportMetalObjectsEXT(from);
            
            public static bool operator ==(PFN_vkExportMetalObjectsEXT left, PFN_vkExportMetalObjectsEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkExportMetalObjectsEXT left, PFN_vkExportMetalObjectsEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkExportMetalObjectsEXT`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkExportMetalObjectsEXT"u8;
            
            /// <summary>
            /// Export Metal objects from the corresponding Vulkan objects
            /// </summary>
            /// <param name="device">The device that created the Vulkan objects.</param>
            /// <param name="pMetalObjectsInfo">A pointer to a <see cref="T:VkExportMetalObjectsInfoEXT"/> structure whose <paramref name="pNext"/> chain contains structures, each identifying a Vulkan object and providing a pointer through which the Metal object will be returned.</param>
            /// <remarks>
            /// <para>Extension: VK_EXT_metal_objects</para>
            /// </remarks>
            public void Invoke(vulkan.VkDevice device, vulkan.VkExportMetalObjectsInfoEXT* pMetalObjectsInfo)
            {
                Value(device, pMetalObjectsInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Export Metal objects from the corresponding Vulkan objects
            /// </summary>
            /// <param name="device">The device that created the Vulkan objects.</param>
            /// <param name="pMetalObjectsInfo">A pointer to a <see cref="T:VkExportMetalObjectsInfoEXT"/> structure whose <paramref name="pNext"/> chain contains structures, each identifying a Vulkan object and providing a pointer through which the Metal object will be returned.</param>
            /// <remarks>
            /// <para>Extension: VK_EXT_metal_objects</para>
            /// </remarks>
            public void Invoke(vulkan.VkDevice device, ref vulkan.VkExportMetalObjectsInfoEXT pMetalObjectsInfo)
            {
                fixed (vulkan.VkExportMetalObjectsInfoEXT* __pMetalObjectsInfo_local = &pMetalObjectsInfo)
                this.Invoke(device, __pMetalObjectsInfo_local);
            }
        }
        
        public const int VK_EXT_metal_surface = 1;
        
        public const int VK_EXT_METAL_SURFACE_SPEC_VERSION = 1;
        
        public static ReadOnlyMemoryUtf8 VK_EXT_METAL_SURFACE_EXTENSION_NAME => "VK_EXT_metal_surface"u8;
        
        public const int VK_EXT_metal_objects = 1;
        
        public const int VK_EXT_METAL_OBJECTS_SPEC_VERSION = 2;
        
        public static ReadOnlyMemoryUtf8 VK_EXT_METAL_OBJECTS_EXTENSION_NAME => "VK_EXT_metal_objects"u8;
    }
}
