//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Bitmask specifying Metal object types that can be exported from a Vulkan object
        /// </summary>
        [Flags]
        public enum VkExportMetalObjectTypeFlagBitsEXT : uint
        {
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = unchecked((uint)1),
            
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = unchecked((uint)2),
            
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = unchecked((uint)4),
            
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = unchecked((uint)8),
            
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = unchecked((uint)16),
            
            VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = unchecked((uint)32),
            
            VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
        
        public const vulkan.VkExportMetalObjectTypeFlagBitsEXT VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Structure specifying parameters of a newly created Metal surface object
        /// </summary>
        public partial struct VkMetalSurfaceCreateInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkMetalSurfaceCreateFlagsEXT flags;
            
            /// <summary>
            /// A reference to a basetype:CAMetalLayer object representing a renderable surface.
            /// </summary>
            public void* pLayer;
        }
        
        public readonly partial struct VkMetalSurfaceCreateFlagsEXT : IEquatable<VkMetalSurfaceCreateFlagsEXT>
        {
            public VkMetalSurfaceCreateFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkMetalSurfaceCreateFlagsEXT other && Equals(other);
            
            public bool Equals(VkMetalSurfaceCreateFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkMetalSurfaceCreateFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkMetalSurfaceCreateFlagsEXT (vulkan.VkFlags from) => new vulkan.VkMetalSurfaceCreateFlagsEXT(from);
            
            public static bool operator ==(VkMetalSurfaceCreateFlagsEXT left, VkMetalSurfaceCreateFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkMetalSurfaceCreateFlagsEXT left, VkMetalSurfaceCreateFlagsEXT right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies the Metal objects that can be exported from Vulkan objects
        /// </summary>
        public partial struct VkExportMetalObjectCreateInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkExportMetalObjectTypeFlagBitsEXT"/> indicating the type of Metal object that the application may request to be exported from the Vulkan object.
            /// </summary>
            public vulkan.VkExportMetalObjectTypeFlagBitsEXT exportObjectType;
        }
        
        /// <summary>
        /// Structure whose pNext chain identifies Vulkan objects and corresponding Metal objects
        /// </summary>
        public partial struct VkExportMetalObjectsInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
        }
        
        /// <summary>
        /// Structure that identifies a VkDevice object and corresponding Metal MTLDevice object
        /// </summary>
        public partial struct VkExportMetalDeviceInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLDevice&gt;` object underlying the <see cref="T:VkPhysicalDevice"/> associated with the <see cref="T:VkDevice"/> object identified in the call. The implementation will return the <c>MTLDevice</c> in this member, or it will return `NULL` if no <c>MTLDevice</c> could be found underlying the <see cref="T:VkPhysicalDevice"/> object.
            /// </summary>
            public vulkan.MTLDevice_id mtlDevice;
        }
        
        public readonly partial struct MTLDevice_id : IEquatable<MTLDevice_id>
        {
            public MTLDevice_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLDevice_id other && Equals(other);
            
            public bool Equals(MTLDevice_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLDevice_id from) => from.Value;
            
            public static implicit operator vulkan.MTLDevice_id (void* from) => new vulkan.MTLDevice_id(from);
            
            public static bool operator ==(MTLDevice_id left, MTLDevice_id right) => left.Equals(right);
            
            public static bool operator !=(MTLDevice_id left, MTLDevice_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkQueue object and corresponding Metal MTLCommandQueue object
        /// </summary>
        public partial struct VkExportMetalCommandQueueInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkQueue"/>.
            /// </summary>
            public vulkan.VkQueue queue;
            
            /// <summary>
            /// The Metal `id&lt;MTLCommandQueue&gt;` object underlying the <see cref="T:VkQueue"/> object in <see cref="M:queue"/>. The implementation will return the <c>MTLCommandQueue</c> in this member, or it will return `NULL` if no <c>MTLCommandQueue</c> could be found underlying the <see cref="T:VkQueue"/> object.
            /// </summary>
            public vulkan.MTLCommandQueue_id mtlCommandQueue;
        }
        
        public readonly partial struct MTLCommandQueue_id : IEquatable<MTLCommandQueue_id>
        {
            public MTLCommandQueue_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLCommandQueue_id other && Equals(other);
            
            public bool Equals(MTLCommandQueue_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLCommandQueue_id from) => from.Value;
            
            public static implicit operator vulkan.MTLCommandQueue_id (void* from) => new vulkan.MTLCommandQueue_id(from);
            
            public static bool operator ==(MTLCommandQueue_id left, MTLCommandQueue_id right) => left.Equals(right);
            
            public static bool operator !=(MTLCommandQueue_id left, MTLCommandQueue_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkDeviceMemory object and corresponding Metal MTLBuffer object
        /// </summary>
        public partial struct VkExportMetalBufferInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkDeviceMemory"/>.
            /// </summary>
            public vulkan.VkDeviceMemory memory;
            
            /// <summary>
            /// The Metal `id&lt;MTLBuffer&gt;` object underlying the <see cref="T:VkDeviceMemory"/> object in <see cref="M:memory"/>. The implementation will return the <c>MTLBuffer</c> in this member, or it will return `NULL` if no <c>MTLBuffer</c> could be found underlying the <see cref="T:VkDeviceMemory"/> object.
            /// </summary>
            public vulkan.MTLBuffer_id mtlBuffer;
        }
        
        public readonly partial struct MTLBuffer_id : IEquatable<MTLBuffer_id>
        {
            public MTLBuffer_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLBuffer_id other && Equals(other);
            
            public bool Equals(MTLBuffer_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLBuffer_id from) => from.Value;
            
            public static implicit operator vulkan.MTLBuffer_id (void* from) => new vulkan.MTLBuffer_id(from);
            
            public static bool operator ==(MTLBuffer_id left, MTLBuffer_id right) => left.Equals(right);
            
            public static bool operator !=(MTLBuffer_id left, MTLBuffer_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a Metal MTLBuffer object to use when creating a VkDeviceMemory object.
        /// </summary>
        public partial struct VkImportMetalBufferInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLBuffer&gt;` object that is to underlie the <see cref="T:VkDeviceMemory"/>.
            /// </summary>
            public vulkan.MTLBuffer_id mtlBuffer;
        }
        
        /// <summary>
        /// Structure that identifies a VkImage, VkImageView, or VkBufferView object and corresponding Metal MTLTexture object
        /// </summary>
        public partial struct VkExportMetalTextureInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.VkImage image;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkImageView"/>.
            /// </summary>
            public vulkan.VkImageView imageView;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkBufferView"/>.
            /// </summary>
            public vulkan.VkBufferView bufferView;
            
            /// <summary>
            /// Indicates the plane of a multi-planar <see cref="T:VkImage"/> or <see cref="T:VkImageView"/>.
            /// </summary>
            public vulkan.VkImageAspectFlagBits plane;
            
            /// <summary>
            /// The Metal `id&lt;MTLTexture&gt;` object underlying the <see cref="T:VkImage"/>, <see cref="T:VkImageView"/>, or <see cref="T:VkBufferView"/> object in <see cref="M:image"/>, <see cref="M:imageView"/>, or <see cref="M:bufferView"/>, respectively, at the plane indicated in <see cref="M:aspectMask"/>. The implementation will return the <c>MTLTexture</c> in this member, or it will return `NULL` if no <c>MTLTexture</c> could be found underlying the <see cref="T:VkImage"/>, <see cref="T:VkImageView"/>, or <see cref="T:VkBufferView"/> object, at the plane indicated in <see cref="M:aspectMask"/>.
            /// </summary>
            public vulkan.MTLTexture_id mtlTexture;
        }
        
        public readonly partial struct MTLTexture_id : IEquatable<MTLTexture_id>
        {
            public MTLTexture_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLTexture_id other && Equals(other);
            
            public bool Equals(MTLTexture_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLTexture_id from) => from.Value;
            
            public static implicit operator vulkan.MTLTexture_id (void* from) => new vulkan.MTLTexture_id(from);
            
            public static bool operator ==(MTLTexture_id left, MTLTexture_id right) => left.Equals(right);
            
            public static bool operator !=(MTLTexture_id left, MTLTexture_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies Metal MTLTexture objects to use when creating a VkImage.
        /// </summary>
        public partial struct VkImportMetalTextureInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates the plane of the <see cref="T:VkImage"/> that the `id&lt;MTLTexture&gt;` object should be attached to.
            /// </summary>
            public vulkan.VkImageAspectFlagBits plane;
            
            /// <summary>
            /// A the Metal `id&lt;MTLTexture&gt;` object that is to underlie the <see cref="T:VkImage"/> plane.
            /// </summary>
            public vulkan.MTLTexture_id mtlTexture;
        }
        
        /// <summary>
        /// Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object
        /// </summary>
        public partial struct VkExportMetalIOSurfaceInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.VkImage image;
            
            /// <summary>
            /// The Metal basetype:IOSurfaceRef object underlying the <see cref="T:VkImage"/> object in <see cref="M:image"/>. The implementation will return the basetype:IOSurfaceRef in this member, or it will return `NULL` if no basetype:IOSurfaceRef could be found underlying the <see cref="T:VkImage"/> object.
            /// </summary>
            public vulkan.IOSurfaceRef ioSurface;
        }
        
        public readonly partial struct IOSurfaceRef : IEquatable<IOSurfaceRef>
        {
            public IOSurfaceRef(vulkan.__IOSurface value) => this.Value = value;
            
            public vulkan.__IOSurface Value { get; }
            
            public override bool Equals(object obj) => obj is IOSurfaceRef other && Equals(other);
            
            public bool Equals(IOSurfaceRef other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.__IOSurface (vulkan.IOSurfaceRef from) => from.Value;
            
            public static implicit operator vulkan.IOSurfaceRef (vulkan.__IOSurface from) => new vulkan.IOSurfaceRef(from);
            
            public static bool operator ==(IOSurfaceRef left, IOSurfaceRef right) => left.Equals(right);
            
            public static bool operator !=(IOSurfaceRef left, IOSurfaceRef right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object to use.
        /// </summary>
        public partial struct VkImportMetalIOSurfaceInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or the Metal basetype:IOSurfaceRef object that is to underlie the <see cref="T:VkImage"/>.
            /// </summary>
            public vulkan.IOSurfaceRef ioSurface;
        }
        
        /// <summary>
        /// Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal MTLSharedEvent object
        /// </summary>
        public partial struct VkExportMetalSharedEventInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Dlink:VK_NULL_HANDLE or a <see cref="T:VkSemaphore"/>.
            /// </summary>
            public vulkan.VkSemaphore semaphore;
            
            public vulkan.VkEvent @event;
            
            /// <summary>
            /// The Metal `id&lt;MTLSharedEvent&gt;` object underlying the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/> object in <see cref="M:semaphore"/> or <see cref="M:event"/>, respectively. The implementation will return the <c>MTLSharedEvent</c> in this member, or it will return `NULL` if no <c>MTLSharedEvent</c> could be found underlying the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/> object.
            /// </summary>
            public vulkan.MTLSharedEvent_id mtlSharedEvent;
        }
        
        public readonly partial struct MTLSharedEvent_id : IEquatable<MTLSharedEvent_id>
        {
            public MTLSharedEvent_id(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is MTLSharedEvent_id other && Equals(other);
            
            public bool Equals(MTLSharedEvent_id other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (vulkan.MTLSharedEvent_id from) => from.Value;
            
            public static implicit operator vulkan.MTLSharedEvent_id (void* from) => new vulkan.MTLSharedEvent_id(from);
            
            public static bool operator ==(MTLSharedEvent_id left, MTLSharedEvent_id right) => left.Equals(right);
            
            public static bool operator !=(MTLSharedEvent_id left, MTLSharedEvent_id right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal Shared Event object to use.
        /// </summary>
        public partial struct VkImportMetalSharedEventInfoEXT
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The Metal `id&lt;MTLSharedEvent&gt;` object that is to underlie the <see cref="T:VkSemaphore"/> or <see cref="T:VkEvent"/>.
            /// </summary>
            public vulkan.MTLSharedEvent_id mtlSharedEvent;
        }
        
        public readonly partial struct PFN_vkCreateMetalSurfaceEXT : IEquatable<PFN_vkCreateMetalSurfaceEXT>, IvkFunctionPointer
        {
            public PFN_vkCreateMetalSurfaceEXT(delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateMetalSurfaceEXT other && Equals(other);
            
            public bool Equals(PFN_vkCreateMetalSurfaceEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> (vulkan.PFN_vkCreateMetalSurfaceEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateMetalSurfaceEXT (delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkMetalSurfaceCreateInfoEXT*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateMetalSurfaceEXT(from);
            
            public static bool operator ==(PFN_vkCreateMetalSurfaceEXT left, PFN_vkCreateMetalSurfaceEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateMetalSurfaceEXT left, PFN_vkCreateMetalSurfaceEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Create a VkSurfaceKHR object for CAMetalLayer
            /// </summary>
            /// <param name="instance">The instance with which to associate the surface.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkMetalSurfaceCreateInfoEXT"/> structure specifying parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, in vulkan.VkMetalSurfaceCreateInfoEXT pCreateInfo, in vulkan.VkAllocationCallbacks pAllocator, out vulkan.VkSurfaceKHR pSurface)
            {
                fixed (vulkan.VkMetalSurfaceCreateInfoEXT* __pCreateInfo = &pCreateInfo)
                fixed (vulkan.VkAllocationCallbacks* __pAllocator = &pAllocator)
                fixed (vulkan.VkSurfaceKHR* __pSurface = &pSurface)
                return Value(instance, __pCreateInfo, __pAllocator, __pSurface);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct VkExportMetalObjectTypeFlagsEXT : IEquatable<VkExportMetalObjectTypeFlagsEXT>
        {
            public VkExportMetalObjectTypeFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkExportMetalObjectTypeFlagsEXT other && Equals(other);
            
            public bool Equals(VkExportMetalObjectTypeFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkExportMetalObjectTypeFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkExportMetalObjectTypeFlagsEXT (vulkan.VkFlags from) => new vulkan.VkExportMetalObjectTypeFlagsEXT(from);
            
            public static bool operator ==(VkExportMetalObjectTypeFlagsEXT left, VkExportMetalObjectTypeFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkExportMetalObjectTypeFlagsEXT left, VkExportMetalObjectTypeFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkExportMetalObjectTypeFlagBitsEXT (vulkan.VkExportMetalObjectTypeFlagsEXT from) => (vulkan.VkExportMetalObjectTypeFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkExportMetalObjectTypeFlagsEXT (vulkan.VkExportMetalObjectTypeFlagBitsEXT from) => new vulkan.VkExportMetalObjectTypeFlagsEXT((uint)from);
        }
        
        public readonly partial struct PFN_vkExportMetalObjectsEXT : IEquatable<PFN_vkExportMetalObjectsEXT>, IvkFunctionPointer
        {
            public PFN_vkExportMetalObjectsEXT(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkExportMetalObjectsEXT other && Equals(other);
            
            public bool Equals(PFN_vkExportMetalObjectsEXT other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> (vulkan.PFN_vkExportMetalObjectsEXT from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkExportMetalObjectsEXT (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkExportMetalObjectsInfoEXT*, void> from) => new vulkan.PFN_vkExportMetalObjectsEXT(from);
            
            public static bool operator ==(PFN_vkExportMetalObjectsEXT left, PFN_vkExportMetalObjectsEXT right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkExportMetalObjectsEXT left, PFN_vkExportMetalObjectsEXT right) => !left.Equals(right);
            
            /// <summary>
            /// Export Metal objects from the corresponding Vulkan objects
            /// </summary>
            /// <param name="device">The device that created the Vulkan objects.</param>
            /// <param name="pMetalObjectsInfo">A pointer to a <see cref="T:VkExportMetalObjectsInfoEXT"/> structure whose <paramref name="pNext"/> chain contains structures, each identifying a Vulkan object and providing a pointer through which the Metal object will be returned.</param>
            public void Invoke(vulkan.VkDevice device, out vulkan.VkExportMetalObjectsInfoEXT pMetalObjectsInfo)
            {
                fixed (vulkan.VkExportMetalObjectsInfoEXT* __pMetalObjectsInfo = &pMetalObjectsInfo)
                Value(device, __pMetalObjectsInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public const int VK_EXT_metal_surface = 1;
        
        public const int VK_EXT_METAL_SURFACE_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_EXT_METAL_SURFACE_EXTENSION_NAME => "VK_EXT_metal_surface"u8;
        
        public const int VK_EXT_metal_objects = 1;
        
        public const int VK_EXT_METAL_OBJECTS_SPEC_VERSION = 1;
        
        public static ReadOnlySpanUtf8 VK_EXT_METAL_OBJECTS_EXTENSION_NAME => "VK_EXT_metal_objects"u8;
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateMetalSurfaceEXT> vkCreateMetalSurfaceEXT_ => new("vkCreateMetalSurfaceEXT"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkExportMetalObjectsEXT> vkExportMetalObjectsEXT_ => new("vkExportMetalObjectsEXT"u8);
    }
}
