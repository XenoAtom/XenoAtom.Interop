//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Structure specifying parameters of a newly created Xcb surface object
        /// </summary>
        public partial struct VkXcbSurfaceCreateInfoKHR
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkXcbSurfaceCreateFlagsKHR flags;
            
            /// <summary>
            /// A pointer to an <c>xcb_connection_t</c> to the X server.
            /// </summary>
            public void* connection;
            
            /// <summary>
            /// The <c>xcb_window_t</c> for the X11 window to associate the surface with.
            /// </summary>
            public uint window;
        }
        
        public readonly partial struct VkXcbSurfaceCreateFlagsKHR : IEquatable<VkXcbSurfaceCreateFlagsKHR>
        {
            public VkXcbSurfaceCreateFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkXcbSurfaceCreateFlagsKHR other && Equals(other);
            
            public bool Equals(VkXcbSurfaceCreateFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkXcbSurfaceCreateFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkXcbSurfaceCreateFlagsKHR (vulkan.VkFlags from) => new vulkan.VkXcbSurfaceCreateFlagsKHR(from);
            
            public static bool operator ==(VkXcbSurfaceCreateFlagsKHR left, VkXcbSurfaceCreateFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkXcbSurfaceCreateFlagsKHR left, VkXcbSurfaceCreateFlagsKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCreateXcbSurfaceKHR : IEquatable<PFN_vkCreateXcbSurfaceKHR>, IvkFunctionPointer
        {
            public PFN_vkCreateXcbSurfaceKHR(delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkXcbSurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkXcbSurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateXcbSurfaceKHR other && Equals(other);
            
            public bool Equals(PFN_vkCreateXcbSurfaceKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkXcbSurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> (vulkan.PFN_vkCreateXcbSurfaceKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateXcbSurfaceKHR (delegate*unmanaged[Stdcall]<vulkan.VkInstance, vulkan.VkXcbSurfaceCreateInfoKHR*, vulkan.VkAllocationCallbacks*, vulkan.VkSurfaceKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateXcbSurfaceKHR(from);
            
            public static bool operator ==(PFN_vkCreateXcbSurfaceKHR left, PFN_vkCreateXcbSurfaceKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateXcbSurfaceKHR left, PFN_vkCreateXcbSurfaceKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Create a <see cref="T:VkSurfaceKHR"/> object for a X11 window, using the XCB client-side library
            /// </summary>
            /// <param name="instance">The instance to associate the surface with.</param>
            /// <param name="pCreateInfo">A pointer to a <see cref="T:VkXcbSurfaceCreateInfoKHR"/> structure containing parameters affecting the creation of the surface object.</param>
            /// <param name="pAllocator">The allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).</param>
            /// <param name="pSurface">A pointer to a <see cref="T:VkSurfaceKHR"/> handle in which the created surface object is returned.</param>
            public vulkan.VkResult Invoke(vulkan.VkInstance instance, in vulkan.VkXcbSurfaceCreateInfoKHR pCreateInfo, in vulkan.VkAllocationCallbacks pAllocator, out vulkan.VkSurfaceKHR pSurface)
            {
                fixed (vulkan.VkXcbSurfaceCreateInfoKHR* __pCreateInfo = &pCreateInfo)
                fixed (vulkan.VkAllocationCallbacks* __pAllocator = &pAllocator)
                fixed (vulkan.VkSurfaceKHR* __pSurface = &pSurface)
                return Value(instance, __pCreateInfo, __pAllocator, __pSurface);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR : IEquatable<PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR>, IvkFunctionPointer
        {
            public PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, void*, uint, vulkan.VkBool32> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, void*, uint, vulkan.VkBool32> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, void*, uint, vulkan.VkBool32> (vulkan.PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, uint, void*, uint, vulkan.VkBool32> from) => new vulkan.PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR(from);
            
            public static bool operator ==(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR left, PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR left, PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Query physical device for presentation to X11 server using XCB
            /// </summary>
            /// <param name="physicalDevice">The physical device.</param>
            /// <param name="queueFamilyIndex">The queue family index.</param>
            /// <param name="connection">A pointer to an <c>xcb_connection_t</c> to the X server.</param>
            /// <param name="visual_id">An X11 visual (<c>xcb_visualid_t</c>).</param>
            public vulkan.VkBool32 Invoke(vulkan.VkPhysicalDevice physicalDevice, uint queueFamilyIndex, void* connection, uint visual_id)
            {
                return Value(physicalDevice, queueFamilyIndex, connection, visual_id);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public const int VK_KHR_xcb_surface = 1;
        
        public const int VK_KHR_XCB_SURFACE_SPEC_VERSION = 6;
        
        public static ReadOnlySpanUtf8 VK_KHR_XCB_SURFACE_EXTENSION_NAME => "VK_KHR_xcb_surface"u8;
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateXcbSurfaceKHR> vkCreateXcbSurfaceKHR_ => new("vkCreateXcbSurfaceKHR"u8);
        
        public static vkFunctionPointerPrototype<vulkan.PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR> vkGetPhysicalDeviceXcbPresentationSupportKHR_ => new("vkGetPhysicalDeviceXcbPresentationSupportKHR"u8);
    }
}
