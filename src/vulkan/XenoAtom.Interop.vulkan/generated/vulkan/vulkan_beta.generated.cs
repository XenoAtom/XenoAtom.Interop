//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Format enum for displacement micromaps
        /// </summary>
        public enum VkDisplacementMicromapFormatNV : uint
        {
            /// <summary>
            /// Indicates that the given micromap format encodes 64 micro-triangles worth of displacements in 64 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 256 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 1024 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding.
            /// </summary>
            VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = unchecked((uint)1),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = unchecked((uint)2),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = unchecked((uint)3),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Indicates that the given micromap format encodes 64 micro-triangles worth of displacements in 64 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 256 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 1024 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding.
        /// </summary>
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV;
        
        /// <summary>
        /// Structure describing the features that may not be supported by an implementation of the Vulkan 1.0 Portability Subset
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_portability_subset</para>
        /// </remarks>
        public partial struct VkPhysicalDevicePortabilitySubsetFeaturesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[features-constantAlphaColorBlendFactors]] <see cref="M:constantAlphaColorBlendFactors"/> indicates whether this implementation supports constant _alpha_ or a different number of bits in each component, than the texel format of the underlying <see cref="T:VkImage"/>. * [[features-imageViewFormatSwizzle]] <see cref="M:imageViewFormatSwizzle"/> indicates whether this implementation supports remapping format components using <see cref="T:VkImageViewCreateInfo.components"/>. * [[features-imageView2DOn3DImage]] <see cref="M:imageView2DOn3DImage"/> indicates whether this implementation supports a <see cref="T:VkImage"/> being created with the <see cref="T:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/> flag set, permitting a 2D or 2D array image view to be created on a 3D <see cref="T:VkImage"/>. * [[features-multisampleArrayImage]] <see cref="M:multisampleArrayImage"/> indicates whether this implementation supports a <see cref="T:VkImage"/> being created as a 2D array with multiple samples per texel. * [[features-mutableComparisonSamplers]] <see cref="M:mutableComparisonSamplers"/> indicates whether this implementation allows descriptors with comparison samplers to be &lt;&lt;descriptorsets-updates, updated. * [[features-pointPolygons]] <see cref="M:pointPolygons"/> indicates whether this implementation supports mipmap LOD bias value when creating a sampler. * [[features-separateStencilMaskRef]] <see cref="M:separateStencilMaskRef"/> indicates whether this implementation supports separate front and back <c>InterpolationFunction</c> capability and the extended instructions `InterpolateAtCentroid`, `InterpolateAtOffset`, and `InterpolateAtSample` from the `GLSL.std.450` extended instruction set. This member is only meaningful if the <see cref="M:sampleRateShading"/> feature is supported. * [[features-tessellationIsolines]] <see cref="M:tessellationIsolines"/> indicates whether this implementation supports isoline output from the <see cref="M:tessellationShader"/> are supported. * [[features-tessellationPointMode]] <see cref="M:tessellationPointMode"/> indicates whether this implementation supports point output from the <see cref="M:tessellationShader"/> are supported. * [[features-triangleFans]] <see cref="M:triangleFans"/> indicates whether this implementation supports &lt;&lt;drawing-triangle-fans&gt;&gt; primitive topology. * [[features-vertexAttributeAccessBeyondStride]] <see cref="M:vertexAttributeAccessBeyondStride"/> indicates whether this implementation supports accessing a vertex input attribute beyond the stride of the corresponding vertex input binding.
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBool32 constantAlphaColorBlendFactors;
            
            public vulkan.VkBool32 events;
            
            public vulkan.VkBool32 imageViewFormatReinterpretation;
            
            public vulkan.VkBool32 imageViewFormatSwizzle;
            
            public vulkan.VkBool32 imageView2DOn3DImage;
            
            public vulkan.VkBool32 multisampleArrayImage;
            
            public vulkan.VkBool32 mutableComparisonSamplers;
            
            public vulkan.VkBool32 pointPolygons;
            
            public vulkan.VkBool32 samplerMipLodBias;
            
            public vulkan.VkBool32 separateStencilMaskRef;
            
            public vulkan.VkBool32 shaderSampleRateInterpolationFunctions;
            
            public vulkan.VkBool32 tessellationIsolines;
            
            public vulkan.VkBool32 tessellationPointMode;
            
            public vulkan.VkBool32 triangleFans;
            
            public vulkan.VkBool32 vertexAttributeAccessBeyondStride;
        }
        
        /// <summary>
        /// Structure describing additional properties supported by a portable implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_portability_subset</para>
        /// </remarks>
        public partial struct VkPhysicalDevicePortabilitySubsetPropertiesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[limits-minVertexInputBindingStrideAlignment]] <see cref="M:minVertexInputBindingStrideAlignment"/> indicates the minimum alignment for vertex input strides. <see cref="T:VkVertexInputBindingDescription.stride"/> must: be a multiple of, and at least as large as, this value. The value must: be a power of two.
            /// </summary>
            public void* pNext;
            
            public uint minVertexInputBindingStrideAlignment;
        }
        
        /// <summary>
        /// Structure describing whether shader enqueue within execution graphs are supported by the implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceShaderEnqueueFeaturesAMDX()
        {
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX;
            
            public void* pNext;
            
            public vulkan.VkBool32 shaderEnqueue;
        }
        
        /// <summary>
        /// Structure describing shader enqueue limits of an implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceShaderEnqueuePropertiesAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[limits-maxExecutionGraphDepth]] <see cref="M:maxExecutionGraphDepth"/> defines the maximum node chain depth in the graph. The dispatched node is at depth 1 and the node enqueued by it is at depth 2, and so on. If a node enqueues itself, each recursive enqueue increases the depth by 1 as well. * [[limits-maxExecutionGraphShaderOutputNodes]] <see cref="M:maxExecutionGraphShaderOutputNodes"/> specifies the maximum number of unique nodes that can be dispatched from a single shader, and must: be at least 256. * [[limits-maxExecutionGraphShaderPayloadSize]] <see cref="M:maxExecutionGraphShaderPayloadSize"/> specifies the maximum total size of payload declarations in a shader. For any payload declarations that share resources, indicated by <c>NodeSharesPayloadLimitsWithAMDX</c> decorations, the maximum size of each set of shared payload declarations is taken. The sum of each shared set's maximum size and the size of each unshared payload is counted against this limit. * [[limits-maxExecutionGraphShaderPayloadCount]] <see cref="M:maxExecutionGraphShaderPayloadCount"/> specifies the maximum number of output payloads that can be initialized in a single workgroup. * [[limits-executionGraphDispatchAddressAlignment]] <see cref="M:executionGraphDispatchAddressAlignment"/> specifies the alignment of non-scratch basetype:VkDeviceAddress arguments consumed by graph dispatch commands.
            /// </summary>
            public void* pNext;
            
            public uint maxExecutionGraphDepth;
            
            public uint maxExecutionGraphShaderOutputNodes;
            
            public uint maxExecutionGraphShaderPayloadSize;
            
            public uint maxExecutionGraphShaderPayloadCount;
            
            public uint executionGraphDispatchAddressAlignment;
        }
        
        /// <summary>
        /// Structure describing the scratch space required to dispatch an execution graph
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkExecutionGraphPipelineScratchSizeAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates the scratch space required for dispatch the queried execution graph.
            /// </summary>
            public vulkan.VkDeviceSize size;
        }
        
        /// <summary>
        /// Structure specifying parameters of a newly created execution graph pipeline
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkExecutionGraphPipelineCreateInfoAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkPipelineCreateFlagBits"/> specifying how the pipeline will be generated.
            /// </summary>
            public vulkan.VkPipelineCreateFlags flags;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pStages"/> array.
            /// </summary>
            public uint stageCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:stageCount"/> <see cref="T:VkPipelineShaderStageCreateInfo"/> structures describing the set of the shader stages to be included in the execution graph pipeline.
            /// </summary>
            public vulkan.VkPipelineShaderStageCreateInfo* pStages;
            
            /// <summary>
            /// A pointer to a <see cref="T:VkPipelineLibraryCreateInfoKHR"/> structure defining pipeline libraries to include.
            /// </summary>
            public vulkan.VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
            
            /// <summary>
            /// The description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
            /// </summary>
            public vulkan.VkPipelineLayout layout;
            
            /// <summary>
            /// A pipeline to derive from
            /// </summary>
            public vulkan.VkPipeline basePipelineHandle;
            
            /// <summary>
            /// An index into the <see cref="M:pCreateInfos"/> parameter to use as a pipeline to derive from
            /// </summary>
            public int basePipelineIndex;
        }
        
        /// <summary>
        /// Union specifying a const device or host address
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
        public partial struct VkDeviceOrHostAddressConstAMDX
        {
            /// <summary>
            /// A buffer device address as returned by the <see cref="M:vkGetBufferDeviceAddressKHR"/> command.
            /// </summary>
            [FieldOffset(0)]
            public vulkan.VkDeviceAddress deviceAddress;
            
            /// <summary>
            /// A const host memory address.
            /// </summary>
            [FieldOffset(0)]
            public void* hostAddress;
        }
        
        /// <summary>
        /// Structure specifying node parameters for execution graph dispatch
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkDispatchGraphInfoAMDX
        {
            /// <summary>
            /// The index of a node in an execution graph to be dispatched.
            /// </summary>
            public uint nodeIndex;
            
            /// <summary>
            /// The number of payloads to dispatch for the specified node.
            /// </summary>
            public uint payloadCount;
            
            /// <summary>
            /// A device or host address pointer to a flat array of payloads with size equal to the product of <see cref="M:payloadCount"/> and <see cref="M:payloadStride"/>
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstAMDX payloads;
            
            /// <summary>
            /// The byte stride between successive payloads in <see cref="M:payloads"/>
            /// </summary>
            public ulong payloadStride;
        }
        
        /// <summary>
        /// Structure specifying count parameters for execution graph dispatch
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkDispatchGraphCountInfoAMDX
        {
            /// <summary>
            /// The number of dispatches to perform.
            /// </summary>
            public uint count;
            
            /// <summary>
            /// The device or host address of a flat array of <see cref="T:VkDispatchGraphInfoAMDX"/> structures
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstAMDX infos;
            
            /// <summary>
            /// The byte stride between successive <see cref="T:VkDispatchGraphInfoAMDX"/> structures in <see cref="M:infos"/>
            /// </summary>
            public ulong stride;
        }
        
        /// <summary>
        /// Structure specifying the shader name and index with an execution graph
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPipelineShaderStageNodeCreateInfoAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The shader name to use when creating a node in an execution graph. If <see cref="M:pName"/> is `NULL`, the name of the entry point specified in SPIR-V is used as the shader name.
            /// </summary>
            public byte* pName;
            
            /// <summary>
            /// The shader index to use when creating a node in an execution graph. If <see cref="M:index"/> is <see cref="T:VK_SHADER_INDEX_UNUSED_AMDX"/> then the original index is used, either as specified by the <c>ShaderIndexAMDX</c> execution mode, or `0` if that too is not specified.
            /// </summary>
            public uint index;
        }
        
        /// <summary>
        /// Structure describing the ray tracing displacement micromap features that can be supported by an implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceDisplacementMicromapFeaturesNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[features-displacementMicromap]] <see cref="M:displacementMicromap"/> indicates whether the implementation supports the displacement micromap feature.
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBool32 displacementMicromap;
        }
        
        /// <summary>
        /// Structure describing the displacement micromap properties of a physical device
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceDisplacementMicromapPropertiesNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The maximum allowed <see cref="M:subdivisionLevel"/> for displacement micromaps.
            /// </summary>
            public uint maxDisplacementMicromapSubdivisionLevel;
        }
        
        /// <summary>
        /// Structure specifying a displacement micromap in a bottom-level acceleration structure
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkAccelerationStructureTrianglesDisplacementMicromapNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The format of displacement bias and scale used in this displacement micromap reference.
            /// </summary>
            public vulkan.VkFormat displacementBiasAndScaleFormat;
            
            /// <summary>
            /// The format of displacement vector used in this displacement micromap reference.
            /// </summary>
            public vulkan.VkFormat displacementVectorFormat;
            
            /// <summary>
            /// The address containing the bias and scale.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer;
            
            /// <summary>
            /// The byte stride between bias and scale values.
            /// </summary>
            public vulkan.VkDeviceSize displacementBiasAndScaleStride;
            
            /// <summary>
            /// The address containing the displacement vector values.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacementVectorBuffer;
            
            /// <summary>
            /// The byte stride between displacement vector values.
            /// </summary>
            public vulkan.VkDeviceSize displacementVectorStride;
            
            /// <summary>
            /// The address containing the primitive flags.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags;
            
            /// <summary>
            /// The byte stride between primitive flag values.
            /// </summary>
            public vulkan.VkDeviceSize displacedMicromapPrimitiveFlagsStride;
            
            /// <summary>
            /// The type of triangle indices used when indexing this micromap.
            /// </summary>
            public vulkan.VkIndexType indexType;
            
            /// <summary>
            /// The address containing the triangle indices.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR indexBuffer;
            
            /// <summary>
            /// The byte stride between triangle indices.
            /// </summary>
            public vulkan.VkDeviceSize indexStride;
            
            /// <summary>
            /// The base value added to the non-negative triangle indices.
            /// </summary>
            public uint baseTriangle;
            
            /// <summary>
            /// Specifies the number of usage counts structures that will be used to determine the size of this micromap.
            /// </summary>
            public uint usageCountsCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkMicromapUsageEXT"/> structures.
            /// </summary>
            public vulkan.VkMicromapUsageEXT* pUsageCounts;
            
            /// <summary>
            /// A pointer to an array of pointers to <see cref="T:VkMicromapUsageEXT"/> structures.
            /// </summary>
            public vulkan.VkMicromapUsageEXT** ppUsageCounts;
            
            /// <summary>
            /// The handle to the micromap object to include in this geometry.
            /// </summary>
            public vulkan.VkMicromapEXT micromap;
        }
        
        public readonly partial struct PFN_vkCreateExecutionGraphPipelinesAMDX : IEquatable<vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX>
        {
            public PFN_vkCreateExecutionGraphPipelinesAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateExecutionGraphPipelinesAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCreateExecutionGraphPipelinesAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> (vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX(from);
            
            public static bool operator ==(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCreateExecutionGraphPipelinesAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCreateExecutionGraphPipelinesAMDX"u8;
            
            /// <summary>
            /// Creates a new execution graph pipeline object
            /// </summary>
            /// <param name="device">The logical device that creates the execution graph pipelines.</param>
            /// <param name="pipelineCache">Either dlink:VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. This parameter is optional.</param>
            /// <param name="createInfoCount">The length of the <paramref name="pCreateInfos"/> and <paramref name="pPipelines"/> arrays.</param>
            /// <param name="pCreateInfos">A pointer to an array of <see cref="T:VkExecutionGraphPipelineCreateInfoAMDX"/> structures.</param>
            /// <param name="pAllocator">Controls host memory allocation as described in the Memory Allocation chapter. This parameter is optional.</param>
            /// <param name="pPipelines">A pointer to an array of <see cref="T:VkPipeline"/> handles in which the resulting execution graph pipeline objects are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_PIPELINE_COMPILE_REQUIRED_EXT</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipelineCache pipelineCache, uint createInfoCount, vulkan.VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkPipeline* pPipelines)
            {
                return Value(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Creates a new execution graph pipeline object
            /// </summary>
            /// <param name="device">The logical device that creates the execution graph pipelines.</param>
            /// <param name="pipelineCache">Either dlink:VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. This parameter is optional.</param>
            /// <param name="createInfoCount">The length of the <paramref name="pCreateInfos"/> and <paramref name="pPipelines"/> arrays.</param>
            /// <param name="pCreateInfos">A pointer to an array of <see cref="T:VkExecutionGraphPipelineCreateInfoAMDX"/> structures.</param>
            /// <param name="pAllocator">Controls host memory allocation as described in the Memory Allocation chapter. This parameter is optional.</param>
            /// <param name="pPipelines">A pointer to an array of <see cref="T:VkPipeline"/> handles in which the resulting execution graph pipeline objects are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_PIPELINE_COMPILE_REQUIRED_EXT</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipelineCache pipelineCache, ReadOnlySpan<vulkan.VkExecutionGraphPipelineCreateInfoAMDX> pCreateInfos, vulkan.VkAllocationCallbacks* pAllocator, Span<vulkan.VkPipeline> pPipelines)
            {
                uint __createInfoCount_local = checked((uint)pCreateInfos.Length);
                fixed (vulkan.VkExecutionGraphPipelineCreateInfoAMDX* __pCreateInfos_local = pCreateInfos)
                fixed (vulkan.VkPipeline* __pPipelines_local = pPipelines)
                return this.Invoke(device, pipelineCache, __createInfoCount_local, __pCreateInfos_local, pAllocator, __pPipelines_local);
            }
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineScratchSizeAMDX : IEquatable<vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetExecutionGraphPipelineScratchSizeAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkGetExecutionGraphPipelineScratchSizeAMDX"u8;
            
            /// <summary>
            /// Query scratch space required to dispatch an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the scratch space for.</param>
            /// <param name="pSizeInfo">A pointer to a <see cref="T:VkExecutionGraphPipelineScratchSizeAMDX"/> structure that will contain the required scratch size.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, vulkan.VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo)
            {
                return Value(device, executionGraph, pSizeInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query scratch space required to dispatch an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the scratch space for.</param>
            /// <param name="pSizeInfo">A pointer to a <see cref="T:VkExecutionGraphPipelineScratchSizeAMDX"/> structure that will contain the required scratch size.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, ref vulkan.VkExecutionGraphPipelineScratchSizeAMDX pSizeInfo)
            {
                fixed (vulkan.VkExecutionGraphPipelineScratchSizeAMDX* __pSizeInfo_local = &pSizeInfo)
                return this.Invoke(device, executionGraph, __pSizeInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineNodeIndexAMDX : IEquatable<vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetExecutionGraphPipelineNodeIndexAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkGetExecutionGraphPipelineNodeIndexAMDX"u8;
            
            /// <summary>
            /// Query internal id of a node in an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the internal node index for.</param>
            /// <param name="pNodeInfo">A pointer to a <see cref="T:VkPipelineShaderStageNodeCreateInfoAMDX"/> structure identifying the name and index of the node to query.</param>
            /// <param name="pNodeIndex">The returned internal node index of the identified node.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint* pNodeIndex)
            {
                return Value(device, executionGraph, pNodeInfo, pNodeIndex);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query internal id of a node in an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the internal node index for.</param>
            /// <param name="pNodeInfo">A pointer to a <see cref="T:VkPipelineShaderStageNodeCreateInfoAMDX"/> structure identifying the name and index of the node to query.</param>
            /// <param name="pNodeIndex">The returned internal node index of the identified node.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, in vulkan.VkPipelineShaderStageNodeCreateInfoAMDX pNodeInfo, out uint pNodeIndex)
            {
                fixed (vulkan.VkPipelineShaderStageNodeCreateInfoAMDX* __pNodeInfo_local = &pNodeInfo)
                fixed (uint* __pNodeIndex_local = &pNodeIndex)
                return this.Invoke(device, executionGraph, __pNodeInfo_local, __pNodeIndex_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdInitializeGraphScratchMemoryAMDX : IEquatable<vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX>
        {
            public PFN_vkCmdInitializeGraphScratchMemoryAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdInitializeGraphScratchMemoryAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdInitializeGraphScratchMemoryAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX(from);
            
            public static bool operator ==(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdInitializeGraphScratchMemoryAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCmdInitializeGraphScratchMemoryAMDX"u8;
            
            /// <summary>
            /// Initialize scratch memory for an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be initialized.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch)
            {
                Value(commandBuffer, scratch);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkCmdDispatchGraphAMDX>
        {
            public PFN_vkCmdDispatchGraphAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCmdDispatchGraphAMDX"u8;
            
            /// <summary>
            /// Dispatch an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDispatchGraphCountInfoAMDX* pCountInfo)
            {
                Value(commandBuffer, scratch, pCountInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Dispatch an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo)
            {
                fixed (vulkan.VkDispatchGraphCountInfoAMDX* __pCountInfo_local = &pCountInfo)
                this.Invoke(commandBuffer, scratch, __pCountInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphIndirectAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkCmdDispatchGraphIndirectAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphIndirectAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphIndirectAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCmdDispatchGraphIndirectAMDX"u8;
            
            /// <summary>
            /// Dispatch an execution graph with node and payload parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDispatchGraphCountInfoAMDX* pCountInfo)
            {
                Value(commandBuffer, scratch, pCountInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Dispatch an execution graph with node and payload parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo)
            {
                fixed (vulkan.VkDispatchGraphCountInfoAMDX* __pCountInfo_local = &pCountInfo)
                this.Invoke(commandBuffer, scratch, __pCountInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectCountAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX>, IvkDeviceFunctionPointer<vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectCountAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectCountAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectCountAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphIndirectCountAMDX`.
            /// </summary>
            public static ReadOnlyMemoryUtf8 Name => "vkCmdDispatchGraphIndirectCountAMDX"u8;
            
            /// <summary>
            /// Dispatch an execution graph with all parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="countInfo">A device address of a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDeviceAddress countInfo)
            {
                Value(commandBuffer, scratch, countInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public const int VK_KHR_portability_subset = 1;
        
        public const int VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1;
        
        public static ReadOnlyMemoryUtf8 VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME => "VK_KHR_portability_subset"u8;
        
        public const int VK_AMDX_shader_enqueue = 1;
        
        public const int VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION = 1;
        
        public static ReadOnlyMemoryUtf8 VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME => "VK_AMDX_shader_enqueue"u8;
        
        public const uint VK_SHADER_INDEX_UNUSED_AMDX = 4294967295;
        
        public const int VK_NV_displacement_micromap = 1;
        
        public const int VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION = 2;
        
        public static ReadOnlyMemoryUtf8 VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME => "VK_NV_displacement_micromap"u8;
    }
}
