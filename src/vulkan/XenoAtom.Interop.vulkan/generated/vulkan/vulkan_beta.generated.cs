//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        /// <summary>
        /// Video encode tuning mode
        /// </summary>
        public enum VkVideoEncodeTuningModeKHR : uint
        {
            /// <summary>
            /// Specifies the default tuning mode.
            /// </summary>
            VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = unchecked((uint)0),
            
            /// <summary>
            /// Specifies that video encoding is tuned for high quality. When using this tuning mode, the implementation may: compromise the latency of video encoding operations to improve quality.
            /// </summary>
            VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that video encoding is tuned for low latency. When using this tuning mode, the implementation may: compromise quality to increase the performance and lower the latency of video encode operations.
            /// </summary>
            VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = unchecked((uint)2),
            
            /// <summary>
            /// Specifies that video encoding is tuned for ultra-low latency. When using this tuning mode, the implementation may: compromise quality to maximize the performance and minimize the latency of video encoding operations.
            /// </summary>
            VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = unchecked((uint)3),
            
            /// <summary>
            /// Specifies that video encoding is tuned for lossless encoding. When using this tuning mode, video encode operations produce lossless output.
            /// </summary>
            VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Specifies the default tuning mode.
        /// </summary>
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is tuned for high quality. When using this tuning mode, the implementation may: compromise the latency of video encoding operations to improve quality.
        /// </summary>
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR;
        
        /// <summary>
        /// Specifies that video encoding is tuned for low latency. When using this tuning mode, the implementation may: compromise quality to increase the performance and lower the latency of video encode operations.
        /// </summary>
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR;
        
        /// <summary>
        /// Specifies that video encoding is tuned for ultra-low latency. When using this tuning mode, the implementation may: compromise quality to maximize the performance and minimize the latency of video encoding operations.
        /// </summary>
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR;
        
        /// <summary>
        /// Specifies that video encoding is tuned for lossless encoding. When using this tuning mode, video encode operations produce lossless output.
        /// </summary>
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR;
        
        /// <summary>
        /// Video encode capability flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeCapabilityFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeCapabilityFlagBitsKHR VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = VkVideoEncodeCapabilityFlagBitsKHR.VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR;
        
        public const vulkan.VkVideoEncodeCapabilityFlagBitsKHR VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeCapabilityFlagBitsKHR.VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR;
        
        /// <summary>
        /// Video encode rate control modes
        /// </summary>
        [Flags]
        public enum VkVideoEncodeRateControlModeFlagBitsKHR : uint
        {
            /// <summary>
            /// Specifies the use of implementation-specific rate control.
            /// </summary>
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = unchecked((uint)0),
            
            /// <summary>
            /// Specifies that rate control is disabled and any quality control parameters for the encoding are provided on a per-picture basis. In this mode implementations will encode pictures independently of the output bitrate of prior video encode operations. When using an H.264 encode profile, implementations will use the QP values specified in the <see cref="T:VkVideoEncodeH264RateControlInfoEXT"/> structure for the encoded picture. When using an H.265 encode profile, implementations will use the QP values specified in the <see cref="T:VkVideoEncodeH265RateControlInfoEXT"/> structure for the encoded picture.
            /// </summary>
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = unchecked((uint)1),
            
            /// <summary>
            /// Specifies the use of constant bitrate rate control mode.
            /// </summary>
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = unchecked((uint)2),
            
            /// <summary>
            /// Specifies the use of variable bitrate rate control mode.
            /// </summary>
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Specifies the use of implementation-specific rate control.
        /// </summary>
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR;
        
        /// <summary>
        /// Specifies that rate control is disabled and any quality control parameters for the encoding are provided on a per-picture basis. In this mode implementations will encode pictures independently of the output bitrate of prior video encode operations. When using an H.264 encode profile, implementations will use the QP values specified in the <see cref="T:VkVideoEncodeH264RateControlInfoEXT"/> structure for the encoded picture. When using an H.265 encode profile, implementations will use the QP values specified in the <see cref="T:VkVideoEncodeH265RateControlInfoEXT"/> structure for the encoded picture.
        /// </summary>
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR;
        
        /// <summary>
        /// Specifies the use of constant bitrate rate control mode.
        /// </summary>
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR;
        
        /// <summary>
        /// Specifies the use of variable bitrate rate control mode.
        /// </summary>
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR;
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR;
        
        /// <summary>
        /// Bits specifying queried video encode feedback values
        /// </summary>
        [Flags]
        public enum VkVideoEncodeFeedbackFlagBitsKHR : uint
        {
            /// <summary>
            /// Specifies that queries managed by the pool will capture the byte offset of the bitstream data written by the video encode operation to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/> relative to the offset specified in <see cref="T:VkVideoEncodeInfoKHR.dstBufferOffset"/>.
            /// </summary>
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that queries managed by the pool will capture the number of bytes written by the video encode operation to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/>.
            /// </summary>
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = unchecked((uint)2),
            
            /// <summary>
            /// Specifies that queries managed by the pool will capture a boolean value indicating that the data written to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/> contains overridden parameters.
            /// </summary>
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Specifies that queries managed by the pool will capture the byte offset of the bitstream data written by the video encode operation to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/> relative to the offset specified in <see cref="T:VkVideoEncodeInfoKHR.dstBufferOffset"/>.
        /// </summary>
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR;
        
        /// <summary>
        /// Specifies that queries managed by the pool will capture the number of bytes written by the video encode operation to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/>.
        /// </summary>
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR;
        
        /// <summary>
        /// Specifies that queries managed by the pool will capture a boolean value indicating that the data written to the bitstream buffer specified in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/> contains overridden parameters.
        /// </summary>
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR;
        
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR;
        
        /// <summary>
        /// Video encode usage flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeUsageFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = unchecked((uint)0),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used in conjunction with video decoding to transcode a video bitstream with the same and/or different codecs.
            /// </summary>
            VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used to produce a video bitstream that is expected to be sent as a continuous flow over network.
            /// </summary>
            VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = unchecked((uint)2),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used for real-time recording for offline consumption.
            /// </summary>
            VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = unchecked((uint)4),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used in a video conferencing scenario.
            /// </summary>
            VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used in conjunction with video decoding to transcode a video bitstream with the same and/or different codecs.
        /// </summary>
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used to produce a video bitstream that is expected to be sent as a continuous flow over network.
        /// </summary>
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used for real-time recording for offline consumption.
        /// </summary>
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used in a video conferencing scenario.
        /// </summary>
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR;
        
        /// <summary>
        /// Video encode content flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeContentFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = unchecked((uint)0),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used to encode camera content.
            /// </summary>
            VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that video encoding is intended to be used to encode desktop content.
            /// </summary>
            VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = unchecked((uint)2),
            
            /// <summary>
            /// Specified that video encoding is intended to be used to encode rendered (e.g. game) content.
            /// </summary>
            VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used to encode camera content.
        /// </summary>
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR;
        
        /// <summary>
        /// Specifies that video encoding is intended to be used to encode desktop content.
        /// </summary>
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR;
        
        /// <summary>
        /// Specified that video encoding is intended to be used to encode rendered (e.g. game) content.
        /// </summary>
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR;
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR;
        
        /// <summary>
        /// Video encode H.264 capability flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH264CapabilityFlagBitsEXT : uint
        {
            /// <summary>
            /// Indicates if the implementation guarantees generating a HRD compliant bitstream if <c>nal_hrd_parameters_present_flag</c> or <c>vcl_hrd_parameters_present_flag</c> are enabled in <c>StdVideoH264SpsVuiFlags</c>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/> indicates that when <c>weighted_pred_flag</c> is enabled or <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is used, the implementation is able to internally decide syntax for <c>pred_weight_table</c>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT"/> indicates that each slice in a frame with multiple slices may begin or finish at any offset in a macroblock row. If not supported, all slices in the frame must: begin at the start of a macroblock row (and hence each slice must: finish at the end of a macroblock row). * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT"/> indicates that when a frame is encoded with multiple slices, the implementation allows encoding each slice with a different <c>StdVideoEncodeH264SliceHeader</c>. If not supported, all slices of the frame must: be encoded with the same <c>slice_type</c> which corresponds to the picture type of the frame. For example, all slices of a P-frame would be encoded as P-slices. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/> indicates support for using a B frame as L0 reference. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/> indicates support for using a B frame as L1 reference. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/> indicates support for specifying different QP values in the members of <see cref="T:VkVideoEncodeH264QpEXT"/>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT"/> indicates support for specifying different constant QP values for each slice. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT"/> indicates support for generating prefix NALUs by setting <see cref="T:VkVideoEncodeH264PictureInfoEXT.generatePrefixNalu"/> to <see cref="T:VK_TRUE"/>.
            /// </summary>
            VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Indicates if the implementation guarantees generating a HRD compliant bitstream if <c>nal_hrd_parameters_present_flag</c> or <c>vcl_hrd_parameters_present_flag</c> are enabled in <c>StdVideoH264SpsVuiFlags</c>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/> indicates that when <c>weighted_pred_flag</c> is enabled or <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is used, the implementation is able to internally decide syntax for <c>pred_weight_table</c>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT"/> indicates that each slice in a frame with multiple slices may begin or finish at any offset in a macroblock row. If not supported, all slices in the frame must: begin at the start of a macroblock row (and hence each slice must: finish at the end of a macroblock row). * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT"/> indicates that when a frame is encoded with multiple slices, the implementation allows encoding each slice with a different <c>StdVideoEncodeH264SliceHeader</c>. If not supported, all slices of the frame must: be encoded with the same <c>slice_type</c> which corresponds to the picture type of the frame. For example, all slices of a P-frame would be encoded as P-slices. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/> indicates support for using a B frame as L0 reference. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/> indicates support for using a B frame as L1 reference. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/> indicates support for specifying different QP values in the members of <see cref="T:VkVideoEncodeH264QpEXT"/>. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT"/> indicates support for specifying different constant QP values for each slice. * <see cref="T:VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT"/> indicates support for generating prefix NALUs by setting <see cref="T:VkVideoEncodeH264PictureInfoEXT.generatePrefixNalu"/> to <see cref="T:VK_TRUE"/>.
        /// </summary>
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Video encode H.264 syntax capability flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH264StdFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4),
            
            /// <summary>
            /// Indicates if setting non-zero <c>chroma_qp_index_offset</c> in <c>StdVideoH264PictureParameterSet</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT"/> indicates if setting non-zero <c>second_chroma_qp_index_offset</c> in <c>StdVideoH264PictureParameterSet</c> is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = unchecked((uint)16),
            
            /// <summary>
            /// Indicates if setting non-zero <c>pic_init_qp_minus26</c> in <c>StdVideoH264PictureParameterSet</c> is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = unchecked((uint)32),
            
            /// <summary>
            /// Indicates if enabling <c>weighted_pred_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transform_8x8_mode_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>StdVideoEncodeH264SliceHeaderFlags</c> is supported when it is present in the slice header. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT"/> indicates if CAVLC entropy coding is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT"/> indicates if CABAC entropy coding is supported. An implementation must: support at least one entropy coding mode. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>direct_8x8_inference_flag</c> in <c>StdVideoH264SpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>constrained_intra_pred_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED</c> from StdVideoH264DisableDeblockingFilterIdc is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED</c> from StdVideoH264DisableDeblockingFilterIdc is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL</c> from StdVideoH264DisableDeblockingFilterIdc is supported. An implementation must: support at least one deblocking filter mode.
            /// </summary>
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = unchecked((uint)1024),
            
            VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = unchecked((uint)2048),
            
            VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = unchecked((uint)4096),
            
            VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = unchecked((uint)8192),
            
            VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = unchecked((uint)16384),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = unchecked((uint)32768),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = unchecked((uint)65536),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = unchecked((uint)131072),
            
            VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT;
        
        /// <summary>
        /// Indicates if setting non-zero <c>chroma_qp_index_offset</c> in <c>StdVideoH264PictureParameterSet</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT"/> indicates if setting non-zero <c>second_chroma_qp_index_offset</c> in <c>StdVideoH264PictureParameterSet</c> is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT;
        
        /// <summary>
        /// Indicates if setting non-zero <c>pic_init_qp_minus26</c> in <c>StdVideoH264PictureParameterSet</c> is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT;
        
        /// <summary>
        /// Indicates if enabling <c>weighted_pred_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT</c> from <c>StdVideoH264WeightedBipredIdc</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transform_8x8_mode_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>StdVideoEncodeH264SliceHeaderFlags</c> is supported when it is present in the slice header. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT"/> indicates if CAVLC entropy coding is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT"/> indicates if CABAC entropy coding is supported. An implementation must: support at least one entropy coding mode. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>direct_8x8_inference_flag</c> in <c>StdVideoH264SpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>constrained_intra_pred_flag</c> in <c>StdVideoH264PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED</c> from StdVideoH264DisableDeblockingFilterIdc is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED</c> from StdVideoH264DisableDeblockingFilterIdc is supported. * <see cref="T:VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT"/> indicates if using <c>STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL</c> from StdVideoH264DisableDeblockingFilterIdc is supported. An implementation must: support at least one deblocking filter mode.
        /// </summary>
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// H.264 encode rate control bits
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH264RateControlFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that the application intends to use a regular GOP structure according to the parameters specified in the <see cref="M:gopFrameCount"/>, <see cref="M:idrPeriod"/>, and <see cref="M:consecutiveBFrameCount"/> members of the <see cref="T:VkVideoEncodeH264RateControlInfoEXT"/> structure. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/> specifies that the application intends to follow a flat reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic temporal layer pattern.
            /// </summary>
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT;
        
        /// <summary>
        /// Specifies that the application intends to use a regular GOP structure according to the parameters specified in the <see cref="M:gopFrameCount"/>, <see cref="M:idrPeriod"/>, and <see cref="M:consecutiveBFrameCount"/> members of the <see cref="T:VkVideoEncodeH264RateControlInfoEXT"/> structure. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/> specifies that the application intends to follow a flat reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic temporal layer pattern.
        /// </summary>
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Video encode H.265 capability flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH265CapabilityFlagBitsEXT : uint
        {
            /// <summary>
            /// Indicates if the implementation guarantees generating a HRD compliant bitstream if <c>nal_hrd_parameters_present_flag</c>, <c>vcl_hrd_parameters_present_flag</c>, or <c>sub_pic_hrd_params_present_flag</c> are enabled in <c>StdVideoH265HrdFlags</c>, or <c>vui_hrd_parameters_present_flag</c> is enabled in <c>StdVideoH265SpsVuiFlags</c>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/> indicates that when <c>weighted_pred_flag</c> or <c>weighted_bipred_flag</c> in <c>StdVideoH265PpsFlags</c> are enabled, the implementation is able to internally decide syntax for <c>pred_weight_table</c>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT"/> indicates that each slice segment in a frame with a single or multiple tiles per slice may begin or finish at any offset in a CTB row. If not supported, all slice segments in such a frame must: begin at the start of a CTB row (and hence each slice segment must: finish at the end of a CTB row). Also indicates that each slice segment in a frame with multiple slices per tile may begin or finish at any offset within the enclosing tile's CTB row. If not supported, slice segments in such a frame must: begin at the start of the enclosing tile's CTB row (and hence each slice segment must: finish at the end of the enclosing tile's CTB row). * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT"/> indicates that when a frame is encoded with multiple slice segments, the implementation allows encoding each slice segment with a different <c>StdVideoEncodeH265SliceSegmentHeader</c>. If not supported, all slice segments of the frame must: be encoded with the same <c>slice_type</c> which corresponds to the picture type of the frame. For example, all slice segments of a P-frame would be encoded as P-slices. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/> indicates support for using a B frame as L0 reference. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/> indicates support for using a B frame as L1 reference. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/> indicates support for specifying different QP values in the members of <see cref="T:VkVideoEncodeH265QpEXT"/>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT"/> indicates support for specifying different constant QP values for each slice segment. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT"/> indicates if encoding multiple tiles per slice segment is supported. If not set, the implementation is only able to encode a single tile for each slice segment. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT"/> indicates if encoding multiple slice segments per tile is supported. If not set, the implementation is only able to encode a single slice segment for each tile.
            /// </summary>
            VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Indicates if the implementation guarantees generating a HRD compliant bitstream if <c>nal_hrd_parameters_present_flag</c>, <c>vcl_hrd_parameters_present_flag</c>, or <c>sub_pic_hrd_params_present_flag</c> are enabled in <c>StdVideoH265HrdFlags</c>, or <c>vui_hrd_parameters_present_flag</c> is enabled in <c>StdVideoH265SpsVuiFlags</c>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT"/> indicates that when <c>weighted_pred_flag</c> or <c>weighted_bipred_flag</c> in <c>StdVideoH265PpsFlags</c> are enabled, the implementation is able to internally decide syntax for <c>pred_weight_table</c>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT"/> indicates that each slice segment in a frame with a single or multiple tiles per slice may begin or finish at any offset in a CTB row. If not supported, all slice segments in such a frame must: begin at the start of a CTB row (and hence each slice segment must: finish at the end of a CTB row). Also indicates that each slice segment in a frame with multiple slices per tile may begin or finish at any offset within the enclosing tile's CTB row. If not supported, slice segments in such a frame must: begin at the start of the enclosing tile's CTB row (and hence each slice segment must: finish at the end of the enclosing tile's CTB row). * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT"/> indicates that when a frame is encoded with multiple slice segments, the implementation allows encoding each slice segment with a different <c>StdVideoEncodeH265SliceSegmentHeader</c>. If not supported, all slice segments of the frame must: be encoded with the same <c>slice_type</c> which corresponds to the picture type of the frame. For example, all slice segments of a P-frame would be encoded as P-slices. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT"/> indicates support for using a B frame as L0 reference. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT"/> indicates support for using a B frame as L1 reference. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT"/> indicates support for specifying different QP values in the members of <see cref="T:VkVideoEncodeH265QpEXT"/>. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT"/> indicates support for specifying different constant QP values for each slice segment. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT"/> indicates if encoding multiple tiles per slice segment is supported. If not set, the implementation is only able to encode a single tile for each slice segment. * <see cref="T:VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT"/> indicates if encoding multiple slice segments per tile is supported. If not set, the implementation is only able to encode a single slice segment for each tile.
        /// </summary>
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Video encode H.265 syntax capability flags
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH265StdFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4),
            
            /// <summary>
            /// Indicates if enabling <c>pcm_enable_flag</c> in <c>StdVideoH265SpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>sps_temporal_mvp_enabled_flag</c> in <c>StdVideoH265SpsFlags</c> is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)16),
            
            /// <summary>
            /// Indicates if setting non-zero <c>init_qp_minus26</c> in <c>StdVideoH265PictureParameterSet</c> is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = unchecked((uint)32),
            
            /// <summary>
            /// Indicates if enabling <c>weighted_pred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>weighted_bipred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT"/> indicates if setting non-zero value for <c>log2_parallel_merge_level_minus2</c> in <c>StdVideoH265PictureParameterSet</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>sign_data_hiding_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transform_skip_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>transform_skip_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. Implementations must: report at least one of <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT"/> and <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT"/> as supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT"/> indicates if enabling <c>pps_slice_chroma_qp_offsets_present_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transquant_bypass_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>constrained_intra_pred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>entropy_coding_sync_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>deblocking_filter_override_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>dependent_slice_segments_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT"/> indicates if enabling <c>dependent_slice_segment_flag</c> in <c>StdVideoEncodeH265SliceHeaderFlags</c> is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)1024),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = unchecked((uint)2048),
            
            VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4096),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)8192),
            
            VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = unchecked((uint)16384),
            
            VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)32768),
            
            VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)65536),
            
            VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)131072),
            
            VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = unchecked((uint)262144),
            
            VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT;
        
        /// <summary>
        /// Indicates if enabling <c>pcm_enable_flag</c> in <c>StdVideoH265SpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>sps_temporal_mvp_enabled_flag</c> in <c>StdVideoH265SpsFlags</c> is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT;
        
        /// <summary>
        /// Indicates if setting non-zero <c>init_qp_minus26</c> in <c>StdVideoH265PictureParameterSet</c> is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT;
        
        /// <summary>
        /// Indicates if enabling <c>weighted_pred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>weighted_bipred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT"/> indicates if setting non-zero value for <c>log2_parallel_merge_level_minus2</c> in <c>StdVideoH265PictureParameterSet</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>sign_data_hiding_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transform_skip_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT"/> indicates if disabling <c>transform_skip_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. Implementations must: report at least one of <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT"/> and <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT"/> as supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT"/> indicates if enabling <c>pps_slice_chroma_qp_offsets_present_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>transquant_bypass_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>constrained_intra_pred_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>entropy_coding_sync_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>deblocking_filter_override_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT"/> indicates if enabling <c>dependent_slice_segments_enabled_flag</c> in <c>StdVideoH265PpsFlags</c> is supported. * <see cref="T:VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT"/> indicates if enabling <c>dependent_slice_segment_flag</c> in <c>StdVideoEncodeH265SliceHeaderFlags</c> is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Supported CTB sizes for H.265 video encode
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH265CtbSizeFlagBitsEXT : uint
        {
            /// <summary>
            /// Specifies that a CTB size of 16x16 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that a CTB size of 32x32 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = unchecked((uint)2),
            
            /// <summary>
            /// Specifies that a CTB size of 64x64 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Specifies that a CTB size of 16x16 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT;
        
        /// <summary>
        /// Specifies that a CTB size of 32x32 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT;
        
        /// <summary>
        /// Specifies that a CTB size of 64x64 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Supported transform block sizes for H.265 video encode
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH265TransformBlockSizeFlagBitsEXT : uint
        {
            /// <summary>
            /// Specifies that a transform block size of 4x4 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that a transform block size of 8x8 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = unchecked((uint)2),
            
            /// <summary>
            /// Specifies that a transform block size of 16x16 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = unchecked((uint)4),
            
            /// <summary>
            /// Specifies that a transform block size of 32x32 is supported.
            /// </summary>
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Specifies that a transform block size of 4x4 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT;
        
        /// <summary>
        /// Specifies that a transform block size of 8x8 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT;
        
        /// <summary>
        /// Specifies that a transform block size of 16x16 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT;
        
        /// <summary>
        /// Specifies that a transform block size of 32x32 is supported.
        /// </summary>
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// H.265 encode rate control bits
        /// </summary>
        [Flags]
        public enum VkVideoEncodeH265RateControlFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            /// <summary>
            /// Specifies that the application intends to use a regular GOP structure according to the parameters specified in the <see cref="M:gopFrameCount"/>, <see cref="M:idrPeriod"/>, and <see cref="M:consecutiveBFrameCount"/> members of the <see cref="T:VkVideoEncodeH265RateControlInfoEXT"/> structure. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/> specifies that the application intends to follow a flat reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic temporal sub-layer pattern.
            /// </summary>
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT;
        
        /// <summary>
        /// Specifies that the application intends to use a regular GOP structure according to the parameters specified in the <see cref="M:gopFrameCount"/>, <see cref="M:idrPeriod"/>, and <see cref="M:consecutiveBFrameCount"/> members of the <see cref="T:VkVideoEncodeH265RateControlInfoEXT"/> structure. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT"/> specifies that the application intends to follow a flat reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic reference pattern. * <see cref="T:VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT"/> specifies that the application intends to follow a dyadic temporal sub-layer pattern.
        /// </summary>
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT;
        
        /// <summary>
        /// Format enum for displacement micromaps
        /// </summary>
        public enum VkDisplacementMicromapFormatNV : uint
        {
            /// <summary>
            /// Indicates that the given micromap format encodes 64 micro-triangles worth of displacements in 64 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 256 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 1024 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding.
            /// </summary>
            VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = unchecked((uint)1),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = unchecked((uint)2),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = unchecked((uint)3),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = unchecked((uint)2147483647),
        }
        
        /// <summary>
        /// Indicates that the given micromap format encodes 64 micro-triangles worth of displacements in 64 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 256 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding. * <see cref="T:VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/> indicates that the given micromap format encodes 1024 micro-triangles worth of displacements in 128 bytes as described in Displacement Micromap Encoding.
        /// </summary>
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV;
        
        /// <summary>
        /// Structure describing the features that may not be supported by an implementation of the Vulkan 1.0 Portability Subset
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_portability_subset</para>
        /// </remarks>
        public partial struct VkPhysicalDevicePortabilitySubsetFeaturesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[features-constantAlphaColorBlendFactors]] <see cref="M:constantAlphaColorBlendFactors"/> indicates whether this implementation supports constant _alpha_ or a different number of bits in each component, than the texel format of the underlying <see cref="T:VkImage"/>. * [[features-imageViewFormatSwizzle]] <see cref="M:imageViewFormatSwizzle"/> indicates whether this implementation supports remapping format components using <see cref="T:VkImageViewCreateInfo.components"/>. * [[features-imageView2DOn3DImage]] <see cref="M:imageView2DOn3DImage"/> indicates whether this implementation supports a <see cref="T:VkImage"/> being created with the <see cref="T:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/> flag set, permitting a 2D or 2D array image view to be created on a 3D <see cref="T:VkImage"/>. * [[features-multisampleArrayImage]] <see cref="M:multisampleArrayImage"/> indicates whether this implementation supports a <see cref="T:VkImage"/> being created as a 2D array with multiple samples per texel. * [[features-mutableComparisonSamplers]] <see cref="M:mutableComparisonSamplers"/> indicates whether this implementation allows descriptors with comparison samplers to be &lt;&lt;descriptorsets-updates, updated. * [[features-pointPolygons]] <see cref="M:pointPolygons"/> indicates whether this implementation supports mipmap LOD bias value when creating a sampler. * [[features-separateStencilMaskRef]] <see cref="M:separateStencilMaskRef"/> indicates whether this implementation supports separate front and back <c>InterpolationFunction</c> capability and the extended instructions `InterpolateAtCentroid`, `InterpolateAtOffset`, and `InterpolateAtSample` from the `GLSL.std.450` extended instruction set. This member is only meaningful if the <see cref="M:sampleRateShading"/> feature is supported. * [[features-tessellationIsolines]] <see cref="M:tessellationIsolines"/> indicates whether this implementation supports isoline output from the <see cref="M:tessellationShader"/> are supported. * [[features-tessellationPointMode]] <see cref="M:tessellationPointMode"/> indicates whether this implementation supports point output from the <see cref="M:tessellationShader"/> are supported. * [[features-triangleFans]] <see cref="M:triangleFans"/> indicates whether this implementation supports &lt;&lt;drawing-triangle-fans&gt;&gt; primitive topology. * [[features-vertexAttributeAccessBeyondStride]] <see cref="M:vertexAttributeAccessBeyondStride"/> indicates whether this implementation supports accessing a vertex input attribute beyond the stride of the corresponding vertex input binding.
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBool32 constantAlphaColorBlendFactors;
            
            public vulkan.VkBool32 events;
            
            public vulkan.VkBool32 imageViewFormatReinterpretation;
            
            public vulkan.VkBool32 imageViewFormatSwizzle;
            
            public vulkan.VkBool32 imageView2DOn3DImage;
            
            public vulkan.VkBool32 multisampleArrayImage;
            
            public vulkan.VkBool32 mutableComparisonSamplers;
            
            public vulkan.VkBool32 pointPolygons;
            
            public vulkan.VkBool32 samplerMipLodBias;
            
            public vulkan.VkBool32 separateStencilMaskRef;
            
            public vulkan.VkBool32 shaderSampleRateInterpolationFunctions;
            
            public vulkan.VkBool32 tessellationIsolines;
            
            public vulkan.VkBool32 tessellationPointMode;
            
            public vulkan.VkBool32 triangleFans;
            
            public vulkan.VkBool32 vertexAttributeAccessBeyondStride;
        }
        
        /// <summary>
        /// Structure describing additional properties supported by a portable implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_portability_subset</para>
        /// </remarks>
        public partial struct VkPhysicalDevicePortabilitySubsetPropertiesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[limits-minVertexInputBindingStrideAlignment]] <see cref="M:minVertexInputBindingStrideAlignment"/> indicates the minimum alignment for vertex input strides. <see cref="T:VkVertexInputBindingDescription.stride"/> must: be a multiple of, and at least as large as, this value. The value must: be a power of two.
            /// </summary>
            public void* pNext;
            
            public uint minVertexInputBindingStrideAlignment;
        }
        
        /// <summary>
        /// Structure to chain codec-specific structures to
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR;
            
            /// <summary>
            /// A pointer to a structure extending this structure. A codec-specific extension structure must: be chained to specify what bitstream unit to generate with this encode operation.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkVideoEncodeFlagsKHR flags;
            
            /// <summary>
            /// The destination video bitstream buffer to write the encoded bitstream to.
            /// </summary>
            public vulkan.VkBuffer dstBuffer;
            
            /// <summary>
            /// The starting offset in bytes from the start of <see cref="M:dstBuffer"/> to write the encoded bitstream to. <see cref="M:dstBufferOffset"/>'s value must: be aligned to <see cref="T:VkVideoCapabilitiesKHR.minBitstreamBufferOffsetAlignment"/>, as reported by the implementation.
            /// </summary>
            public vulkan.VkDeviceSize dstBufferOffset;
            
            /// <summary>
            /// The maximum size in bytes of the encoded bitstream written to <see cref="M:dstBuffer"/>, starting from <see cref="M:dstBufferOffset"/>. <see cref="M:dstBufferRange"/>'s value must: be aligned to <see cref="T:VkVideoCapabilitiesKHR.minBitstreamBufferSizeAlignment"/>, as reported by the implementation.
            /// </summary>
            public vulkan.VkDeviceSize dstBufferRange;
            
            /// <summary>
            /// The Picture Resource of the Input Picture to be encoded by the operation.
            /// </summary>
            public vulkan.VkVideoPictureResourceInfoKHR srcPictureResource;
            
            /// <summary>
            /// A pointer to a <see cref="T:VkVideoReferenceSlotInfoKHR"/> structure used for generating a reconstructed reference slot and Picture Resource. <see cref="M:pSetupReferenceSlot"/>-&gt;slotIndex specifies the slot index number to use as a target for producing the Reconstructed (DPB) data. <see cref="M:pSetupReferenceSlot"/> must: be one of the entries provided in <see cref="T:VkVideoBeginCodingInfoKHR"/> via the <see cref="M:pReferenceSlots"/> within the <see cref="M:vkCmdBeginVideoCodingKHR"/> command that established the Vulkan Video Encode Context for this command.
            /// </summary>
            public vulkan.VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
            
            /// <summary>
            /// The number of Reconstructed Reference Pictures that will be used when this encoding operation is executing.
            /// </summary>
            public uint referenceSlotCount;
            
            /// <summary>
            /// `NULL` or a pointer to an array of <see cref="T:VkVideoReferenceSlotInfoKHR"/> structures that will be used when this encoding operation is executing. Each entry in <see cref="M:pReferenceSlots"/> must: be one of the entries provided in <see cref="T:VkVideoBeginCodingInfoKHR"/> via the <see cref="M:pReferenceSlots"/> within the <see cref="M:vkCmdBeginVideoCodingKHR"/> command that established the Vulkan Video Encode Context for this command.
            /// </summary>
            public vulkan.VkVideoReferenceSlotInfoKHR* pReferenceSlots;
            
            /// <summary>
            /// The number of bytes externally encoded for insertion in the active video encode session overall bitstream prior to the bitstream that will be generated by the implementation for this instance of <see cref="T:VkVideoEncodeInfoKHR"/>. The value provided is used to update the implementation's rate control algorithm for the rate control layer this instance of <see cref="T:VkVideoEncodeInfoKHR"/> belongs to, by accounting for the bitrate budget consumed by these externally encoded bytes. See <see cref="T:VkVideoEncodeRateControlInfoKHR"/> for additional information about encode rate control.
            /// </summary>
            public uint precedingExternallyEncodedBytes;
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeFlagsKHR : IEquatable<vulkan.VkVideoEncodeFlagsKHR>
        {
            public VkVideoEncodeFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeFlagsKHR left, VkVideoEncodeFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeFlagsKHR left, VkVideoEncodeFlagsKHR right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure specifying encode capabilities
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeCapabilitiesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeCapabilityFlagBitsKHR"/> describing supported encoding features.
            /// </summary>
            public vulkan.VkVideoEncodeCapabilityFlagsKHR flags;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeRateControlModeFlagBitsKHR"/> indicating supported rate control modes.
            /// </summary>
            public vulkan.VkVideoEncodeRateControlModeFlagsKHR rateControlModes;
            
            /// <summary>
            /// Indicates the maximum number of rate control layers supported.
            /// </summary>
            public uint maxRateControlLayers;
            
            /// <summary>
            /// Indicates the maximum supported bitrate.
            /// </summary>
            public ulong maxBitrate;
            
            /// <summary>
            /// Indicates the number of discrete video encode quality levels supported. Implementations must: report at least 1.
            /// </summary>
            public uint maxQualityLevels;
            
            /// <summary>
            /// Indicates the granularity at which encode input picture data is encoded.
            /// </summary>
            public vulkan.VkExtent2D encodeInputPictureGranularity;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeFeedbackFlagBitsKHR"/> values specifying the supported flags for video encode feedback queries.
            /// </summary>
            public vulkan.VkVideoEncodeFeedbackFlagsKHR supportedEncodeFeedbackFlags;
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeCapabilityFlagsKHR : IEquatable<vulkan.VkVideoEncodeCapabilityFlagsKHR>
        {
            public VkVideoEncodeCapabilityFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeCapabilityFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeCapabilityFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeCapabilityFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeCapabilityFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeCapabilityFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeCapabilityFlagsKHR left, VkVideoEncodeCapabilityFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeCapabilityFlagsKHR left, VkVideoEncodeCapabilityFlagsKHR right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeCapabilityFlagBitsKHR (vulkan.VkVideoEncodeCapabilityFlagsKHR from) => (vulkan.VkVideoEncodeCapabilityFlagBitsKHR)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeCapabilityFlagsKHR (vulkan.VkVideoEncodeCapabilityFlagBitsKHR from) => new vulkan.VkVideoEncodeCapabilityFlagsKHR((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeRateControlModeFlagsKHR : IEquatable<vulkan.VkVideoEncodeRateControlModeFlagsKHR>
        {
            public VkVideoEncodeRateControlModeFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeRateControlModeFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeRateControlModeFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeRateControlModeFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeRateControlModeFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeRateControlModeFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeRateControlModeFlagsKHR left, VkVideoEncodeRateControlModeFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeRateControlModeFlagsKHR left, VkVideoEncodeRateControlModeFlagsKHR right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeRateControlModeFlagBitsKHR (vulkan.VkVideoEncodeRateControlModeFlagsKHR from) => (vulkan.VkVideoEncodeRateControlModeFlagBitsKHR)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeRateControlModeFlagsKHR (vulkan.VkVideoEncodeRateControlModeFlagBitsKHR from) => new vulkan.VkVideoEncodeRateControlModeFlagsKHR((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeFeedbackFlagsKHR : IEquatable<vulkan.VkVideoEncodeFeedbackFlagsKHR>
        {
            public VkVideoEncodeFeedbackFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeFeedbackFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeFeedbackFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeFeedbackFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeFeedbackFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeFeedbackFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeFeedbackFlagsKHR left, VkVideoEncodeFeedbackFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeFeedbackFlagsKHR left, VkVideoEncodeFeedbackFlagsKHR right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeFeedbackFlagBitsKHR (vulkan.VkVideoEncodeFeedbackFlagsKHR from) => (vulkan.VkVideoEncodeFeedbackFlagBitsKHR)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeFeedbackFlagsKHR (vulkan.VkVideoEncodeFeedbackFlagBitsKHR from) => new vulkan.VkVideoEncodeFeedbackFlagsKHR((uint)from);
        }
        
        /// <summary>
        /// Structure specifying enabled video encode feedback values
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeFeedbackFlagBitsKHR"/> values specifying the set of enabled video encode feedback values captured by queries of the new pool.
            /// </summary>
            public vulkan.VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags;
        }
        
        /// <summary>
        /// Structure specifying video encode usage information
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeUsageInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeUsageFlagBitsKHR"/> specifying hints about the intended use of the video encode profile.
            /// </summary>
            public vulkan.VkVideoEncodeUsageFlagsKHR videoUsageHints;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeContentFlagBitsKHR"/> specifying hints about the content to be encoded using the video encode profile.
            /// </summary>
            public vulkan.VkVideoEncodeContentFlagsKHR videoContentHints;
            
            /// <summary>
            /// A <see cref="T:VkVideoEncodeTuningModeKHR"/> value specifying the tuning mode to use when encoding with the video profile.
            /// </summary>
            public vulkan.VkVideoEncodeTuningModeKHR tuningMode;
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeUsageFlagsKHR : IEquatable<vulkan.VkVideoEncodeUsageFlagsKHR>
        {
            public VkVideoEncodeUsageFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeUsageFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeUsageFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeUsageFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeUsageFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeUsageFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeUsageFlagsKHR left, VkVideoEncodeUsageFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeUsageFlagsKHR left, VkVideoEncodeUsageFlagsKHR right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeUsageFlagBitsKHR (vulkan.VkVideoEncodeUsageFlagsKHR from) => (vulkan.VkVideoEncodeUsageFlagBitsKHR)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeUsageFlagsKHR (vulkan.VkVideoEncodeUsageFlagBitsKHR from) => new vulkan.VkVideoEncodeUsageFlagsKHR((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeContentFlagsKHR : IEquatable<vulkan.VkVideoEncodeContentFlagsKHR>
        {
            public VkVideoEncodeContentFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeContentFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeContentFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeContentFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeContentFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeContentFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeContentFlagsKHR left, VkVideoEncodeContentFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeContentFlagsKHR left, VkVideoEncodeContentFlagsKHR right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeContentFlagBitsKHR (vulkan.VkVideoEncodeContentFlagsKHR from) => (vulkan.VkVideoEncodeContentFlagBitsKHR)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeContentFlagsKHR (vulkan.VkVideoEncodeContentFlagBitsKHR from) => new vulkan.VkVideoEncodeContentFlagsKHR((uint)from);
        }
        
        /// <summary>
        /// Structure to set encode per-layer rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeRateControlLayerInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
            
            /// <summary>
            /// A pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The average bitrate in bits/second. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/> or <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>.
            /// </summary>
            public ulong averageBitrate;
            
            /// <summary>
            /// The peak bitrate in bits/second. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>.
            /// </summary>
            public ulong maxBitrate;
            
            /// <summary>
            /// The numerator of the frame rate. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/> or <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>.
            /// </summary>
            public uint frameRateNumerator;
            
            /// <summary>
            /// The denominator of the frame rate. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/> or <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>.
            /// </summary>
            public uint frameRateDenominator;
        }
        
        /// <summary>
        /// Structure to set encode stream rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeRateControlInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            public vulkan.VkVideoEncodeRateControlFlagsKHR flags;
            
            /// <summary>
            /// A <see cref="T:VkVideoEncodeRateControlModeFlagBitsKHR"/> value specifying the encode stream rate control mode.
            /// </summary>
            public vulkan.VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
            
            /// <summary>
            /// Specifies the number of rate control layers in the video encode stream.
            /// </summary>
            public uint layerCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkVideoEncodeRateControlLayerInfoKHR"/> structures specifying the rate control configurations of <see cref="M:layerCount"/> rate control layers.
            /// </summary>
            public vulkan.VkVideoEncodeRateControlLayerInfoKHR* pLayers;
            
            /// <summary>
            /// The leaky bucket model virtual buffer size in milliseconds, with respect to peak bitrate. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/> or <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>. For example, virtual buffer size is (<see cref="M:virtualBufferSizeInMs"/> {times} <see cref="M:maxBitrate"/> / 1000).
            /// </summary>
            public uint virtualBufferSizeInMs;
            
            /// <summary>
            /// The initial occupancy in milliseconds of the virtual buffer in the leaky bucket model. Valid when rate control mode is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/> or <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>.
            /// </summary>
            public uint initialVirtualBufferSizeInMs;
        }
        
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeRateControlFlagsKHR : IEquatable<vulkan.VkVideoEncodeRateControlFlagsKHR>
        {
            public VkVideoEncodeRateControlFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeRateControlFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeRateControlFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeRateControlFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeRateControlFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeRateControlFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeRateControlFlagsKHR left, VkVideoEncodeRateControlFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeRateControlFlagsKHR left, VkVideoEncodeRateControlFlagsKHR right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Structure describing the video encode profile and quality level to query properties for
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a <see cref="T:VkVideoProfileInfoKHR"/> structure specifying the video profile to query the video encode quality level properties for.
            /// </summary>
            public vulkan.VkVideoProfileInfoKHR* pVideoProfile;
            
            /// <summary>
            /// The video encode quality level to query properties for.
            /// </summary>
            public uint qualityLevel;
        }
        
        /// <summary>
        /// Structure describing the video encode quality level properties
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeQualityLevelPropertiesKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <see cref="T:VkVideoEncodeRateControlModeFlagBitsKHR"/> value indicating the preferred rate control mode to use with the video encode quality level.
            /// </summary>
            public vulkan.VkVideoEncodeRateControlModeFlagBitsKHR preferredRateControlMode;
            
            /// <summary>
            /// Indicates the preferred number of rate control layers to use with the quality level.
            /// </summary>
            public uint preferredRateControlLayerCount;
        }
        
        /// <summary>
        /// Structure specifying used video encode quality level
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeQualityLevelInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The used video encode quality level.
            /// </summary>
            public uint qualityLevel;
        }
        
        /// <summary>
        /// Structure specifying parameters for retrieving encoded video session parameter data
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeSessionParametersGetInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The <see cref="T:VkVideoSessionParametersKHR"/> object to retrieve encoded parameter data from.
            /// </summary>
            public vulkan.VkVideoSessionParametersKHR videoSessionParameters;
        }
        
        /// <summary>
        /// Structure providing feedback about the requested video session parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_KHR_video_encode_queue</para>
        /// </remarks>
        public partial struct VkVideoEncodeSessionParametersFeedbackInfoKHR()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether any of the requested parameter data were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasOverrides;
        }
        
        /// <summary>
        /// Structure specifying H.264 encode capabilities
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264CapabilitiesEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH264CapabilityFlagBitsEXT"/> indicating supported H.264 encoding capabilities.
            /// </summary>
            public vulkan.VkVideoEncodeH264CapabilityFlagsEXT flags;
            
            /// <summary>
            /// A <c>StdVideoH264LevelIdc</c> value indicating the maximum H.264 level supported.
            /// </summary>
            public vulkan.StdVideoH264LevelIdc maxLevelIdc;
            
            /// <summary>
            /// Indicates the maximum number of slices that can: be encoded for a single picture. Further restrictions may: apply to the number of slices that can: be encoded for a single picture depending on other capabilities and codec-specific rules.
            /// </summary>
            public uint maxSliceCount;
            
            /// <summary>
            /// Indicates the maximum number of reference pictures the implementation supports in the reference list L0 for P pictures.
            /// </summary>
            public uint maxPPictureL0ReferenceCount;
            
            /// <summary>
            /// Indicates the maximum number of reference pictures the implementation supports in the reference list L0 for B pictures. The reported value is `0` if encoding of B pictures is not supported.
            /// </summary>
            public uint maxBPictureL0ReferenceCount;
            
            /// <summary>
            /// Reports the maximum number of reference pictures the implementation supports in the reference list L1 if encoding of B pictures is supported. The reported value is `0` if encoding of B pictures is not supported.
            /// </summary>
            public uint maxL1ReferenceCount;
            
            /// <summary>
            /// Indicates the maximum number of H.264 temporal layers supported by the implementation.
            /// </summary>
            public uint maxTemporalLayerCount;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithms expect the application to use a dyadic temporal layer pattern when encoding multiple temporal layers.
            /// </summary>
            public vulkan.VkBool32 expectDyadicTemporalLayerPattern;
            
            /// <summary>
            /// Indicates the minimum QP value supported.
            /// </summary>
            public int minQp;
            
            /// <summary>
            /// Indicates the maximum QP value supported.
            /// </summary>
            public int maxQp;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithm prefers the application to specify the number of frames of each type remaining in the current group of pictures.
            /// </summary>
            public vulkan.VkBool32 prefersGopRemainingFrames;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithm requires the application to specify the number of frames of each type remaining in the current group of pictures.
            /// </summary>
            public vulkan.VkBool32 requiresGopRemainingFrames;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH264StdFlagBitsEXT"/> indicating capabilities related to H.264 syntax elements.
            /// </summary>
            public vulkan.VkVideoEncodeH264StdFlagsEXT stdSyntaxFlags;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH264CapabilityFlagsEXT : IEquatable<vulkan.VkVideoEncodeH264CapabilityFlagsEXT>
        {
            public VkVideoEncodeH264CapabilityFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264CapabilityFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264CapabilityFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264CapabilityFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264CapabilityFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264CapabilityFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264CapabilityFlagsEXT left, VkVideoEncodeH264CapabilityFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264CapabilityFlagsEXT left, VkVideoEncodeH264CapabilityFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT (vulkan.VkVideoEncodeH264CapabilityFlagsEXT from) => (vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264CapabilityFlagsEXT (vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT from) => new vulkan.VkVideoEncodeH264CapabilityFlagsEXT((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH264StdFlagsEXT : IEquatable<vulkan.VkVideoEncodeH264StdFlagsEXT>
        {
            public VkVideoEncodeH264StdFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264StdFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264StdFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264StdFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264StdFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264StdFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264StdFlagsEXT left, VkVideoEncodeH264StdFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264StdFlagsEXT left, VkVideoEncodeH264StdFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH264StdFlagBitsEXT (vulkan.VkVideoEncodeH264StdFlagsEXT from) => (vulkan.VkVideoEncodeH264StdFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264StdFlagsEXT (vulkan.VkVideoEncodeH264StdFlagBitsEXT from) => new vulkan.VkVideoEncodeH264StdFlagsEXT((uint)from);
        }
        
        /// <summary>
        /// Structure describing H.264 QP values per picture type
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264QpEXT
        {
            /// <summary>
            /// The QP to be used for I-frames.
            /// </summary>
            public int qpI;
            
            /// <summary>
            /// The QP to be used for P-frames.
            /// </summary>
            public int qpP;
            
            /// <summary>
            /// The QP to be used for B-frames.
            /// </summary>
            public int qpB;
        }
        
        /// <summary>
        /// Structure describing the H.264 encode quality level properties
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264QualityLevelPropertiesEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH264RateControlFlagBitsEXT"/> values indicating the preferred flags to use for <see cref="T:VkVideoEncodeH264RateControlInfoEXT.flags"/>.
            /// </summary>
            public vulkan.VkVideoEncodeH264RateControlFlagsEXT preferredRateControlFlags;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH264RateControlInfoEXT.gopFrameCount"/>.
            /// </summary>
            public uint preferredGopFrameCount;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH264RateControlInfoEXT.idrPeriod"/>.
            /// </summary>
            public uint preferredIdrPeriod;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH264RateControlInfoEXT.consecutiveBFrameCount"/>.
            /// </summary>
            public uint preferredConsecutiveBFrameCount;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH264RateControlInfoEXT.temporalLayerCount"/>.
            /// </summary>
            public uint preferredTemporalLayerCount;
            
            /// <summary>
            /// Indicates the preferred values to use for <see cref="T:VkVideoEncodeH264NaluSliceInfoEXT.constantQp"/> for each picture type when using rate control mode <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>.
            /// </summary>
            public vulkan.VkVideoEncodeH264QpEXT preferredConstantQp;
            
            /// <summary>
            /// Indicates the preferred maximum number of reference pictures to use in the reference list L0.
            /// </summary>
            public uint preferredMaxL0ReferenceCount;
            
            /// <summary>
            /// Indicates the preferred maximum number of reference pictures to use in the reference list L1.
            /// </summary>
            public uint preferredMaxL1ReferenceCount;
            
            /// <summary>
            /// Indicates the preferred value to use for <c>entropy_coding_mode_flag</c> in <c>StdVideoH264PpsFlags</c>.
            /// </summary>
            public vulkan.VkBool32 preferredStdEntropyCodingModeFlag;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH264RateControlFlagsEXT : IEquatable<vulkan.VkVideoEncodeH264RateControlFlagsEXT>
        {
            public VkVideoEncodeH264RateControlFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264RateControlFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264RateControlFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264RateControlFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264RateControlFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264RateControlFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264RateControlFlagsEXT left, VkVideoEncodeH264RateControlFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264RateControlFlagsEXT left, VkVideoEncodeH264RateControlFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH264RateControlFlagBitsEXT (vulkan.VkVideoEncodeH264RateControlFlagsEXT from) => (vulkan.VkVideoEncodeH264RateControlFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264RateControlFlagsEXT (vulkan.VkVideoEncodeH264RateControlFlagBitsEXT from) => new vulkan.VkVideoEncodeH264RateControlFlagsEXT((uint)from);
        }
        
        /// <summary>
        /// Structure specifies H.264 encode session parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264SessionCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the value of <see cref="M:maxLevelIdc"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the value of <see cref="M:maxLevelIdc"/> and uses the value of <see cref="T:VkVideoEncodeH264CapabilitiesEXT.maxLevelIdc"/>, as reported by <see cref="M:vkGetPhysicalDeviceVideoCapabilitiesKHR"/> for the video profile.
            /// </summary>
            public vulkan.VkBool32 useMaxLevelIdc;
            
            /// <summary>
            /// Provides the upper bound on the H.264 level for the video bitstreams produced by the created video session.
            /// </summary>
            public vulkan.StdVideoH264LevelIdc maxLevelIdc;
        }
        
        /// <summary>
        /// Structure specifies H.264 encoder parameter set information
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264SessionParametersAddInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of SPS elements in the <see cref="M:pStdSPSs"/>. Its value must: be less than or equal to the value of <see cref="M:maxStdSPSCount"/>.
            /// </summary>
            public uint stdSPSCount;
            
            /// <summary>
            /// A pointer to an array of <c>StdVideoH264SequenceParameterSet</c> structures representing H.264 sequence parameter sets. Each element of the array must: have a unique H.264 SPS ID.
            /// </summary>
            public vulkan.StdVideoH264SequenceParameterSet* pStdSPSs;
            
            /// <summary>
            /// The number of PPS provided in <see cref="M:pStdPPSs"/>. Its value must: be less than or equal to the value of <see cref="M:maxStdPPSCount"/>.
            /// </summary>
            public uint stdPPSCount;
            
            /// <summary>
            /// A pointer to an array of <c>StdVideoH264PictureParameterSet</c> structures representing H.264 picture parameter sets. Each element of the array must: have a unique H.264 SPS-PPS ID pair.
            /// </summary>
            public vulkan.StdVideoH264PictureParameterSet* pStdPPSs;
        }
        
        /// <summary>
        /// Structure specifies H.264 encoder parameter set information
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264SessionParametersCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The maximum number of SPS parameters that the <see cref="T:VkVideoSessionParametersKHR"/> can contain.
            /// </summary>
            public uint maxStdSPSCount;
            
            /// <summary>
            /// The maximum number of PPS parameters that the <see cref="T:VkVideoSessionParametersKHR"/> can contain.
            /// </summary>
            public uint maxStdPPSCount;
            
            /// <summary>
            /// `NULL` or a pointer to a <see cref="T:VkVideoEncodeH264SessionParametersAddInfoEXT"/> structure specifying H.264 parameters to add upon object creation.
            /// </summary>
            public vulkan.VkVideoEncodeH264SessionParametersAddInfoEXT* pParametersAddInfo;
        }
        
        /// <summary>
        /// Structure specifying parameters for retrieving encoded H.264 parameter set data
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264SessionParametersGetInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the encoded H.264 sequence parameter set identified by <see cref="M:stdSPSId"/> is requested to be retrieved.
            /// </summary>
            public vulkan.VkBool32 writeStdSPS;
            
            /// <summary>
            /// Indicates whether the encoded H.264 picture parameter set identified by the pair constructed from <see cref="M:stdSPSId"/> and <see cref="M:stdPPSId"/> is requested to be retrieved.
            /// </summary>
            public vulkan.VkBool32 writeStdPPS;
            
            /// <summary>
            /// Specifies the H.264 sequence parameter set ID used to identify the retrieved H.264 sequence and/or picture parameter set(s).
            /// </summary>
            public uint stdSPSId;
            
            /// <summary>
            /// Specifies the H.264 picture parameter set ID used to identify the retrieved H.264 picture parameter set when <see cref="M:writeStdPPS"/> is set to <see cref="T:VK_TRUE"/>.
            /// </summary>
            public uint stdPPSId;
        }
        
        /// <summary>
        /// Structure providing feedback about the requested H.264 video session parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264SessionParametersFeedbackInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether any of the parameters of the requested H.264 sequence parameter set, if one was requested via <see cref="T:VkVideoEncodeH264SessionParametersGetInfoEXT.writeStdSPS"/>, were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasStdSPSOverrides;
            
            /// <summary>
            /// Indicates whether any of the parameters of the requested H.264 picture parameter set, if one was requested via <see cref="T:VkVideoEncodeH264SessionParametersGetInfoEXT.writeStdPPS"/>, were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasStdPPSOverrides;
        }
        
        /// <summary>
        /// Structure specifies H.264 encode slice NALU parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264NaluSliceInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The QP to use for the slice if the current rate control mode configured for the video session is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>.
            /// </summary>
            public int constantQp;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH264SliceHeader</c> structure specifying the slice header for the current slice.
            /// </summary>
            public vulkan.StdVideoEncodeH264SliceHeader* pStdSliceHeader;
        }
        
        /// <summary>
        /// Structure specifies H.264 encode frame parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264PictureInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of slice NALUs in the frame.
            /// </summary>
            public uint naluSliceEntryCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:naluSliceEntryCount"/> <see cref="T:VkVideoEncodeH264NaluSliceInfoEXT"/> structures specifying the division of the current picture into slices and the properties of these slices. This is an ordered sequence; the NALUs are generated consecutively in <see cref="T:VkVideoEncodeInfoKHR.dstBuffer"/> in the same order as in this array.
            /// </summary>
            public vulkan.VkVideoEncodeH264NaluSliceInfoEXT* pNaluSliceEntries;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH264PictureInfo</c> structure specifying the syntax and other codec-specific information from the H.264 specification associated with this picture. The information provided must: reflect the decoded picture marking operations that are applicable to this frame.
            /// </summary>
            public vulkan.StdVideoEncodeH264PictureInfo* pStdPictureInfo;
            
            /// <summary>
            /// Controls whether prefix NALUs are generated before slice NALUs into the target bitstream.
            /// </summary>
            public vulkan.VkBool32 generatePrefixNalu;
        }
        
        /// <summary>
        /// Structure specifies H.264 encode DPB picture information
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264DpbSlotInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH264ReferenceInfo</c> structure specifying the syntax and other codec-specific information from the H.264 specification associated with this reference picture.
            /// </summary>
            public vulkan.StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo;
        }
        
        /// <summary>
        /// Structure specifying H.264 encode profile
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264ProfileInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <c>StdVideoH264ProfileIdc</c> value specifying the H.264 codec profile IDC.
            /// </summary>
            public vulkan.StdVideoH264ProfileIdc stdProfileIdc;
        }
        
        /// <summary>
        /// Structure describing H.264 stream rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264RateControlInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH264RateControlFlagBitsEXT"/> specifying H.264 rate control flags.
            /// </summary>
            public vulkan.VkVideoEncodeH264RateControlFlagsEXT flags;
            
            /// <summary>
            /// The number of frames contained within the group of pictures (GOP), starting from an intra frame and until the next intra frame. If it is set to 0, the implementation chooses a suitable value. If it is set to <c>UINT32_MAX</c>, the GOP length is treated as infinite.
            /// </summary>
            public uint gopFrameCount;
            
            /// <summary>
            /// The interval, in terms of number of frames, between two IDR frames. If it is set to 0, the implementation chooses a suitable value. If it is set to <c>UINT32_MAX</c>, the IDR period is treated as infinite.
            /// </summary>
            public uint idrPeriod;
            
            /// <summary>
            /// The number of consecutive B-frames between I- and/or P-frames within the GOP.
            /// </summary>
            public uint consecutiveBFrameCount;
            
            /// <summary>
            /// Specifies the number of temporal layers enabled in the stream.
            /// </summary>
            public uint temporalLayerCount;
        }
        
        /// <summary>
        /// Structure describing frame size values per H.264 picture type
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264FrameSizeEXT
        {
            /// <summary>
            /// The size in bytes to be used for I-frames.
            /// </summary>
            public uint frameISize;
            
            /// <summary>
            /// The size in bytes to be used for P-frames.
            /// </summary>
            public uint framePSize;
            
            /// <summary>
            /// The size in bytes to be used for B-frames.
            /// </summary>
            public uint frameBSize;
        }
        
        /// <summary>
        /// Structure describing H.264 per-layer rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264RateControlLayerInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:minQp"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the values in <see cref="M:minQp"/> and chooses suitable values.
            /// </summary>
            public vulkan.VkBool32 useMinQp;
            
            /// <summary>
            /// Provides the lower bound on the QP values for each picture type, to be used in rate control calculations.
            /// </summary>
            public vulkan.VkVideoEncodeH264QpEXT minQp;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:maxQp"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the values in <see cref="M:maxQp"/> and chooses suitable values.
            /// </summary>
            public vulkan.VkBool32 useMaxQp;
            
            /// <summary>
            /// Provides the upper bound on the QP values for each picture type, to be used in rate control calculations.
            /// </summary>
            public vulkan.VkVideoEncodeH264QpEXT maxQp;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:maxFrameSize"/> should be used by the implementation.
            /// </summary>
            public vulkan.VkBool32 useMaxFrameSize;
            
            /// <summary>
            /// Provides the upper bound on the encoded frame size for each picture type. The implementation does not guarantee the encoded frame sizes will be within the specified limits, however these limits may: be used as a guide in rate control calculations. If enabled and not set properly, the <see cref="M:maxQp"/> limit may prevent the implementation from respecting the <see cref="M:maxFrameSize"/> limit.
            /// </summary>
            public vulkan.VkVideoEncodeH264FrameSizeEXT maxFrameSize;
        }
        
        /// <summary>
        /// Structure specifying H.264 encode rate control GOP remaining frame counts
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h264</para>
        /// </remarks>
        public partial struct VkVideoEncodeH264GopRemainingFrameInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the implementation's rate control algorithm should: use the values specified in <see cref="M:gopRemainingI"/>, <see cref="M:gopRemainingP"/>, and <see cref="M:gopRemainingB"/>. If <see cref="M:useGopRemainingFrames"/> is <see cref="T:VK_FALSE"/>, then the values of <see cref="M:gopRemainingI"/>, <see cref="M:gopRemainingP"/>, and <see cref="M:gopRemainingB"/> are ignored.
            /// </summary>
            public vulkan.VkBool32 useGopRemainingFrames;
            
            /// <summary>
            /// Specifies the number of I-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingI;
            
            /// <summary>
            /// Specifies the number of P-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingP;
            
            /// <summary>
            /// Specifies the number of B-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingB;
        }
        
        /// <summary>
        /// Structure specifying H.265 encode capabilities
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265CapabilitiesEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265CapabilityFlagBitsEXT"/> indicating supported H.265 encoding capabilities.
            /// </summary>
            public vulkan.VkVideoEncodeH265CapabilityFlagsEXT flags;
            
            /// <summary>
            /// A <c>StdVideoH265LevelIdc</c> value indicating the maximum H.265 level supported.
            /// </summary>
            public vulkan.StdVideoH265LevelIdc maxLevelIdc;
            
            /// <summary>
            /// Indicates the maximum number of slice segments that can: be encoded for a single picture. Further restrictions may: apply to the number of slice segments that can: be encoded for a single picture depending on other capabilities and codec-specific rules.
            /// </summary>
            public uint maxSliceSegmentCount;
            
            /// <summary>
            /// Indicates the maximum number of H.265 tile columns and rows that can: be encoded for a single picture. Further restrictions may: apply to the number of H.265 tiles that can: be encoded for a single picture depending on other capabilities and codec-specific rules.
            /// </summary>
            public vulkan.VkExtent2D maxTiles;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265CtbSizeFlagBitsEXT"/> describing the supported CTB sizes.
            /// </summary>
            public vulkan.VkVideoEncodeH265CtbSizeFlagsEXT ctbSizes;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265TransformBlockSizeFlagBitsEXT"/> describing the supported transform block sizes.
            /// </summary>
            public vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT transformBlockSizes;
            
            /// <summary>
            /// Indicates the maximum number of reference pictures the implementation supports in the reference list L0 for P pictures.
            /// </summary>
            public uint maxPPictureL0ReferenceCount;
            
            /// <summary>
            /// Indicates the maximum number of reference pictures the implementation supports in the reference list L0 for B pictures. The reported value is `0` if encoding of B pictures is not supported.
            /// </summary>
            public uint maxBPictureL0ReferenceCount;
            
            /// <summary>
            /// Indicates the maximum number of reference pictures the implementation supports in the reference list L1 if encoding of B pictures is supported. The reported value is `0` if encoding of B pictures is not supported.
            /// </summary>
            public uint maxL1ReferenceCount;
            
            /// <summary>
            /// Indicates the maximum number of H.265 sub-layers supported by the implementation.
            /// </summary>
            public uint maxSubLayerCount;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithms expect the application to use a dyadic temporal sub-layer pattern when encoding multiple temporal sub-layers.
            /// </summary>
            public vulkan.VkBool32 expectDyadicTemporalSubLayerPattern;
            
            /// <summary>
            /// Indicates the minimum QP value supported.
            /// </summary>
            public int minQp;
            
            /// <summary>
            /// Indicates the maximum QP value supported.
            /// </summary>
            public int maxQp;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithm prefers the application to specify the number of frames of each type remaining in the current group of pictures.
            /// </summary>
            public vulkan.VkBool32 prefersGopRemainingFrames;
            
            /// <summary>
            /// Indicates that the implementation's rate control algorithm requires the application to specify the number of frames of each type remaining in the current group of pictures.
            /// </summary>
            public vulkan.VkBool32 requiresGopRemainingFrames;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265StdFlagBitsEXT"/> indicating capabilities related to H.265 syntax elements.
            /// </summary>
            public vulkan.VkVideoEncodeH265StdFlagsEXT stdSyntaxFlags;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH265CapabilityFlagsEXT : IEquatable<vulkan.VkVideoEncodeH265CapabilityFlagsEXT>
        {
            public VkVideoEncodeH265CapabilityFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265CapabilityFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265CapabilityFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265CapabilityFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CapabilityFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265CapabilityFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265CapabilityFlagsEXT left, VkVideoEncodeH265CapabilityFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265CapabilityFlagsEXT left, VkVideoEncodeH265CapabilityFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT (vulkan.VkVideoEncodeH265CapabilityFlagsEXT from) => (vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CapabilityFlagsEXT (vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT from) => new vulkan.VkVideoEncodeH265CapabilityFlagsEXT((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH265CtbSizeFlagsEXT : IEquatable<vulkan.VkVideoEncodeH265CtbSizeFlagsEXT>
        {
            public VkVideoEncodeH265CtbSizeFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265CtbSizeFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265CtbSizeFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265CtbSizeFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CtbSizeFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265CtbSizeFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265CtbSizeFlagsEXT left, VkVideoEncodeH265CtbSizeFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265CtbSizeFlagsEXT left, VkVideoEncodeH265CtbSizeFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT (vulkan.VkVideoEncodeH265CtbSizeFlagsEXT from) => (vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CtbSizeFlagsEXT (vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT from) => new vulkan.VkVideoEncodeH265CtbSizeFlagsEXT((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH265TransformBlockSizeFlagsEXT : IEquatable<vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT>
        {
            public VkVideoEncodeH265TransformBlockSizeFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265TransformBlockSizeFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265TransformBlockSizeFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265TransformBlockSizeFlagsEXT left, VkVideoEncodeH265TransformBlockSizeFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265TransformBlockSizeFlagsEXT left, VkVideoEncodeH265TransformBlockSizeFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT (vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT from) => (vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT (vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT from) => new vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT((uint)from);
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH265StdFlagsEXT : IEquatable<vulkan.VkVideoEncodeH265StdFlagsEXT>
        {
            public VkVideoEncodeH265StdFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265StdFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265StdFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265StdFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265StdFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265StdFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265StdFlagsEXT left, VkVideoEncodeH265StdFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265StdFlagsEXT left, VkVideoEncodeH265StdFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH265StdFlagBitsEXT (vulkan.VkVideoEncodeH265StdFlagsEXT from) => (vulkan.VkVideoEncodeH265StdFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265StdFlagsEXT (vulkan.VkVideoEncodeH265StdFlagBitsEXT from) => new vulkan.VkVideoEncodeH265StdFlagsEXT((uint)from);
        }
        
        /// <summary>
        /// Structure specifies H.265 encode session parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265SessionCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the value of <see cref="M:maxLevelIdc"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the value of <see cref="M:maxLevelIdc"/> and uses the value of <see cref="T:VkVideoEncodeH265CapabilitiesEXT.maxLevelIdc"/>, as reported by <see cref="M:vkGetPhysicalDeviceVideoCapabilitiesKHR"/> for the video profile.
            /// </summary>
            public vulkan.VkBool32 useMaxLevelIdc;
            
            /// <summary>
            /// Provides the upper bound on the H.265 level for the video bitstreams produced by the created video session.
            /// </summary>
            public vulkan.StdVideoH265LevelIdc maxLevelIdc;
        }
        
        /// <summary>
        /// Structure describing H.265 QP values per picture type
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265QpEXT
        {
            /// <summary>
            /// The QP to be used for I-frames.
            /// </summary>
            public int qpI;
            
            /// <summary>
            /// The QP to be used for P-frames.
            /// </summary>
            public int qpP;
            
            /// <summary>
            /// The QP to be used for B-frames.
            /// </summary>
            public int qpB;
        }
        
        /// <summary>
        /// Structure describing the H.265 encode quality level properties
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265QualityLevelPropertiesEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265RateControlFlagBitsEXT"/> values indicating the preferred flags to use for <see cref="T:VkVideoEncodeH265RateControlInfoEXT.flags"/>.
            /// </summary>
            public vulkan.VkVideoEncodeH265RateControlFlagsEXT preferredRateControlFlags;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH265RateControlInfoEXT.gopFrameCount"/>.
            /// </summary>
            public uint preferredGopFrameCount;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH265RateControlInfoEXT.idrPeriod"/>.
            /// </summary>
            public uint preferredIdrPeriod;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH265RateControlInfoEXT.consecutiveBFrameCount"/>.
            /// </summary>
            public uint preferredConsecutiveBFrameCount;
            
            /// <summary>
            /// Indicates the preferred value to use for <see cref="T:VkVideoEncodeH265RateControlInfoEXT.subLayerCount"/>.
            /// </summary>
            public uint preferredSubLayerCount;
            
            /// <summary>
            /// Indicates the preferred values to use for <see cref="T:VkVideoEncodeH265NaluSliceSegmentInfoEXT.constantQp"/> for each picture type when using rate control mode <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>.
            /// </summary>
            public vulkan.VkVideoEncodeH265QpEXT preferredConstantQp;
            
            /// <summary>
            /// Indicates the preferred maximum number of reference pictures to use in the reference list L0.
            /// </summary>
            public uint preferredMaxL0ReferenceCount;
            
            /// <summary>
            /// Indicates the preferred maximum number of reference pictures to use in the reference list L1.
            /// </summary>
            public uint preferredMaxL1ReferenceCount;
        }
        
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public readonly partial struct VkVideoEncodeH265RateControlFlagsEXT : IEquatable<vulkan.VkVideoEncodeH265RateControlFlagsEXT>
        {
            public VkVideoEncodeH265RateControlFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265RateControlFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265RateControlFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265RateControlFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265RateControlFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265RateControlFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265RateControlFlagsEXT left, VkVideoEncodeH265RateControlFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265RateControlFlagsEXT left, VkVideoEncodeH265RateControlFlagsEXT right) => !left.Equals(right);
            
            public static implicit operator vulkan.VkVideoEncodeH265RateControlFlagBitsEXT (vulkan.VkVideoEncodeH265RateControlFlagsEXT from) => (vulkan.VkVideoEncodeH265RateControlFlagBitsEXT)(uint)from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265RateControlFlagsEXT (vulkan.VkVideoEncodeH265RateControlFlagBitsEXT from) => new vulkan.VkVideoEncodeH265RateControlFlagsEXT((uint)from);
        }
        
        /// <summary>
        /// Structure specifies H.265 encoder parameter set info
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265SessionParametersAddInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of VPS elements in <see cref="M:pStdVPSs"/>.
            /// </summary>
            public uint stdVPSCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:stdVPSCount"/> <c>StdVideoH265VideoParameterSet</c> structures representing H.265 video parameter sets.
            /// </summary>
            public vulkan.StdVideoH265VideoParameterSet* pStdVPSs;
            
            /// <summary>
            /// The number of SPS elements in <see cref="M:pStdSPSs"/>.
            /// </summary>
            public uint stdSPSCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:stdSPSCount"/> <c>StdVideoH265SequenceParameterSet</c> structures representing H.265 sequence parameter sets.
            /// </summary>
            public vulkan.StdVideoH265SequenceParameterSet* pStdSPSs;
            
            /// <summary>
            /// The number of PPS elements in <see cref="M:pStdPPSs"/>.
            /// </summary>
            public uint stdPPSCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:stdPPSCount"/> <c>StdVideoH265PictureParameterSet</c> structures representing H.265 picture parameter sets.
            /// </summary>
            public vulkan.StdVideoH265PictureParameterSet* pStdPPSs;
        }
        
        /// <summary>
        /// Structure specifies H.265 encoder parameter set info
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265SessionParametersCreateInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The maximum number of entries of type <c>StdVideoH265VideoParameterSet</c> within <see cref="T:VkVideoSessionParametersKHR"/>.
            /// </summary>
            public uint maxStdVPSCount;
            
            /// <summary>
            /// The maximum number of entries of type <c>StdVideoH265SequenceParameterSet</c> within <see cref="T:VkVideoSessionParametersKHR"/>.
            /// </summary>
            public uint maxStdSPSCount;
            
            /// <summary>
            /// The maximum number of entries of type <c>StdVideoH265PictureParameterSet</c> within <see cref="T:VkVideoSessionParametersKHR"/>.
            /// </summary>
            public uint maxStdPPSCount;
            
            /// <summary>
            /// `NULL` or a pointer to a <see cref="T:VkVideoEncodeH265SessionParametersAddInfoEXT"/> structure specifying the video session parameters to add upon creation of this object.
            /// </summary>
            public vulkan.VkVideoEncodeH265SessionParametersAddInfoEXT* pParametersAddInfo;
        }
        
        /// <summary>
        /// Structure specifying parameters for retrieving encoded H.265 parameter set data
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265SessionParametersGetInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the encoded H.265 video parameter set identified by <see cref="M:stdVPSId"/> is requested to be retrieved.
            /// </summary>
            public vulkan.VkBool32 writeStdVPS;
            
            /// <summary>
            /// Indicates whether the encoded H.265 sequence parameter set identified by the pair constructed from <see cref="M:stdVPSId"/> and <see cref="M:stdSPSId"/> is requested to be retrieved.
            /// </summary>
            public vulkan.VkBool32 writeStdSPS;
            
            /// <summary>
            /// Indicates whether the encoded H.265 picture parameter set identified by the triplet constructed from <see cref="M:stdVPSId"/>, <see cref="M:stdSPSId"/>, and <see cref="M:stdPPSId"/> is requested to be retrieved.
            /// </summary>
            public vulkan.VkBool32 writeStdPPS;
            
            /// <summary>
            /// Specifies the H.265 video parameter set ID used to identify the retrieved H.265 video, sequence, and/or picture parameter set(s).
            /// </summary>
            public uint stdVPSId;
            
            /// <summary>
            /// Specifies the H.265 sequence parameter set ID used to identify the retrieved H.265 sequence and/or picture parameter set(s) when <see cref="M:writeStdSPS"/> and/or <see cref="M:writeStdPPS"/> is set to <see cref="T:VK_TRUE"/>.
            /// </summary>
            public uint stdSPSId;
            
            /// <summary>
            /// Specifies the H.265 picture parameter set ID used to identify the retrieved H.265 picture parameter set when <see cref="M:writeStdPPS"/> is set to <see cref="T:VK_TRUE"/>.
            /// </summary>
            public uint stdPPSId;
        }
        
        /// <summary>
        /// Structure providing feedback about the requested H.265 video session parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265SessionParametersFeedbackInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether any of the parameters of the requested H.265 video parameter set, if one was requested via <see cref="T:VkVideoEncodeH265SessionParametersGetInfoEXT.writeStdVPS"/>, were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasStdVPSOverrides;
            
            /// <summary>
            /// Indicates whether any of the parameters of the requested H.265 sequence parameter set, if one was requested via <see cref="T:VkVideoEncodeH265SessionParametersGetInfoEXT.writeStdSPS"/>, were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasStdSPSOverrides;
            
            /// <summary>
            /// Indicates whether any of the parameters of the requested H.265 picture parameter set, if one was requested via <see cref="T:VkVideoEncodeH265SessionParametersGetInfoEXT.writeStdPPS"/>, were overridden by the implementation.
            /// </summary>
            public vulkan.VkBool32 hasStdPPSOverrides;
        }
        
        /// <summary>
        /// Structure specifies H.265 encode slice segment NALU parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265NaluSliceSegmentInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The QP to use for the slice segment if the current rate control mode configured for the video session is <see cref="T:VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>.
            /// </summary>
            public int constantQp;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH265SliceSegmentHeader</c> structure specifying the slice segment header for the current slice segment.
            /// </summary>
            public vulkan.StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader;
        }
        
        /// <summary>
        /// Structure specifies H.265 encode frame parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265PictureInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The number of slice segment NALUs in the frame.
            /// </summary>
            public uint naluSliceSegmentEntryCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkVideoEncodeH265NaluSliceSegmentInfoEXT"/> structures specifying the division of the current picture into slice segments and the properties of these slice segments.
            /// </summary>
            public vulkan.VkVideoEncodeH265NaluSliceSegmentInfoEXT* pNaluSliceSegmentEntries;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH265PictureInfo</c> structure specifying the syntax and other codec-specific information from the H.265 specification, associated with this picture.
            /// </summary>
            public vulkan.StdVideoEncodeH265PictureInfo* pStdPictureInfo;
        }
        
        /// <summary>
        /// Structure specifies H.265 encode decoded pic info
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265DpbSlotInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A pointer to a <c>StdVideoEncodeH265ReferenceInfo</c> structure specifying the syntax and other codec-specific information from the H.265 specification, associated with this reference picture.
            /// </summary>
            public vulkan.StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo;
        }
        
        /// <summary>
        /// Structure specifying H.265 encode profile
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265ProfileInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A <c>StdVideoH265ProfileIdc</c> value specifying the H.265 codec profile IDC.
            /// </summary>
            public vulkan.StdVideoH265ProfileIdc stdProfileIdc;
        }
        
        /// <summary>
        /// Structure describing H.265 stream rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265RateControlInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkVideoEncodeH265RateControlFlagBitsEXT"/> specifying H.265 rate control flags.
            /// </summary>
            public vulkan.VkVideoEncodeH265RateControlFlagsEXT flags;
            
            /// <summary>
            /// The number of frames contained within the group of pictures (GOP), starting from an intra frame and until the next intra frame. If it is set to 0, the implementation chooses a suitable value. If it is set to <c>UINT32_MAX</c>, the GOP length is treated as infinite.
            /// </summary>
            public uint gopFrameCount;
            
            /// <summary>
            /// The interval, in terms of number of frames, between two IDR frames. If it is set to 0, the implementation chooses a suitable value. If it is set to <c>UINT32_MAX</c>, the IDR period is treated as infinite.
            /// </summary>
            public uint idrPeriod;
            
            /// <summary>
            /// The number of consecutive B-frames between I- and/or P-frames within the GOP.
            /// </summary>
            public uint consecutiveBFrameCount;
            
            /// <summary>
            /// Specifies the number of sub layers enabled in the stream.
            /// </summary>
            public uint subLayerCount;
        }
        
        /// <summary>
        /// Structure describing frame size values per H.265 picture type
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265FrameSizeEXT
        {
            /// <summary>
            /// The size in bytes to be used for I-frames.
            /// </summary>
            public uint frameISize;
            
            /// <summary>
            /// The size in bytes to be used for P-frames.
            /// </summary>
            public uint framePSize;
            
            /// <summary>
            /// The size in bytes to be used for B-frames.
            /// </summary>
            public uint frameBSize;
        }
        
        /// <summary>
        /// Structure describing H.265 per-layer rate control parameters
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265RateControlLayerInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:minQp"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the values in <see cref="M:minQp"/> and chooses suitable values.
            /// </summary>
            public vulkan.VkBool32 useMinQp;
            
            /// <summary>
            /// Provides the lower bound on the QP values for each picture type, to be used in rate control calculations.
            /// </summary>
            public vulkan.VkVideoEncodeH265QpEXT minQp;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:maxQp"/> should be used by the implementation. When it is set to <see cref="T:VK_FALSE"/>, the implementation ignores the values in <see cref="M:maxQp"/> and chooses suitable values.
            /// </summary>
            public vulkan.VkBool32 useMaxQp;
            
            /// <summary>
            /// Provides the upper bound on the QP values for each picture type, to be used in rate control calculations.
            /// </summary>
            public vulkan.VkVideoEncodeH265QpEXT maxQp;
            
            /// <summary>
            /// Indicates whether the values within <see cref="M:maxFrameSize"/> should be used by the implementation.
            /// </summary>
            public vulkan.VkBool32 useMaxFrameSize;
            
            /// <summary>
            /// Provides the upper bound on the encoded frame size for each picture type. The implementation does not guarantee the encoded frame sizes will be within the specified limits, however these limits may: be used as a guide in rate control calculations. If enabled and not set properly, the <see cref="M:maxQp"/> limit may prevent the implementation from respecting the <see cref="M:maxFrameSize"/> limit.
            /// </summary>
            public vulkan.VkVideoEncodeH265FrameSizeEXT maxFrameSize;
        }
        
        /// <summary>
        /// Structure specifying H.265 encode rate control GOP remaining frame counts
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_EXT_video_encode_h265</para>
        /// </remarks>
        public partial struct VkVideoEncodeH265GopRemainingFrameInfoEXT()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates whether the implementation's rate control algorithm should: use the values specified in <see cref="M:gopRemainingI"/>, <see cref="M:gopRemainingP"/>, and <see cref="M:gopRemainingB"/>. If <see cref="M:useGopRemainingFrames"/> is <see cref="T:VK_FALSE"/>, then the values of <see cref="M:gopRemainingI"/>, <see cref="M:gopRemainingP"/>, and <see cref="M:gopRemainingB"/> are ignored.
            /// </summary>
            public vulkan.VkBool32 useGopRemainingFrames;
            
            /// <summary>
            /// Specifies the number of I-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingI;
            
            /// <summary>
            /// Specifies the number of P-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingP;
            
            /// <summary>
            /// Specifies the number of B-frames the implementation's rate control algorithm should: assume to be remaining in the GOP prior to executing the video encode operation.
            /// </summary>
            public uint gopRemainingB;
        }
        
        /// <summary>
        /// Structure describing whether shader enqueue within execution graphs are supported by the implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceShaderEnqueueFeaturesAMDX()
        {
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX;
            
            public void* pNext;
            
            public vulkan.VkBool32 shaderEnqueue;
        }
        
        /// <summary>
        /// Structure describing shader enqueue limits of an implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceShaderEnqueuePropertiesAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[limits-maxExecutionGraphDepth]] <see cref="M:maxExecutionGraphDepth"/> defines the maximum node chain depth in the graph. The dispatched node is at depth 1 and the node enqueued by it is at depth 2, and so on. If a node enqueues itself, each recursive enqueue increases the depth by 1 as well. * [[limits-maxExecutionGraphShaderOutputNodes]] <see cref="M:maxExecutionGraphShaderOutputNodes"/> specifies the maximum number of unique nodes that can be dispatched from a single shader, and must be at least 256. * [[limits-maxExecutionGraphShaderPayloadSize]] <see cref="M:maxExecutionGraphShaderPayloadSize"/> specifies the maximum total size of payload declarations in a shader. For any payload declarations that share resources, indicated by <c>NodeSharesPayloadLimitsWithAMDX</c> decorations, the maximum size of each set of shared payload declarations is taken. The sum of each shared set's maximum size and the size of each unshared payload is counted against this limit. * [[limits-maxExecutionGraphShaderPayloadCount]] <see cref="M:maxExecutionGraphShaderPayloadCount"/> specifies the maximum number of output payloads that can be initialized in a single workgroup. * [[limits-executionGraphDispatchAddressAlignment]] <see cref="M:executionGraphDispatchAddressAlignment"/> specifies the alignment of non-scratch basetype:VkDeviceAddress arguments consumed by graph dispatch commands.
            /// </summary>
            public void* pNext;
            
            public uint maxExecutionGraphDepth;
            
            public uint maxExecutionGraphShaderOutputNodes;
            
            public uint maxExecutionGraphShaderPayloadSize;
            
            public uint maxExecutionGraphShaderPayloadCount;
            
            public uint executionGraphDispatchAddressAlignment;
        }
        
        /// <summary>
        /// Structure describing the scratch space required to dispatch an execution graph
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkExecutionGraphPipelineScratchSizeAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// Indicates the scratch space required for dispatch the queried execution graph.
            /// </summary>
            public vulkan.VkDeviceSize size;
        }
        
        /// <summary>
        /// Structure specifying parameters of a newly created execution graph pipeline
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkExecutionGraphPipelineCreateInfoAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// A bitmask of <see cref="T:VkPipelineCreateFlagBits"/> specifying how the pipeline will be generated.
            /// </summary>
            public vulkan.VkPipelineCreateFlags flags;
            
            /// <summary>
            /// The number of entries in the <see cref="M:pStages"/> array.
            /// </summary>
            public uint stageCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="M:stageCount"/> <see cref="T:VkPipelineShaderStageCreateInfo"/> structures describing the set of the shader stages to be included in the execution graph pipeline.
            /// </summary>
            public vulkan.VkPipelineShaderStageCreateInfo* pStages;
            
            /// <summary>
            /// A pointer to a <see cref="T:VkPipelineLibraryCreateInfoKHR"/> structure defining pipeline libraries to include.
            /// </summary>
            public vulkan.VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
            
            /// <summary>
            /// The description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
            /// </summary>
            public vulkan.VkPipelineLayout layout;
            
            /// <summary>
            /// A pipeline to derive from
            /// </summary>
            public vulkan.VkPipeline basePipelineHandle;
            
            /// <summary>
            /// An index into the <see cref="M:pCreateInfos"/> parameter to use as a pipeline to derive from
            /// </summary>
            public int basePipelineIndex;
        }
        
        /// <summary>
        /// Union specifying a const device or host address
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
        public partial struct VkDeviceOrHostAddressConstAMDX
        {
            /// <summary>
            /// A buffer device address as returned by the <see cref="M:vkGetBufferDeviceAddressKHR"/> command.
            /// </summary>
            [FieldOffset(0)]
            public vulkan.VkDeviceAddress deviceAddress;
            
            /// <summary>
            /// A const host memory address.
            /// </summary>
            [FieldOffset(0)]
            public void* hostAddress;
        }
        
        /// <summary>
        /// Structure specifying node parameters for execution graph dispatch
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkDispatchGraphInfoAMDX
        {
            /// <summary>
            /// The index of a node in an execution graph to be dispatched.
            /// </summary>
            public uint nodeIndex;
            
            /// <summary>
            /// The number of payloads to dispatch for the specified node.
            /// </summary>
            public uint payloadCount;
            
            /// <summary>
            /// A device or host address pointer to a flat array of payloads with size equal to the product of <see cref="M:payloadCount"/> and <see cref="M:payloadStride"/>
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstAMDX payloads;
            
            /// <summary>
            /// The byte stride between successive payloads in <see cref="M:payloads"/>
            /// </summary>
            public ulong payloadStride;
        }
        
        /// <summary>
        /// Structure specifying count parameters for execution graph dispatch
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkDispatchGraphCountInfoAMDX
        {
            /// <summary>
            /// The number of dispatches to perform.
            /// </summary>
            public uint count;
            
            /// <summary>
            /// The device or host address of a flat array of <see cref="T:VkDispatchGraphInfoAMDX"/> structures
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstAMDX infos;
            
            /// <summary>
            /// The byte stride between successive <see cref="T:VkDispatchGraphInfoAMDX"/> structures in <see cref="M:infos"/>
            /// </summary>
            public ulong stride;
        }
        
        /// <summary>
        /// Structure specifying the shader name and index with an execution graph
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_AMDX_shader_enqueue</para>
        /// </remarks>
        public partial struct VkPipelineShaderStageNodeCreateInfoAMDX()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The shader name to use when creating a node in an execution graph. If <see cref="M:pName"/> is `NULL`, the name of the entry point specified in SPIR-V is used as the shader name.
            /// </summary>
            public byte* pName;
            
            /// <summary>
            /// The shader index to use when creating a node in an execution graph. If <see cref="M:index"/> is <see cref="T:VK_SHADER_INDEX_UNUSED_AMDX"/> then the original index is used, either as specified by the <c>ShaderIndexAMDX</c> execution mode, or `0` if that too is not specified.
            /// </summary>
            public uint index;
        }
        
        /// <summary>
        /// Structure describing the ray tracing displacement micromap features that can be supported by an implementation
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceDisplacementMicromapFeaturesNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure. * [[features-displacementMicromap]] <see cref="M:displacementMicromap"/> indicates whether the implementation supports the displacement micromap feature.
            /// </summary>
            public void* pNext;
            
            public vulkan.VkBool32 displacementMicromap;
        }
        
        /// <summary>
        /// Structure describing the displacement micromap properties of a physical device
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkPhysicalDeviceDisplacementMicromapPropertiesNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The maximum allowed <see cref="M:subdivisionLevel"/> for displacement micromaps.
            /// </summary>
            public uint maxDisplacementMicromapSubdivisionLevel;
        }
        
        /// <summary>
        /// Structure specifying a displacement micromap in a bottom-level acceleration structure
        /// </summary>
        /// <remarks>
        /// <para>Extension: VK_NV_displacement_micromap</para>
        /// </remarks>
        public partial struct VkAccelerationStructureTrianglesDisplacementMicromapNV()
        {
            /// <summary>
            /// A <see cref="T:VkStructureType"/> value identifying this structure.
            /// </summary>
            public vulkan.VkStructureType sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV;
            
            /// <summary>
            /// `NULL` or a pointer to a structure extending this structure.
            /// </summary>
            public void* pNext;
            
            /// <summary>
            /// The format of displacement bias and scale used in this displacement micromap reference.
            /// </summary>
            public vulkan.VkFormat displacementBiasAndScaleFormat;
            
            /// <summary>
            /// The format of displacement vector used in this displacement micromap reference.
            /// </summary>
            public vulkan.VkFormat displacementVectorFormat;
            
            /// <summary>
            /// The address containing the bias and scale.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer;
            
            /// <summary>
            /// The byte stride between bias and scale values.
            /// </summary>
            public vulkan.VkDeviceSize displacementBiasAndScaleStride;
            
            /// <summary>
            /// The address containing the displacement vector values.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacementVectorBuffer;
            
            /// <summary>
            /// The byte stride between displacement vector values.
            /// </summary>
            public vulkan.VkDeviceSize displacementVectorStride;
            
            /// <summary>
            /// The address containing the primitive flags.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags;
            
            /// <summary>
            /// The byte stride between primitive flag values.
            /// </summary>
            public vulkan.VkDeviceSize displacedMicromapPrimitiveFlagsStride;
            
            /// <summary>
            /// The type of triangle indices used when indexing this micromap.
            /// </summary>
            public vulkan.VkIndexType indexType;
            
            /// <summary>
            /// The address containing the triangle indices.
            /// </summary>
            public vulkan.VkDeviceOrHostAddressConstKHR indexBuffer;
            
            /// <summary>
            /// The byte stride between triangle indices.
            /// </summary>
            public vulkan.VkDeviceSize indexStride;
            
            /// <summary>
            /// The base value added to the non-negative triangle indices.
            /// </summary>
            public uint baseTriangle;
            
            /// <summary>
            /// Specifies the number of usage counts structures that will be used to determine the size of this micromap.
            /// </summary>
            public uint usageCountsCount;
            
            /// <summary>
            /// A pointer to an array of <see cref="T:VkMicromapUsageEXT"/> structures.
            /// </summary>
            public vulkan.VkMicromapUsageEXT* pUsageCounts;
            
            /// <summary>
            /// A pointer to an array of pointers to <see cref="T:VkMicromapUsageEXT"/> structures.
            /// </summary>
            public vulkan.VkMicromapUsageEXT** ppUsageCounts;
            
            /// <summary>
            /// The handle to the micromap object to include in this geometry.
            /// </summary>
            public vulkan.VkMicromapEXT micromap;
        }
        
        public readonly partial struct PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR : IEquatable<vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR>, IvkFunctionPointer<vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR>
        {
            public PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> (vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(from);
            
            public static bool operator ==(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR left, PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR left, PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR> Prototype => new("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"u8);
            
            /// <summary>
            /// Query video encode quality level properties
            /// </summary>
            /// <param name="physicalDevice">The physical device to query the video encode quality level properties for.</param>
            /// <param name="pQualityLevelInfo">A pointer to a <see cref="T:VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR"/> structure specifying the video encode profile and quality level to query properties for.</param>
            /// <param name="pQualityLevelProperties">A pointer to a <see cref="T:VkVideoEncodeQualityLevelPropertiesKHR"/> structure in which the properties are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR</c></description></item>
            /// </list>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, vulkan.VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties)
            {
                return Value(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query video encode quality level properties
            /// </summary>
            /// <param name="physicalDevice">The physical device to query the video encode quality level properties for.</param>
            /// <param name="pQualityLevelInfo">A pointer to a <see cref="T:VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR"/> structure specifying the video encode profile and quality level to query properties for.</param>
            /// <param name="pQualityLevelProperties">A pointer to a <see cref="T:VkVideoEncodeQualityLevelPropertiesKHR"/> structure in which the properties are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR</c></description></item><item><description><c>VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR</c></description></item>
            /// </list>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkPhysicalDevice physicalDevice, in vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR pQualityLevelInfo, ref vulkan.VkVideoEncodeQualityLevelPropertiesKHR pQualityLevelProperties)
            {
                fixed (vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* __pQualityLevelInfo_local = &pQualityLevelInfo)
                fixed (vulkan.VkVideoEncodeQualityLevelPropertiesKHR* __pQualityLevelProperties_local = &pQualityLevelProperties)
                return this.Invoke(physicalDevice, __pQualityLevelInfo_local, __pQualityLevelProperties_local);
            }
        }
        
        public readonly partial struct PFN_vkGetEncodedVideoSessionParametersKHR : IEquatable<vulkan.PFN_vkGetEncodedVideoSessionParametersKHR>, IvkFunctionPointer<vulkan.PFN_vkGetEncodedVideoSessionParametersKHR>
        {
            public PFN_vkGetEncodedVideoSessionParametersKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetEncodedVideoSessionParametersKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetEncodedVideoSessionParametersKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> (vulkan.PFN_vkGetEncodedVideoSessionParametersKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetEncodedVideoSessionParametersKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> from) => new vulkan.PFN_vkGetEncodedVideoSessionParametersKHR(from);
            
            public static bool operator ==(PFN_vkGetEncodedVideoSessionParametersKHR left, PFN_vkGetEncodedVideoSessionParametersKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetEncodedVideoSessionParametersKHR left, PFN_vkGetEncodedVideoSessionParametersKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetEncodedVideoSessionParametersKHR`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkGetEncodedVideoSessionParametersKHR> Prototype => new("vkGetEncodedVideoSessionParametersKHR"u8);
            
            /// <summary>
            /// Get encoded parameter sets from a video session parameters object
            /// </summary>
            /// <param name="device">The logical device that owns the video session parameters object.</param>
            /// <param name="pVideoSessionParametersInfo">A pointer to a <see cref="T:VkVideoEncodeSessionParametersGetInfoKHR"/> structure specifying the parameters of the encoded parameter data to retrieve.</param>
            /// <param name="pFeedbackInfo">Either `NULL` or a pointer to a <see cref="T:VkVideoEncodeSessionParametersFeedbackInfoKHR"/> structure in which feedback about the requested parameter data is returned. This parameter is optional.</param>
            /// <param name="pDataSize">A pointer to a <c>size_t</c> value related to the amount of encode parameter data returned, as described below.</param>
            /// <param name="pData">Either `NULL` or a pointer to a buffer to write the encoded parameter data to. This parameter is optional.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_INCOMPLETE</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, nuint* pDataSize, void* pData)
            {
                return Value(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Get encoded parameter sets from a video session parameters object
            /// </summary>
            /// <param name="device">The logical device that owns the video session parameters object.</param>
            /// <param name="pVideoSessionParametersInfo">A pointer to a <see cref="T:VkVideoEncodeSessionParametersGetInfoKHR"/> structure specifying the parameters of the encoded parameter data to retrieve.</param>
            /// <param name="pFeedbackInfo">Either `NULL` or a pointer to a <see cref="T:VkVideoEncodeSessionParametersFeedbackInfoKHR"/> structure in which feedback about the requested parameter data is returned. This parameter is optional.</param>
            /// <param name="pDataSize">A pointer to a <c>size_t</c> value related to the amount of encode parameter data returned, as described below.</param>
            /// <param name="pData">Either `NULL` or a pointer to a buffer to write the encoded parameter data to. This parameter is optional.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_INCOMPLETE</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, in vulkan.VkVideoEncodeSessionParametersGetInfoKHR pVideoSessionParametersInfo, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, nuint* pDataSize, void* pData)
            {
                fixed (vulkan.VkVideoEncodeSessionParametersGetInfoKHR* __pVideoSessionParametersInfo_local = &pVideoSessionParametersInfo)
                return this.Invoke(device, __pVideoSessionParametersInfo_local, pFeedbackInfo, pDataSize, pData);
            }
        }
        
        public readonly partial struct PFN_vkCmdEncodeVideoKHR : IEquatable<vulkan.PFN_vkCmdEncodeVideoKHR>, IvkFunctionPointer<vulkan.PFN_vkCmdEncodeVideoKHR>
        {
            public PFN_vkCmdEncodeVideoKHR(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdEncodeVideoKHR other && Equals(other);
            
            public bool Equals(PFN_vkCmdEncodeVideoKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> (vulkan.PFN_vkCmdEncodeVideoKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdEncodeVideoKHR (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> from) => new vulkan.PFN_vkCmdEncodeVideoKHR(from);
            
            public static bool operator ==(PFN_vkCmdEncodeVideoKHR left, PFN_vkCmdEncodeVideoKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdEncodeVideoKHR left, PFN_vkCmdEncodeVideoKHR right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdEncodeVideoKHR`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCmdEncodeVideoKHR> Prototype => new("vkCmdEncodeVideoKHR"u8);
            
            /// <summary>
            /// Encode operation for bitstream generation
            /// </summary>
            /// <param name="commandBuffer">The command buffer to be filled with this function for encoding to generate a bitstream.</param>
            /// <param name="pEncodeInfo">A pointer to a <see cref="T:VkVideoEncodeInfoKHR"/> structure.</param>
            /// <remarks>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkVideoEncodeInfoKHR* pEncodeInfo)
            {
                Value(commandBuffer, pEncodeInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Encode operation for bitstream generation
            /// </summary>
            /// <param name="commandBuffer">The command buffer to be filled with this function for encoding to generate a bitstream.</param>
            /// <param name="pEncodeInfo">A pointer to a <see cref="T:VkVideoEncodeInfoKHR"/> structure.</param>
            /// <remarks>
            /// <para>Extension: VK_KHR_video_encode_queue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, in vulkan.VkVideoEncodeInfoKHR pEncodeInfo)
            {
                fixed (vulkan.VkVideoEncodeInfoKHR* __pEncodeInfo_local = &pEncodeInfo)
                this.Invoke(commandBuffer, __pEncodeInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkCreateExecutionGraphPipelinesAMDX : IEquatable<vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX>, IvkFunctionPointer<vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX>
        {
            public PFN_vkCreateExecutionGraphPipelinesAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateExecutionGraphPipelinesAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCreateExecutionGraphPipelinesAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> (vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX(from);
            
            public static bool operator ==(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCreateExecutionGraphPipelinesAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX> Prototype => new("vkCreateExecutionGraphPipelinesAMDX"u8);
            
            /// <summary>
            /// Creates a new execution graph pipeline object
            /// </summary>
            /// <param name="device">The logical device that creates the execution graph pipelines.</param>
            /// <param name="pipelineCache">Either dlink:VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. This parameter is optional.</param>
            /// <param name="createInfoCount">The length of the <paramref name="pCreateInfos"/> and <paramref name="pPipelines"/> arrays.</param>
            /// <param name="pCreateInfos">A pointer to an array of <see cref="T:VkExecutionGraphPipelineCreateInfoAMDX"/> structures.</param>
            /// <param name="pAllocator">Controls host memory allocation as described in the Memory Allocation chapter. This parameter is optional.</param>
            /// <param name="pPipelines">A pointer to an array of <see cref="T:VkPipeline"/> handles in which the resulting execution graph pipeline objects are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_PIPELINE_COMPILE_REQUIRED_EXT</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipelineCache pipelineCache, uint createInfoCount, vulkan.VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, vulkan.VkAllocationCallbacks* pAllocator, vulkan.VkPipeline* pPipelines)
            {
                return Value(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Creates a new execution graph pipeline object
            /// </summary>
            /// <param name="device">The logical device that creates the execution graph pipelines.</param>
            /// <param name="pipelineCache">Either dlink:VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. This parameter is optional.</param>
            /// <param name="createInfoCount">The length of the <paramref name="pCreateInfos"/> and <paramref name="pPipelines"/> arrays.</param>
            /// <param name="pCreateInfos">A pointer to an array of <see cref="T:VkExecutionGraphPipelineCreateInfoAMDX"/> structures.</param>
            /// <param name="pAllocator">Controls host memory allocation as described in the Memory Allocation chapter. This parameter is optional.</param>
            /// <param name="pPipelines">A pointer to an array of <see cref="T:VkPipeline"/> handles in which the resulting execution graph pipeline objects are returned.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item><item><description><c>VK_PIPELINE_COMPILE_REQUIRED_EXT</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item><item><description><c>VK_ERROR_OUT_OF_DEVICE_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipelineCache pipelineCache, ReadOnlySpan<vulkan.VkExecutionGraphPipelineCreateInfoAMDX> pCreateInfos, vulkan.VkAllocationCallbacks* pAllocator, Span<vulkan.VkPipeline> pPipelines)
            {
                uint __createInfoCount_local = checked((uint)pCreateInfos.Length);
                fixed (vulkan.VkExecutionGraphPipelineCreateInfoAMDX* __pCreateInfos_local = pCreateInfos)
                fixed (vulkan.VkPipeline* __pPipelines_local = pPipelines)
                return this.Invoke(device, pipelineCache, __createInfoCount_local, __pCreateInfos_local, pAllocator, __pPipelines_local);
            }
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineScratchSizeAMDX : IEquatable<vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>, IvkFunctionPointer<vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetExecutionGraphPipelineScratchSizeAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX> Prototype => new("vkGetExecutionGraphPipelineScratchSizeAMDX"u8);
            
            /// <summary>
            /// Query scratch space required to dispatch an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the scratch space for.</param>
            /// <param name="pSizeInfo">A pointer to a <see cref="T:VkExecutionGraphPipelineScratchSizeAMDX"/> structure that will contain the required scratch size.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, vulkan.VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo)
            {
                return Value(device, executionGraph, pSizeInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query scratch space required to dispatch an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the scratch space for.</param>
            /// <param name="pSizeInfo">A pointer to a <see cref="T:VkExecutionGraphPipelineScratchSizeAMDX"/> structure that will contain the required scratch size.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, ref vulkan.VkExecutionGraphPipelineScratchSizeAMDX pSizeInfo)
            {
                fixed (vulkan.VkExecutionGraphPipelineScratchSizeAMDX* __pSizeInfo_local = &pSizeInfo)
                return this.Invoke(device, executionGraph, __pSizeInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineNodeIndexAMDX : IEquatable<vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>, IvkFunctionPointer<vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkGetExecutionGraphPipelineNodeIndexAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX> Prototype => new("vkGetExecutionGraphPipelineNodeIndexAMDX"u8);
            
            /// <summary>
            /// Query internal id of a node in an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the internal node index for.</param>
            /// <param name="pNodeInfo">A pointer to a <see cref="T:VkPipelineShaderStageNodeCreateInfoAMDX"/> structure identifying the name and index of the node to query.</param>
            /// <param name="pNodeIndex">The returned internal node index of the identified node.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint* pNodeIndex)
            {
                return Value(device, executionGraph, pNodeInfo, pNodeIndex);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Query internal id of a node in an execution graph
            /// </summary>
            /// <param name="device">The that <paramref name="executionGraph"/> was created on.</param>
            /// <param name="executionGraph">The execution graph pipeline to query the internal node index for.</param>
            /// <param name="pNodeInfo">A pointer to a <see cref="T:VkPipelineShaderStageNodeCreateInfoAMDX"/> structure identifying the name and index of the node to query.</param>
            /// <param name="pNodeIndex">The returned internal node index of the identified node.</param>
            /// <remarks>
            /// <list type="bullet">
            /// <listheader><description>On success, this command returns: </description></listheader><item><description><c>VK_SUCCESS</c></description></item>
            /// </list>
            /// <list type="bullet">
            /// <listheader><description>On failure, this command returns: </description></listheader><item><description><c>VK_ERROR_OUT_OF_HOST_MEMORY</c></description></item>
            /// </list>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public vulkan.VkResult Invoke(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, in vulkan.VkPipelineShaderStageNodeCreateInfoAMDX pNodeInfo, out uint pNodeIndex)
            {
                fixed (vulkan.VkPipelineShaderStageNodeCreateInfoAMDX* __pNodeInfo_local = &pNodeInfo)
                fixed (uint* __pNodeIndex_local = &pNodeIndex)
                return this.Invoke(device, executionGraph, __pNodeInfo_local, __pNodeIndex_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdInitializeGraphScratchMemoryAMDX : IEquatable<vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX>, IvkFunctionPointer<vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX>
        {
            public PFN_vkCmdInitializeGraphScratchMemoryAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdInitializeGraphScratchMemoryAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdInitializeGraphScratchMemoryAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX(from);
            
            public static bool operator ==(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdInitializeGraphScratchMemoryAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX> Prototype => new("vkCmdInitializeGraphScratchMemoryAMDX"u8);
            
            /// <summary>
            /// Initialize scratch memory for an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be initialized.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch)
            {
                Value(commandBuffer, scratch);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphAMDX>, IvkFunctionPointer<vulkan.PFN_vkCmdDispatchGraphAMDX>
        {
            public PFN_vkCmdDispatchGraphAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCmdDispatchGraphAMDX> Prototype => new("vkCmdDispatchGraphAMDX"u8);
            
            /// <summary>
            /// Dispatch an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDispatchGraphCountInfoAMDX* pCountInfo)
            {
                Value(commandBuffer, scratch, pCountInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Dispatch an execution graph
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo)
            {
                fixed (vulkan.VkDispatchGraphCountInfoAMDX* __pCountInfo_local = &pCountInfo)
                this.Invoke(commandBuffer, scratch, __pCountInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphIndirectAMDX>, IvkFunctionPointer<vulkan.PFN_vkCmdDispatchGraphIndirectAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphIndirectAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphIndirectAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCmdDispatchGraphIndirectAMDX> Prototype => new("vkCmdDispatchGraphIndirectAMDX"u8);
            
            /// <summary>
            /// Dispatch an execution graph with node and payload parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDispatchGraphCountInfoAMDX* pCountInfo)
            {
                Value(commandBuffer, scratch, pCountInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
            
            /// <summary>
            /// Dispatch an execution graph with node and payload parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="pCountInfo">A host pointer to a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo)
            {
                fixed (vulkan.VkDispatchGraphCountInfoAMDX* __pCountInfo_local = &pCountInfo)
                this.Invoke(commandBuffer, scratch, __pCountInfo_local);
            }
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectCountAMDX : IEquatable<vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX>, IvkFunctionPointer<vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectCountAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectCountAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectCountAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => !left.Equals(right);
            
            /// <summary>
            /// Gets the prototype of the function `vkCmdDispatchGraphIndirectCountAMDX`.
            /// </summary>
            public static vkFunctionPointerPrototype<vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX> Prototype => new("vkCmdDispatchGraphIndirectCountAMDX"u8);
            
            /// <summary>
            /// Dispatch an execution graph with all parameters read on the device
            /// </summary>
            /// <param name="commandBuffer">The command buffer into which the command will be recorded.</param>
            /// <param name="scratch">A pointer to the scratch memory to be used.</param>
            /// <param name="countInfo">A device address of a <see cref="T:VkDispatchGraphCountInfoAMDX"/> structure defining the nodes which will be initially executed.</param>
            /// <remarks>
            /// <para>Extension: VK_AMDX_shader_enqueue</para>
            /// </remarks>
            public void Invoke(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDeviceAddress countInfo)
            {
                Value(commandBuffer, scratch, countInfo);
            }
            
            public nint Pointer => (nint)Value;
            
            public bool IsNull => (nint)Value == 0;
        }
        
        public const int VK_KHR_portability_subset = 1;
        
        public const int VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1;
        
        public static ReadOnlyMemoryUtf8 VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME => "VK_KHR_portability_subset"u8;
        
        public const int VK_KHR_video_encode_queue = 1;
        
        public const int VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 9;
        
        public static ReadOnlyMemoryUtf8 VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME => "VK_KHR_video_encode_queue"u8;
        
        public const int VK_EXT_video_encode_h264 = 1;
        
        public const int VK_EXT_VIDEO_ENCODE_H264_SPEC_VERSION = 11;
        
        public static ReadOnlyMemoryUtf8 VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME => "VK_EXT_video_encode_h264"u8;
        
        public const int VK_EXT_video_encode_h265 = 1;
        
        public const int VK_EXT_VIDEO_ENCODE_H265_SPEC_VERSION = 11;
        
        public static ReadOnlyMemoryUtf8 VK_EXT_VIDEO_ENCODE_H265_EXTENSION_NAME => "VK_EXT_video_encode_h265"u8;
        
        public const int VK_AMDX_shader_enqueue = 1;
        
        public const int VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION = 1;
        
        public static ReadOnlyMemoryUtf8 VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME => "VK_AMDX_shader_enqueue"u8;
        
        public const uint VK_SHADER_INDEX_UNUSED_AMDX = 4294967295;
        
        public const int VK_NV_displacement_micromap = 1;
        
        public const int VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION = 2;
        
        public static ReadOnlyMemoryUtf8 VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME => "VK_NV_displacement_micromap"u8;
    }
}
