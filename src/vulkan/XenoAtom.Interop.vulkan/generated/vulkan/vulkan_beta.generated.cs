//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class vulkan
    {
        public enum VkVideoEncodeTuningModeKHR : uint
        {
            VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = unchecked((uint)0),
            
            VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = unchecked((uint)3),
            
            VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR;
        
        public const vulkan.VkVideoEncodeTuningModeKHR VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = VkVideoEncodeTuningModeKHR.VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeCapabilityFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeCapabilityFlagBitsKHR VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = VkVideoEncodeCapabilityFlagBitsKHR.VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR;
        
        public const vulkan.VkVideoEncodeCapabilityFlagBitsKHR VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeCapabilityFlagBitsKHR.VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeRateControlModeFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = unchecked((uint)0),
            
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR;
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR;
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR;
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR;
        
        public const vulkan.VkVideoEncodeRateControlModeFlagBitsKHR VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeRateControlModeFlagBitsKHR.VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeFeedbackFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR;
        
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR;
        
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR;
        
        public const vulkan.VkVideoEncodeFeedbackFlagBitsKHR VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeFeedbackFlagBitsKHR.VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeUsageFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = unchecked((uint)0),
            
            VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR;
        
        public const vulkan.VkVideoEncodeUsageFlagBitsKHR VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeUsageFlagBitsKHR.VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeContentFlagBitsKHR : uint
        {
            VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = unchecked((uint)0),
            
            VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR;
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR;
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR;
        
        public const vulkan.VkVideoEncodeContentFlagBitsKHR VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = VkVideoEncodeContentFlagBitsKHR.VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR;
        
        public enum VkVideoEncodeH264CapabilityFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH264StdFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = unchecked((uint)1024),
            
            VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = unchecked((uint)2048),
            
            VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = unchecked((uint)4096),
            
            VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = unchecked((uint)8192),
            
            VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = unchecked((uint)16384),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = unchecked((uint)32768),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = unchecked((uint)65536),
            
            VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = unchecked((uint)131072),
            
            VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264StdFlagBitsEXT VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264StdFlagBitsEXT.VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH264RateControlFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH264RateControlFlagBitsEXT VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH264RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH265CapabilityFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CapabilityFlagBitsEXT VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265CapabilityFlagBitsEXT.VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH265StdFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = unchecked((uint)32),
            
            VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = unchecked((uint)64),
            
            VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = unchecked((uint)128),
            
            VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = unchecked((uint)256),
            
            VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)512),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)1024),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = unchecked((uint)2048),
            
            VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = unchecked((uint)4096),
            
            VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)8192),
            
            VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = unchecked((uint)16384),
            
            VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)32768),
            
            VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)65536),
            
            VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = unchecked((uint)131072),
            
            VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = unchecked((uint)262144),
            
            VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265StdFlagBitsEXT VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265StdFlagBitsEXT.VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH265CtbSizeFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265CtbSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265CtbSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH265TransformBlockSizeFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265TransformBlockSizeFlagBitsEXT VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265TransformBlockSizeFlagBitsEXT.VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkVideoEncodeH265RateControlFlagBitsEXT : uint
        {
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = unchecked((uint)1),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = unchecked((uint)2),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = unchecked((uint)4),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = unchecked((uint)8),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = unchecked((uint)16),
            
            VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT;
        
        public const vulkan.VkVideoEncodeH265RateControlFlagBitsEXT VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT = VkVideoEncodeH265RateControlFlagBitsEXT.VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_EXT;
        
        public enum VkDisplacementMicromapFormatNV : uint
        {
            VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = unchecked((uint)1),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = unchecked((uint)2),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = unchecked((uint)3),
            
            VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = unchecked((uint)2147483647),
        }
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV;
        
        public const vulkan.VkDisplacementMicromapFormatNV VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = VkDisplacementMicromapFormatNV.VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV;
        
        public partial struct VkPhysicalDevicePortabilitySubsetFeaturesKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 constantAlphaColorBlendFactors;
            
            public vulkan.VkBool32 events;
            
            public vulkan.VkBool32 imageViewFormatReinterpretation;
            
            public vulkan.VkBool32 imageViewFormatSwizzle;
            
            public vulkan.VkBool32 imageView2DOn3DImage;
            
            public vulkan.VkBool32 multisampleArrayImage;
            
            public vulkan.VkBool32 mutableComparisonSamplers;
            
            public vulkan.VkBool32 pointPolygons;
            
            public vulkan.VkBool32 samplerMipLodBias;
            
            public vulkan.VkBool32 separateStencilMaskRef;
            
            public vulkan.VkBool32 shaderSampleRateInterpolationFunctions;
            
            public vulkan.VkBool32 tessellationIsolines;
            
            public vulkan.VkBool32 tessellationPointMode;
            
            public vulkan.VkBool32 triangleFans;
            
            public vulkan.VkBool32 vertexAttributeAccessBeyondStride;
        }
        
        public partial struct VkPhysicalDevicePortabilitySubsetPropertiesKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint minVertexInputBindingStrideAlignment;
        }
        
        public partial struct VkVideoEncodeInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeFlagsKHR flags;
            
            public vulkan.VkBuffer dstBuffer;
            
            public vulkan.VkDeviceSize dstBufferOffset;
            
            public vulkan.VkDeviceSize dstBufferRange;
            
            public vulkan.VkVideoPictureResourceInfoKHR srcPictureResource;
            
            public vulkan.VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
            
            public uint referenceSlotCount;
            
            public vulkan.VkVideoReferenceSlotInfoKHR* pReferenceSlots;
            
            public uint precedingExternallyEncodedBytes;
        }
        
        public readonly partial struct VkVideoEncodeFlagsKHR : IEquatable<VkVideoEncodeFlagsKHR>
        {
            public VkVideoEncodeFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeFlagsKHR left, VkVideoEncodeFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeFlagsKHR left, VkVideoEncodeFlagsKHR right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeCapabilitiesKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeCapabilityFlagsKHR flags;
            
            public vulkan.VkVideoEncodeRateControlModeFlagsKHR rateControlModes;
            
            public uint maxRateControlLayers;
            
            public ulong maxBitrate;
            
            public uint maxQualityLevels;
            
            public vulkan.VkExtent2D encodeInputPictureGranularity;
            
            public vulkan.VkVideoEncodeFeedbackFlagsKHR supportedEncodeFeedbackFlags;
        }
        
        public readonly partial struct VkVideoEncodeCapabilityFlagsKHR : IEquatable<VkVideoEncodeCapabilityFlagsKHR>
        {
            public VkVideoEncodeCapabilityFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeCapabilityFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeCapabilityFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeCapabilityFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeCapabilityFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeCapabilityFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeCapabilityFlagsKHR left, VkVideoEncodeCapabilityFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeCapabilityFlagsKHR left, VkVideoEncodeCapabilityFlagsKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeRateControlModeFlagsKHR : IEquatable<VkVideoEncodeRateControlModeFlagsKHR>
        {
            public VkVideoEncodeRateControlModeFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeRateControlModeFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeRateControlModeFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeRateControlModeFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeRateControlModeFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeRateControlModeFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeRateControlModeFlagsKHR left, VkVideoEncodeRateControlModeFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeRateControlModeFlagsKHR left, VkVideoEncodeRateControlModeFlagsKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeFeedbackFlagsKHR : IEquatable<VkVideoEncodeFeedbackFlagsKHR>
        {
            public VkVideoEncodeFeedbackFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeFeedbackFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeFeedbackFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeFeedbackFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeFeedbackFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeFeedbackFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeFeedbackFlagsKHR left, VkVideoEncodeFeedbackFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeFeedbackFlagsKHR left, VkVideoEncodeFeedbackFlagsKHR right) => !left.Equals(right);
        }
        
        public partial struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags;
        }
        
        public partial struct VkVideoEncodeUsageInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeUsageFlagsKHR videoUsageHints;
            
            public vulkan.VkVideoEncodeContentFlagsKHR videoContentHints;
            
            public vulkan.VkVideoEncodeTuningModeKHR tuningMode;
        }
        
        public readonly partial struct VkVideoEncodeUsageFlagsKHR : IEquatable<VkVideoEncodeUsageFlagsKHR>
        {
            public VkVideoEncodeUsageFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeUsageFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeUsageFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeUsageFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeUsageFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeUsageFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeUsageFlagsKHR left, VkVideoEncodeUsageFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeUsageFlagsKHR left, VkVideoEncodeUsageFlagsKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeContentFlagsKHR : IEquatable<VkVideoEncodeContentFlagsKHR>
        {
            public VkVideoEncodeContentFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeContentFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeContentFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeContentFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeContentFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeContentFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeContentFlagsKHR left, VkVideoEncodeContentFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeContentFlagsKHR left, VkVideoEncodeContentFlagsKHR right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeRateControlLayerInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public ulong averageBitrate;
            
            public ulong maxBitrate;
            
            public uint frameRateNumerator;
            
            public uint frameRateDenominator;
        }
        
        public partial struct VkVideoEncodeRateControlInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeRateControlFlagsKHR flags;
            
            public vulkan.VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
            
            public uint layerCount;
            
            public vulkan.VkVideoEncodeRateControlLayerInfoKHR* pLayers;
            
            public uint virtualBufferSizeInMs;
            
            public uint initialVirtualBufferSizeInMs;
        }
        
        public readonly partial struct VkVideoEncodeRateControlFlagsKHR : IEquatable<VkVideoEncodeRateControlFlagsKHR>
        {
            public VkVideoEncodeRateControlFlagsKHR(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeRateControlFlagsKHR other && Equals(other);
            
            public bool Equals(VkVideoEncodeRateControlFlagsKHR other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeRateControlFlagsKHR from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeRateControlFlagsKHR (vulkan.VkFlags from) => new vulkan.VkVideoEncodeRateControlFlagsKHR(from);
            
            public static bool operator ==(VkVideoEncodeRateControlFlagsKHR left, VkVideoEncodeRateControlFlagsKHR right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeRateControlFlagsKHR left, VkVideoEncodeRateControlFlagsKHR right) => !left.Equals(right);
        }
        
        public partial struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoProfileInfoKHR* pVideoProfile;
            
            public uint qualityLevel;
        }
        
        public partial struct VkVideoEncodeQualityLevelPropertiesKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeRateControlModeFlagBitsKHR preferredRateControlMode;
            
            public uint preferredRateControlLayerCount;
        }
        
        public partial struct VkVideoEncodeQualityLevelInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint qualityLevel;
        }
        
        public partial struct VkVideoEncodeSessionParametersGetInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoSessionParametersKHR videoSessionParameters;
        }
        
        public partial struct VkVideoEncodeSessionParametersFeedbackInfoKHR
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 hasOverrides;
        }
        
        public partial struct VkVideoEncodeH264CapabilitiesEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH264CapabilityFlagsEXT flags;
            
            public vulkan.StdVideoH264LevelIdc maxLevelIdc;
            
            public uint maxSliceCount;
            
            public uint maxPPictureL0ReferenceCount;
            
            public uint maxBPictureL0ReferenceCount;
            
            public uint maxL1ReferenceCount;
            
            public uint maxTemporalLayerCount;
            
            public vulkan.VkBool32 expectDyadicTemporalLayerPattern;
            
            public int minQp;
            
            public int maxQp;
            
            public vulkan.VkBool32 prefersGopRemainingFrames;
            
            public vulkan.VkBool32 requiresGopRemainingFrames;
            
            public vulkan.VkVideoEncodeH264StdFlagsEXT stdSyntaxFlags;
        }
        
        public readonly partial struct VkVideoEncodeH264CapabilityFlagsEXT : IEquatable<VkVideoEncodeH264CapabilityFlagsEXT>
        {
            public VkVideoEncodeH264CapabilityFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264CapabilityFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264CapabilityFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264CapabilityFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264CapabilityFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264CapabilityFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264CapabilityFlagsEXT left, VkVideoEncodeH264CapabilityFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264CapabilityFlagsEXT left, VkVideoEncodeH264CapabilityFlagsEXT right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeH264StdFlagsEXT : IEquatable<VkVideoEncodeH264StdFlagsEXT>
        {
            public VkVideoEncodeH264StdFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264StdFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264StdFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264StdFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264StdFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264StdFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264StdFlagsEXT left, VkVideoEncodeH264StdFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264StdFlagsEXT left, VkVideoEncodeH264StdFlagsEXT right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeH264QpEXT
        {
            public int qpI;
            
            public int qpP;
            
            public int qpB;
        }
        
        public partial struct VkVideoEncodeH264QualityLevelPropertiesEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH264RateControlFlagsEXT preferredRateControlFlags;
            
            public uint preferredGopFrameCount;
            
            public uint preferredIdrPeriod;
            
            public uint preferredConsecutiveBFrameCount;
            
            public uint preferredTemporalLayerCount;
            
            public vulkan.VkVideoEncodeH264QpEXT preferredConstantQp;
            
            public uint preferredMaxL0ReferenceCount;
            
            public uint preferredMaxL1ReferenceCount;
            
            public vulkan.VkBool32 preferredStdEntropyCodingModeFlag;
        }
        
        public readonly partial struct VkVideoEncodeH264RateControlFlagsEXT : IEquatable<VkVideoEncodeH264RateControlFlagsEXT>
        {
            public VkVideoEncodeH264RateControlFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH264RateControlFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH264RateControlFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH264RateControlFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH264RateControlFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH264RateControlFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH264RateControlFlagsEXT left, VkVideoEncodeH264RateControlFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH264RateControlFlagsEXT left, VkVideoEncodeH264RateControlFlagsEXT right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeH264SessionCreateInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useMaxLevelIdc;
            
            public vulkan.StdVideoH264LevelIdc maxLevelIdc;
        }
        
        public partial struct VkVideoEncodeH264SessionParametersAddInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint stdSPSCount;
            
            public vulkan.StdVideoH264SequenceParameterSet* pStdSPSs;
            
            public uint stdPPSCount;
            
            public vulkan.StdVideoH264PictureParameterSet* pStdPPSs;
        }
        
        public partial struct VkVideoEncodeH264SessionParametersCreateInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint maxStdSPSCount;
            
            public uint maxStdPPSCount;
            
            public vulkan.VkVideoEncodeH264SessionParametersAddInfoEXT* pParametersAddInfo;
        }
        
        public partial struct VkVideoEncodeH264SessionParametersGetInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 writeStdSPS;
            
            public vulkan.VkBool32 writeStdPPS;
            
            public uint stdSPSId;
            
            public uint stdPPSId;
        }
        
        public partial struct VkVideoEncodeH264SessionParametersFeedbackInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 hasStdSPSOverrides;
            
            public vulkan.VkBool32 hasStdPPSOverrides;
        }
        
        public partial struct VkVideoEncodeH264NaluSliceInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public int constantQp;
            
            public vulkan.StdVideoEncodeH264SliceHeader* pStdSliceHeader;
        }
        
        public partial struct VkVideoEncodeH264PictureInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint naluSliceEntryCount;
            
            public vulkan.VkVideoEncodeH264NaluSliceInfoEXT* pNaluSliceEntries;
            
            public vulkan.StdVideoEncodeH264PictureInfo* pStdPictureInfo;
            
            public vulkan.VkBool32 generatePrefixNalu;
        }
        
        public partial struct VkVideoEncodeH264DpbSlotInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo;
        }
        
        public partial struct VkVideoEncodeH264ProfileInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.StdVideoH264ProfileIdc stdProfileIdc;
        }
        
        public partial struct VkVideoEncodeH264RateControlInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH264RateControlFlagsEXT flags;
            
            public uint gopFrameCount;
            
            public uint idrPeriod;
            
            public uint consecutiveBFrameCount;
            
            public uint temporalLayerCount;
        }
        
        public partial struct VkVideoEncodeH264FrameSizeEXT
        {
            public uint frameISize;
            
            public uint framePSize;
            
            public uint frameBSize;
        }
        
        public partial struct VkVideoEncodeH264RateControlLayerInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useMinQp;
            
            public vulkan.VkVideoEncodeH264QpEXT minQp;
            
            public vulkan.VkBool32 useMaxQp;
            
            public vulkan.VkVideoEncodeH264QpEXT maxQp;
            
            public vulkan.VkBool32 useMaxFrameSize;
            
            public vulkan.VkVideoEncodeH264FrameSizeEXT maxFrameSize;
        }
        
        public partial struct VkVideoEncodeH264GopRemainingFrameInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useGopRemainingFrames;
            
            public uint gopRemainingI;
            
            public uint gopRemainingP;
            
            public uint gopRemainingB;
        }
        
        public partial struct VkVideoEncodeH265CapabilitiesEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH265CapabilityFlagsEXT flags;
            
            public vulkan.StdVideoH265LevelIdc maxLevelIdc;
            
            public uint maxSliceSegmentCount;
            
            public vulkan.VkExtent2D maxTiles;
            
            public vulkan.VkVideoEncodeH265CtbSizeFlagsEXT ctbSizes;
            
            public vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT transformBlockSizes;
            
            public uint maxPPictureL0ReferenceCount;
            
            public uint maxBPictureL0ReferenceCount;
            
            public uint maxL1ReferenceCount;
            
            public uint maxSubLayerCount;
            
            public vulkan.VkBool32 expectDyadicTemporalSubLayerPattern;
            
            public int minQp;
            
            public int maxQp;
            
            public vulkan.VkBool32 prefersGopRemainingFrames;
            
            public vulkan.VkBool32 requiresGopRemainingFrames;
            
            public vulkan.VkVideoEncodeH265StdFlagsEXT stdSyntaxFlags;
        }
        
        public readonly partial struct VkVideoEncodeH265CapabilityFlagsEXT : IEquatable<VkVideoEncodeH265CapabilityFlagsEXT>
        {
            public VkVideoEncodeH265CapabilityFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265CapabilityFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265CapabilityFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265CapabilityFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CapabilityFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265CapabilityFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265CapabilityFlagsEXT left, VkVideoEncodeH265CapabilityFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265CapabilityFlagsEXT left, VkVideoEncodeH265CapabilityFlagsEXT right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeH265CtbSizeFlagsEXT : IEquatable<VkVideoEncodeH265CtbSizeFlagsEXT>
        {
            public VkVideoEncodeH265CtbSizeFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265CtbSizeFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265CtbSizeFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265CtbSizeFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265CtbSizeFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265CtbSizeFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265CtbSizeFlagsEXT left, VkVideoEncodeH265CtbSizeFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265CtbSizeFlagsEXT left, VkVideoEncodeH265CtbSizeFlagsEXT right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeH265TransformBlockSizeFlagsEXT : IEquatable<VkVideoEncodeH265TransformBlockSizeFlagsEXT>
        {
            public VkVideoEncodeH265TransformBlockSizeFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265TransformBlockSizeFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265TransformBlockSizeFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265TransformBlockSizeFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265TransformBlockSizeFlagsEXT left, VkVideoEncodeH265TransformBlockSizeFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265TransformBlockSizeFlagsEXT left, VkVideoEncodeH265TransformBlockSizeFlagsEXT right) => !left.Equals(right);
        }
        
        public readonly partial struct VkVideoEncodeH265StdFlagsEXT : IEquatable<VkVideoEncodeH265StdFlagsEXT>
        {
            public VkVideoEncodeH265StdFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265StdFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265StdFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265StdFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265StdFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265StdFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265StdFlagsEXT left, VkVideoEncodeH265StdFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265StdFlagsEXT left, VkVideoEncodeH265StdFlagsEXT right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeH265SessionCreateInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useMaxLevelIdc;
            
            public vulkan.StdVideoH265LevelIdc maxLevelIdc;
        }
        
        public partial struct VkVideoEncodeH265QpEXT
        {
            public int qpI;
            
            public int qpP;
            
            public int qpB;
        }
        
        public partial struct VkVideoEncodeH265QualityLevelPropertiesEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH265RateControlFlagsEXT preferredRateControlFlags;
            
            public uint preferredGopFrameCount;
            
            public uint preferredIdrPeriod;
            
            public uint preferredConsecutiveBFrameCount;
            
            public uint preferredSubLayerCount;
            
            public vulkan.VkVideoEncodeH265QpEXT preferredConstantQp;
            
            public uint preferredMaxL0ReferenceCount;
            
            public uint preferredMaxL1ReferenceCount;
        }
        
        public readonly partial struct VkVideoEncodeH265RateControlFlagsEXT : IEquatable<VkVideoEncodeH265RateControlFlagsEXT>
        {
            public VkVideoEncodeH265RateControlFlagsEXT(vulkan.VkFlags value) => this.Value = value;
            
            public vulkan.VkFlags Value { get; }
            
            public override bool Equals(object obj) => obj is VkVideoEncodeH265RateControlFlagsEXT other && Equals(other);
            
            public bool Equals(VkVideoEncodeH265RateControlFlagsEXT other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator vulkan.VkFlags (vulkan.VkVideoEncodeH265RateControlFlagsEXT from) => from.Value;
            
            public static implicit operator vulkan.VkVideoEncodeH265RateControlFlagsEXT (vulkan.VkFlags from) => new vulkan.VkVideoEncodeH265RateControlFlagsEXT(from);
            
            public static bool operator ==(VkVideoEncodeH265RateControlFlagsEXT left, VkVideoEncodeH265RateControlFlagsEXT right) => left.Equals(right);
            
            public static bool operator !=(VkVideoEncodeH265RateControlFlagsEXT left, VkVideoEncodeH265RateControlFlagsEXT right) => !left.Equals(right);
        }
        
        public partial struct VkVideoEncodeH265SessionParametersAddInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint stdVPSCount;
            
            public vulkan.StdVideoH265VideoParameterSet* pStdVPSs;
            
            public uint stdSPSCount;
            
            public vulkan.StdVideoH265SequenceParameterSet* pStdSPSs;
            
            public uint stdPPSCount;
            
            public vulkan.StdVideoH265PictureParameterSet* pStdPPSs;
        }
        
        public partial struct VkVideoEncodeH265SessionParametersCreateInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint maxStdVPSCount;
            
            public uint maxStdSPSCount;
            
            public uint maxStdPPSCount;
            
            public vulkan.VkVideoEncodeH265SessionParametersAddInfoEXT* pParametersAddInfo;
        }
        
        public partial struct VkVideoEncodeH265SessionParametersGetInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 writeStdVPS;
            
            public vulkan.VkBool32 writeStdSPS;
            
            public vulkan.VkBool32 writeStdPPS;
            
            public uint stdVPSId;
            
            public uint stdSPSId;
            
            public uint stdPPSId;
        }
        
        public partial struct VkVideoEncodeH265SessionParametersFeedbackInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 hasStdVPSOverrides;
            
            public vulkan.VkBool32 hasStdSPSOverrides;
            
            public vulkan.VkBool32 hasStdPPSOverrides;
        }
        
        public partial struct VkVideoEncodeH265NaluSliceSegmentInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public int constantQp;
            
            public vulkan.StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader;
        }
        
        public partial struct VkVideoEncodeH265PictureInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint naluSliceSegmentEntryCount;
            
            public vulkan.VkVideoEncodeH265NaluSliceSegmentInfoEXT* pNaluSliceSegmentEntries;
            
            public vulkan.StdVideoEncodeH265PictureInfo* pStdPictureInfo;
        }
        
        public partial struct VkVideoEncodeH265DpbSlotInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo;
        }
        
        public partial struct VkVideoEncodeH265ProfileInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.StdVideoH265ProfileIdc stdProfileIdc;
        }
        
        public partial struct VkVideoEncodeH265RateControlInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkVideoEncodeH265RateControlFlagsEXT flags;
            
            public uint gopFrameCount;
            
            public uint idrPeriod;
            
            public uint consecutiveBFrameCount;
            
            public uint subLayerCount;
        }
        
        public partial struct VkVideoEncodeH265FrameSizeEXT
        {
            public uint frameISize;
            
            public uint framePSize;
            
            public uint frameBSize;
        }
        
        public partial struct VkVideoEncodeH265RateControlLayerInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useMinQp;
            
            public vulkan.VkVideoEncodeH265QpEXT minQp;
            
            public vulkan.VkBool32 useMaxQp;
            
            public vulkan.VkVideoEncodeH265QpEXT maxQp;
            
            public vulkan.VkBool32 useMaxFrameSize;
            
            public vulkan.VkVideoEncodeH265FrameSizeEXT maxFrameSize;
        }
        
        public partial struct VkVideoEncodeH265GopRemainingFrameInfoEXT
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 useGopRemainingFrames;
            
            public uint gopRemainingI;
            
            public uint gopRemainingP;
            
            public uint gopRemainingB;
        }
        
        public partial struct VkPhysicalDeviceShaderEnqueueFeaturesAMDX
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 shaderEnqueue;
        }
        
        public partial struct VkPhysicalDeviceShaderEnqueuePropertiesAMDX
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint maxExecutionGraphDepth;
            
            public uint maxExecutionGraphShaderOutputNodes;
            
            public uint maxExecutionGraphShaderPayloadSize;
            
            public uint maxExecutionGraphShaderPayloadCount;
            
            public uint executionGraphDispatchAddressAlignment;
        }
        
        public partial struct VkExecutionGraphPipelineScratchSizeAMDX
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkDeviceSize size;
        }
        
        public partial struct VkExecutionGraphPipelineCreateInfoAMDX
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkPipelineCreateFlags flags;
            
            public uint stageCount;
            
            public vulkan.VkPipelineShaderStageCreateInfo* pStages;
            
            public vulkan.VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
            
            public vulkan.VkPipelineLayout layout;
            
            public vulkan.VkPipeline basePipelineHandle;
            
            public int basePipelineIndex;
        }
        
        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
        public partial struct VkDeviceOrHostAddressConstAMDX
        {
            [FieldOffset(0)]
            public vulkan.VkDeviceAddress deviceAddress;
            
            [FieldOffset(0)]
            public void* hostAddress;
        }
        
        public partial struct VkDispatchGraphInfoAMDX
        {
            public uint nodeIndex;
            
            public uint payloadCount;
            
            public vulkan.VkDeviceOrHostAddressConstAMDX payloads;
            
            public ulong payloadStride;
        }
        
        public partial struct VkDispatchGraphCountInfoAMDX
        {
            public uint count;
            
            public vulkan.VkDeviceOrHostAddressConstAMDX infos;
            
            public ulong stride;
        }
        
        public partial struct VkPipelineShaderStageNodeCreateInfoAMDX
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public byte* pName;
            
            public uint index;
        }
        
        public partial struct VkPhysicalDeviceDisplacementMicromapFeaturesNV
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkBool32 displacementMicromap;
        }
        
        public partial struct VkPhysicalDeviceDisplacementMicromapPropertiesNV
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public uint maxDisplacementMicromapSubdivisionLevel;
        }
        
        public partial struct VkAccelerationStructureTrianglesDisplacementMicromapNV
        {
            public vulkan.VkStructureType sType;
            
            public void* pNext;
            
            public vulkan.VkFormat displacementBiasAndScaleFormat;
            
            public vulkan.VkFormat displacementVectorFormat;
            
            public vulkan.VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer;
            
            public vulkan.VkDeviceSize displacementBiasAndScaleStride;
            
            public vulkan.VkDeviceOrHostAddressConstKHR displacementVectorBuffer;
            
            public vulkan.VkDeviceSize displacementVectorStride;
            
            public vulkan.VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags;
            
            public vulkan.VkDeviceSize displacedMicromapPrimitiveFlagsStride;
            
            public vulkan.VkIndexType indexType;
            
            public vulkan.VkDeviceOrHostAddressConstKHR indexBuffer;
            
            public vulkan.VkDeviceSize indexStride;
            
            public uint baseTriangle;
            
            public uint usageCountsCount;
            
            public vulkan.VkMicromapUsageEXT* pUsageCounts;
            
            public vulkan.VkMicromapUsageEXT** ppUsageCounts;
            
            public vulkan.VkMicromapEXT micromap;
        }
        
        public readonly partial struct PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR : IEquatable<PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR>
        {
            public PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> (vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR (delegate*unmanaged[Stdcall]<vulkan.VkPhysicalDevice, vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*, vulkan.VkVideoEncodeQualityLevelPropertiesKHR*, vulkan.VkResult> from) => new vulkan.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(from);
            
            public static bool operator ==(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR left, PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR left, PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkGetEncodedVideoSessionParametersKHR : IEquatable<PFN_vkGetEncodedVideoSessionParametersKHR>
        {
            public PFN_vkGetEncodedVideoSessionParametersKHR(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetEncodedVideoSessionParametersKHR other && Equals(other);
            
            public bool Equals(PFN_vkGetEncodedVideoSessionParametersKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> (vulkan.PFN_vkGetEncodedVideoSessionParametersKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetEncodedVideoSessionParametersKHR (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkVideoEncodeSessionParametersGetInfoKHR*, vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR*, nuint*, void*, vulkan.VkResult> from) => new vulkan.PFN_vkGetEncodedVideoSessionParametersKHR(from);
            
            public static bool operator ==(PFN_vkGetEncodedVideoSessionParametersKHR left, PFN_vkGetEncodedVideoSessionParametersKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetEncodedVideoSessionParametersKHR left, PFN_vkGetEncodedVideoSessionParametersKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCmdEncodeVideoKHR : IEquatable<PFN_vkCmdEncodeVideoKHR>
        {
            public PFN_vkCmdEncodeVideoKHR(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdEncodeVideoKHR other && Equals(other);
            
            public bool Equals(PFN_vkCmdEncodeVideoKHR other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> (vulkan.PFN_vkCmdEncodeVideoKHR from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdEncodeVideoKHR (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkVideoEncodeInfoKHR*, void> from) => new vulkan.PFN_vkCmdEncodeVideoKHR(from);
            
            public static bool operator ==(PFN_vkCmdEncodeVideoKHR left, PFN_vkCmdEncodeVideoKHR right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdEncodeVideoKHR left, PFN_vkCmdEncodeVideoKHR right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCreateExecutionGraphPipelinesAMDX : IEquatable<PFN_vkCreateExecutionGraphPipelinesAMDX>
        {
            public PFN_vkCreateExecutionGraphPipelinesAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCreateExecutionGraphPipelinesAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCreateExecutionGraphPipelinesAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> (vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipelineCache, uint, vulkan.VkExecutionGraphPipelineCreateInfoAMDX*, vulkan.VkAllocationCallbacks*, vulkan.VkPipeline*, vulkan.VkResult> from) => new vulkan.PFN_vkCreateExecutionGraphPipelinesAMDX(from);
            
            public static bool operator ==(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCreateExecutionGraphPipelinesAMDX left, PFN_vkCreateExecutionGraphPipelinesAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineScratchSizeAMDX : IEquatable<PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkExecutionGraphPipelineScratchSizeAMDX*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineScratchSizeAMDX left, PFN_vkGetExecutionGraphPipelineScratchSizeAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkGetExecutionGraphPipelineNodeIndexAMDX : IEquatable<PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>
        {
            public PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other && Equals(other);
            
            public bool Equals(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> (vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX (delegate*unmanaged[Stdcall]<vulkan.VkDevice, vulkan.VkPipeline, vulkan.VkPipelineShaderStageNodeCreateInfoAMDX*, uint*, vulkan.VkResult> from) => new vulkan.PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(from);
            
            public static bool operator ==(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkGetExecutionGraphPipelineNodeIndexAMDX left, PFN_vkGetExecutionGraphPipelineNodeIndexAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCmdInitializeGraphScratchMemoryAMDX : IEquatable<PFN_vkCmdInitializeGraphScratchMemoryAMDX>
        {
            public PFN_vkCmdInitializeGraphScratchMemoryAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdInitializeGraphScratchMemoryAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdInitializeGraphScratchMemoryAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdInitializeGraphScratchMemoryAMDX(from);
            
            public static bool operator ==(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdInitializeGraphScratchMemoryAMDX left, PFN_vkCmdInitializeGraphScratchMemoryAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphAMDX : IEquatable<PFN_vkCmdDispatchGraphAMDX>
        {
            public PFN_vkCmdDispatchGraphAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphAMDX left, PFN_vkCmdDispatchGraphAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectAMDX : IEquatable<PFN_vkCmdDispatchGraphIndirectAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> (vulkan.PFN_vkCmdDispatchGraphIndirectAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDispatchGraphCountInfoAMDX*, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectAMDX left, PFN_vkCmdDispatchGraphIndirectAMDX right) => !left.Equals(right);
        }
        
        public readonly partial struct PFN_vkCmdDispatchGraphIndirectCountAMDX : IEquatable<PFN_vkCmdDispatchGraphIndirectCountAMDX>
        {
            public PFN_vkCmdDispatchGraphIndirectCountAMDX(delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> value) => this.Value = value;
            
            public delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> Value { get; }
            
            public override bool Equals(object obj) => obj is PFN_vkCmdDispatchGraphIndirectCountAMDX other && Equals(other);
            
            public bool Equals(PFN_vkCmdDispatchGraphIndirectCountAMDX other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> (vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX from) => from.Value;
            
            public static implicit operator vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX (delegate*unmanaged[Stdcall]<vulkan.VkCommandBuffer, vulkan.VkDeviceAddress, vulkan.VkDeviceAddress, void> from) => new vulkan.PFN_vkCmdDispatchGraphIndirectCountAMDX(from);
            
            public static bool operator ==(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => left.Equals(right);
            
            public static bool operator !=(PFN_vkCmdDispatchGraphIndirectCountAMDX left, PFN_vkCmdDispatchGraphIndirectCountAMDX right) => !left.Equals(right);
        }
        
        public const int VK_KHR_portability_subset = 1;
        
        public const int VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1;
        
        public const string VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME = "VK_KHR_portability_subset";
        
        public const int VK_KHR_video_encode_queue = 1;
        
        public const int VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 9;
        
        public const string VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue";
        
        public const int VK_EXT_video_encode_h264 = 1;
        
        public const int VK_EXT_VIDEO_ENCODE_H264_SPEC_VERSION = 11;
        
        public const string VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_EXT_video_encode_h264";
        
        public const int VK_EXT_video_encode_h265 = 1;
        
        public const int VK_EXT_VIDEO_ENCODE_H265_SPEC_VERSION = 11;
        
        public const string VK_EXT_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_EXT_video_encode_h265";
        
        public const int VK_AMDX_shader_enqueue = 1;
        
        public const int VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION = 1;
        
        public const string VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME = "VK_AMDX_shader_enqueue";
        
        public const uint VK_SHADER_INDEX_UNUSED_AMDX = 4294967295;
        
        public const int VK_NV_displacement_micromap = 1;
        
        public const int VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION = 2;
        
        public const string VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME = "VK_NV_displacement_micromap";
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(vulkan.VkPhysicalDevice physicalDevice, in vulkan.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR pQualityLevelInfo, ref vulkan.VkVideoEncodeQualityLevelPropertiesKHR pQualityLevelProperties);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetEncodedVideoSessionParametersKHR")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetEncodedVideoSessionParametersKHR(vulkan.VkDevice device, in vulkan.VkVideoEncodeSessionParametersGetInfoKHR pVideoSessionParametersInfo, ref vulkan.VkVideoEncodeSessionParametersFeedbackInfoKHR pFeedbackInfo, ref nuint pDataSize, void* pData);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCmdEncodeVideoKHR")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkCmdEncodeVideoKHR(vulkan.VkCommandBuffer commandBuffer, in vulkan.VkVideoEncodeInfoKHR pEncodeInfo);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCreateExecutionGraphPipelinesAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkCreateExecutionGraphPipelinesAMDX(vulkan.VkDevice device, vulkan.VkPipelineCache pipelineCache, uint createInfoCount, in vulkan.VkExecutionGraphPipelineCreateInfoAMDX pCreateInfos, in vulkan.VkAllocationCallbacks pAllocator, ref vulkan.VkPipeline pPipelines);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetExecutionGraphPipelineScratchSizeAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetExecutionGraphPipelineScratchSizeAMDX(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, ref vulkan.VkExecutionGraphPipelineScratchSizeAMDX pSizeInfo);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkGetExecutionGraphPipelineNodeIndexAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial vulkan.VkResult vkGetExecutionGraphPipelineNodeIndexAMDX(vulkan.VkDevice device, vulkan.VkPipeline executionGraph, in vulkan.VkPipelineShaderStageNodeCreateInfoAMDX pNodeInfo, ref uint pNodeIndex);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCmdInitializeGraphScratchMemoryAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkCmdInitializeGraphScratchMemoryAMDX(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCmdDispatchGraphAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkCmdDispatchGraphAMDX(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCmdDispatchGraphIndirectAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkCmdDispatchGraphIndirectAMDX(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, in vulkan.VkDispatchGraphCountInfoAMDX pCountInfo);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vkCmdDispatchGraphIndirectCountAMDX")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
        public static partial void vkCmdDispatchGraphIndirectCountAMDX(vulkan.VkCommandBuffer commandBuffer, vulkan.VkDeviceAddress scratch, vulkan.VkDeviceAddress countInfo);
    }
}
