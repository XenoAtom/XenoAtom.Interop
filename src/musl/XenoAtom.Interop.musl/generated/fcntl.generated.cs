//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct flock_t
        {
            public short l_type;
            
            public short l_whence;
            
            public musl.off_t l_start;
            
            public musl.off_t l_len;
            
            public musl.pid_t l_pid;
        }
        
        public unsafe partial struct file_handle
        {
            public uint handle_bytes;
            
            public int handle_type;
            
            public fixed byte f_handle[1];
        }
        
        public partial struct f_owner_ex
        {
            public int type;
            
            public musl.pid_t pid;
        }
        
        public const int O_SEARCH = 2097152;
        
        public const int O_EXEC = 2097152;
        
        public const int O_TTY_INIT = 0;
        
        public const int O_ACCMODE = 2097155;
        
        /// <summary>
        /// This value allows only read access.
        /// </summary>
        public const int O_RDONLY = 0;
        
        /// <summary>
        /// This value allows only write access.
        /// </summary>
        public const int O_WRONLY = 1;
        
        /// <summary>
        /// This value allows read and write access.
        /// 
        /// Additional bits can be set in
        /// event_f_flags .
        /// The most useful values are:
        /// </summary>
        public const int O_RDWR = 2;
        
        public const int F_OFD_GETLK = 36;
        
        public const int F_OFD_SETLK = 37;
        
        public const int F_OFD_SETLKW = 38;
        
        public const int F_DUPFD_CLOEXEC = 1030;
        
        public const int F_RDLCK = 0;
        
        public const int F_WRLCK = 1;
        
        public const int F_UNLCK = 2;
        
        public const int AT_FDCWD = -100;
        
        /// <summary>
        /// If
        /// pathname
        /// is a symbolic link, do not dereference it:
        /// instead return information about the link itself.
        /// 
        /// See
        /// openat (2)
        /// for an explanation of the need for
        /// faccessat ().
        /// </summary>
        public const int AT_SYMLINK_NOFOLLOW = 256;
        
        /// <summary>
        /// By default,
        /// unlinkat ()
        /// performs the equivalent of
        /// unlink ()
        /// on
        /// pathname .
        /// If the
        /// AT_REMOVEDIR
        /// flag is specified, it
        /// performs the equivalent of
        /// rmdir (2)
        /// on
        /// pathname .
        /// 
        /// See
        /// openat (2)
        /// for an explanation of the need for
        /// unlinkat ().
        /// </summary>
        public const int AT_REMOVEDIR = 512;
        
        public const int AT_SYMLINK_FOLLOW = 1024;
        
        /// <summary>
        /// Perform access checks using the effective user and group IDs.
        /// By default,
        /// faccessat ()
        /// uses the real IDs (like
        /// access ()).
        /// </summary>
        public const int AT_EACCESS = 512;
        
        /// <summary>
        /// Indicates that the application has no advice to give about its access
        /// pattern for the specified data.
        /// If no advice is given for an open file,
        /// this is the default assumption.
        /// </summary>
        public const int POSIX_FADV_NORMAL = 0;
        
        /// <summary>
        /// The specified data will be accessed in random order.
        /// </summary>
        public const int POSIX_FADV_RANDOM = 1;
        
        /// <summary>
        /// The application expects to access the specified data sequentially (with
        /// lower offsets read before higher ones).
        /// </summary>
        public const int POSIX_FADV_SEQUENTIAL = 2;
        
        /// <summary>
        /// The specified data will be accessed in the near future.
        /// 
        /// \fBPOSIX_FADV_WILLNEED\fP initiates a
        /// nonblocking read of the specified region into the page cache.
        /// The amount of data read may be decreased by the kernel depending
        /// on virtual memory load.
        /// (A few megabytes will usually be fully satisfied,
        /// and more is rarely useful.)
        /// </summary>
        public const int POSIX_FADV_WILLNEED = 3;
        
        /// <summary>
        /// The specified data will not be accessed in the near future.
        /// 
        /// \fBPOSIX_FADV_DONTNEED\fP attempts to free cached pages associated with
        /// the specified region.
        /// This is useful, for example, while streaming large
        /// files.
        /// A program may periodically request the kernel to free cached data
        /// that has already been used, so that more useful cached pages are not
        /// discarded instead.
        /// 
        /// Requests to discard partial pages are ignored.
        /// It is preferable to preserve needed data than discard unneeded data.
        /// If the application requires that data be considered for discarding, then
        /// offset
        /// and
        /// len
        /// must be page-aligned.
        /// 
        /// The implementation
        /// may
        /// attempt to write back dirty pages in the specified region,
        /// but this is not guaranteed.
        /// Any unwritten dirty pages will not be freed.
        /// If the application wishes to ensure that dirty pages will be released,
        /// it should call
        /// fsync (2)
        /// or
        /// fdatasync (2)
        /// first.
        /// </summary>
        public const int POSIX_FADV_DONTNEED = 4;
        
        /// <summary>
        /// The specified data will be accessed only once.
        /// 
        /// Before Linux 2.6.18, \fBPOSIX_FADV_NOREUSE\fP had the
        /// same semantics as \fBPOSIX_FADV_WILLNEED\fP.
        /// This was probably a bug; since Linux 2.6.18, this flag is a no-op.
        /// </summary>
        public const int POSIX_FADV_NOREUSE = 5;
        
        /// <summary>
        /// The file offset is set to
        /// offset
        /// bytes.
        /// </summary>
        public const int SEEK_SET = 0;
        
        /// <summary>
        /// The file offset is set to its current location plus
        /// offset
        /// bytes.
        /// </summary>
        public const int SEEK_CUR = 1;
        
        /// <summary>
        /// The file offset is set to the size of the file plus
        /// offset
        /// bytes.
        /// 
        /// lseek ()
        /// allows the file offset to be set beyond the end
        /// of the file (but this does not change the size of the file).
        /// If data is later written at this point, subsequent reads of the data
        /// in the gap (a "hole") return null bytes (\[aq]\e0\[aq]) until
        /// data is actually written into the gap.
        /// </summary>
        public const int SEEK_END = 2;
        
        public const int S_ISUID = 2048;
        
        public const int S_ISGID = 1024;
        
        public const int S_ISVTX = 512;
        
        public const int S_IRUSR = 256;
        
        public const int S_IWUSR = 128;
        
        public const int S_IXUSR = 64;
        
        public const int S_IRWXU = 448;
        
        public const int S_IRGRP = 32;
        
        public const int S_IWGRP = 16;
        
        public const int S_IXGRP = 8;
        
        public const int S_IRWXG = 56;
        
        public const int S_IROTH = 4;
        
        public const int S_IWOTH = 2;
        
        public const int S_IXOTH = 1;
        
        public const int S_IRWXO = 7;
        
        /// <summary>
        /// Don't trigger automounts.
        /// 
        /// The
        /// attr
        /// argument of
        /// mount_setattr ()
        /// is a structure of the following form:
        /// 
        /// +4n
        /// 
        /// struct mount_attr {
        ///     __u64 attr_set;     /* Mount properties to set */
        ///     __u64 attr_clr;     /* Mount properties to clear */
        ///     __u64 propagation;  /* Mount propagation type */
        ///     __u64 userns_fd;    /* User namespace file descriptor */
        /// };
        /// 
        /// 
        /// 
        /// The
        /// attr_set
        /// and
        /// attr_clr
        /// members are used to specify the mount properties that
        /// are supposed to be set or cleared for a mount or mount tree.
        /// Flags set in
        /// attr_set
        /// enable a property on a mount or mount tree,
        /// and flags set in
        /// attr_clr
        /// remove a property from a mount or mount tree.
        /// 
        /// When changing mount properties,
        /// the kernel will first clear the flags specified
        /// in the
        /// attr_clr
        /// field,
        /// and then set the flags specified in the
        /// attr_set
        /// field.
        /// For example, these settings:
        /// 
        /// +4n
        /// 
        /// struct mount_attr attr = {
        ///     .attr_clr = MOUNT_ATTR_NOEXEC | MOUNT_ATTR_NODEV,
        ///     .attr_set = MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID,
        /// };
        /// 
        /// 
        /// 
        /// are equivalent to the following steps:
        /// 
        /// +4n
        /// 
        /// unsigned int current_mnt_flags = mnt\-&gt;mnt_flags;
        /// \&amp;
        /// /*
        ///  * Clear all flags set in .attr_clr,
        ///  * clearing MOUNT_ATTR_NOEXEC and MOUNT_ATTR_NODEV.
        ///  */
        /// current_mnt_flags &amp;= \(tiattr\-&gt;attr_clr;
        /// \&amp;
        /// /*
        ///  * Now set all flags set in .attr_set,
        ///  * applying MOUNT_ATTR_RDONLY and MOUNT_ATTR_NOSUID.
        ///  */
        /// current_mnt_flags |= attr\-&gt;attr_set;
        /// \&amp;
        /// mnt\-&gt;mnt_flags = current_mnt_flags;
        /// 
        /// 
        /// 
        /// As a result of this change, the mount or mount tree (a) is read-only;
        /// (b) blocks the execution of set-user-ID and set-group-ID programs;
        /// (c) allows execution of programs; and (d) allows access to devices.
        /// 
        /// Multiple changes with the same set of flags requested
        /// in
        /// attr_clr
        /// and
        /// attr_set
        /// are guaranteed to be idempotent after the changes have been applied.
        /// 
        /// The following mount attributes can be specified in the
        /// attr_set
        /// or
        /// attr_clr
        /// fields:
        /// </summary>
        public const int AT_NO_AUTOMOUNT = 2048;
        
        /// <summary>
        /// If
        /// pathname
        /// is an empty string, operate on the file referred to by
        /// dirfd
        /// (which may have been obtained using the
        /// open (2)
        /// O_PATH
        /// flag).
        /// </summary>
        public const int AT_EMPTY_PATH = 4096;
        
        public const int AT_STATX_SYNC_TYPE = 24576;
        
        /// <summary>
        /// Do whatever
        /// stat (2)
        /// does.
        /// This is the default and is very much filesystem-specific.
        /// </summary>
        public const int AT_STATX_SYNC_AS_STAT = 0;
        
        /// <summary>
        /// Force the attributes to be synchronized with the server.
        /// This may require that
        /// a network filesystem perform a data writeback to get the timestamps correct.
        /// </summary>
        public const int AT_STATX_FORCE_SYNC = 8192;
        
        /// <summary>
        /// Don't synchronize anything, but rather just take whatever
        /// the system has cached if possible.
        /// This may mean that the information returned is approximate, but,
        /// on a network filesystem, it may not involve a round trip to the server - even
        /// if no lease is held.
        /// 
        /// The
        /// mask
        /// argument to
        /// statx ()
        /// is used to tell the kernel which fields the caller is interested in.
        /// mask
        /// is an ORed combination of the following constants:
        /// 
        /// +4n
        /// 
        /// lB l.
        /// STATX_TYPE	Want stx_mode &amp; S_IFMT
        /// STATX_MODE	Want stx_mode &amp; \[ti]S_IFMT
        /// STATX_NLINK	Want stx_nlink
        /// STATX_UID	Want stx_uid
        /// STATX_GID	Want stx_gid
        /// STATX_ATIME	Want stx_atime
        /// STATX_MTIME	Want stx_mtime
        /// STATX_CTIME	Want stx_ctime
        /// STATX_INO	Want stx_ino
        /// STATX_SIZE	Want stx_size
        /// STATX_BLOCKS	Want stx_blocks
        /// STATX_BASIC_STATS	[All of the above]
        /// STATX_BTIME	Want stx_btime
        /// STATX_ALL	The same as STATX_BASIC_STATS | STATX_BTIME.
        /// 	It is deprecated and should not be used.
        /// STATX_MNT_ID	Want stx_mnt_id (since Linux 5.8)
        /// STATX_DIOALIGN	Want stx_dio_mem_align and stx_dio_offset_align
        /// 	(since Linux 6.1; support varies by filesystem)
        /// 
        /// 
        /// 
        /// Note that, in general, the kernel does
        /// not
        /// reject values in
        /// mask
        /// other than the above.
        /// (For an exception, see
        /// EINVAL
        /// in errors.)
        /// Instead, it simply informs the caller which values are supported
        /// by this kernel and filesystem via the
        /// statx.stx_mask
        /// field.
        /// Therefore,
        /// "do not"
        /// simply set
        /// mask
        /// to
        /// UINT_MAX
        /// (all bits set),
        /// as one or more bits may, in the future, be used to specify an
        /// extension to the buffer.
        /// </summary>
        public const int AT_STATX_DONT_SYNC = 16384;
        
        /// <summary>
        /// Change the mount properties of the entire mount tree.
        /// </summary>
        public const int AT_RECURSIVE = 32768;
        
        public const int F_OK = 0;
        
        public const int R_OK = 4;
        
        public const int W_OK = 2;
        
        public const int X_OK = 1;
        
        /// <summary>
        /// Unlock the indicated section of the file.
        /// This may cause a locked section to be split into two locked sections.
        /// </summary>
        public const int F_ULOCK = 0;
        
        /// <summary>
        /// Set an exclusive lock on the specified section of the file.
        /// If (part of) this section is already locked, the call
        /// blocks until the previous lock is released.
        /// If this section overlaps an earlier locked section,
        /// both are merged.
        /// File locks are released as soon as the process holding the locks
        /// closes some file descriptor for the file.
        /// A child process does not inherit these locks.
        /// </summary>
        public const int F_LOCK = 1;
        
        /// <summary>
        /// Same as
        /// F_LOCK
        /// but the call never blocks and returns an error instead if the file is
        /// already locked.
        /// </summary>
        public const int F_TLOCK = 2;
        
        /// <summary>
        /// Test the lock: return 0 if the specified section
        /// is unlocked or locked by this process; return \-1, set
        /// errno
        /// to
        /// EAGAIN
        /// ( EACCES
        /// on some other systems),
        /// if another process holds a lock.
        /// </summary>
        public const int F_TEST = 3;
        
        public const int F_SETLEASE = 1024;
        
        /// <summary>
        /// Type of lease held on file descriptor.
        /// </summary>
        public const int F_GETLEASE = 1025;
        
        public const int F_NOTIFY = 1026;
        
        public const int F_CANCELLK = 1029;
        
        public const int F_SETPIPE_SZ = 1031;
        
        /// <summary>
        /// F_SETPIPE_SZ
        /// The pipe capacity.
        /// </summary>
        public const int F_GETPIPE_SZ = 1032;
        
        public const int F_ADD_SEALS = 1033;
        
        /// <summary>
        /// A bit mask identifying the seals that have been set
        /// for the inode referred to by
        /// fd .
        /// </summary>
        public const int F_GET_SEALS = 1034;
        
        /// <summary>
        /// If this seal is set, any further call to
        /// fcntl ()
        /// with
        /// F_ADD_SEALS
        /// fails with the error
        /// EPERM .
        /// Therefore, this seal prevents any modifications to the set of seals itself.
        /// If the initial set of seals of a file includes
        /// F_SEAL_SEAL ,
        /// then this effectively causes the set of seals to be constant and locked.
        /// </summary>
        public const int F_SEAL_SEAL = 1;
        
        /// <summary>
        /// If this seal is set, the file in question cannot be reduced in size.
        /// This affects
        /// open (2)
        /// with the
        /// O_TRUNC
        /// flag as well as
        /// truncate (2)
        /// and
        /// ftruncate (2).
        /// Those calls fail with
        /// EPERM
        /// if you try to shrink the file in question.
        /// Increasing the file size is still possible.
        /// </summary>
        public const int F_SEAL_SHRINK = 2;
        
        /// <summary>
        /// If this seal is set, the size of the file in question cannot be increased.
        /// This affects
        /// write (2)
        /// beyond the end of the file,
        /// truncate (2),
        /// ftruncate (2),
        /// and
        /// fallocate (2).
        /// These calls fail with
        /// EPERM
        /// if you use them to increase the file size.
        /// If you keep the size or shrink it, those calls still work as expected.
        /// </summary>
        public const int F_SEAL_GROW = 4;
        
        /// <summary>
        /// If this seal is set, you cannot modify the contents of the file.
        /// Note that shrinking or growing the size of the file is
        /// still possible and allowed.
        /// One or more other seals are typically used with F_SEAL_WRITE
        /// because, given a file with the F_SEAL_WRITE seal set, then,
        /// while it would no longer be possible to (say) write zeros into
        /// the last 100 bytes of a file, it would still be possible
        /// to (say) shrink the file by 100 bytes using ftruncate(), and
        /// then increase the file size by 100 bytes, which would have
        /// the effect of replacing the last hundred bytes by zeros.
        /// 
        /// Thus, this seal is normally used in combination with one of the other seals.
        /// This seal affects
        /// write (2)
        /// and
        /// fallocate (2)
        /// (only in combination with the
        /// FALLOC_FL_PUNCH_HOLE
        /// flag).
        /// Those calls fail with
        /// EPERM
        /// if this seal is set.
        /// Furthermore, trying to create new shared, writable memory-mappings via
        /// mmap (2)
        /// will also fail with
        /// EPERM .
        /// 
        /// Using the
        /// F_ADD_SEALS
        /// operation to set the
        /// F_SEAL_WRITE
        /// seal fails with
        /// EBUSY
        /// if any writable, shared mapping exists.
        /// Such mappings must be unmapped before you can add this seal.
        /// Furthermore, if there are any asynchronous I/O operations
        /// ( io_submit (2))
        /// pending on the file,
        /// all outstanding writes will be discarded.
        /// </summary>
        public const int F_SEAL_WRITE = 8;
        
        public const int F_SEAL_FUTURE_WRITE = 16;
        
        public const int F_GET_RW_HINT = 1035;
        
        public const int F_SET_RW_HINT = 1036;
        
        public const int F_GET_FILE_RW_HINT = 1037;
        
        public const int F_SET_FILE_RW_HINT = 1038;
        
        public const int RWF_WRITE_LIFE_NOT_SET = 0;
        
        /// <summary>
        /// No specific write lifetime is associated with this file or inode.
        /// </summary>
        public const int RWH_WRITE_LIFE_NONE = 1;
        
        /// <summary>
        /// Data written to this inode or via this open file description
        /// is expected to have a short lifetime.
        /// </summary>
        public const int RWH_WRITE_LIFE_SHORT = 2;
        
        /// <summary>
        /// Data written to this inode or via this open file description
        /// is expected to have a lifetime longer than
        /// data written with
        /// RWH_WRITE_LIFE_SHORT .
        /// </summary>
        public const int RWH_WRITE_LIFE_MEDIUM = 3;
        
        /// <summary>
        /// Data written to this inode or via this open file description
        /// is expected to have a lifetime longer than
        /// data written with
        /// RWH_WRITE_LIFE_MEDIUM .
        /// </summary>
        public const int RWH_WRITE_LIFE_LONG = 4;
        
        /// <summary>
        /// Data written to this inode or via this open file description
        /// is expected to have a lifetime longer than
        /// data written with
        /// RWH_WRITE_LIFE_LONG .
        /// 
        /// All the write-specific hints are relative to each other,
        /// and no individual absolute meaning should be attributed to them.
        /// </summary>
        public const int RWH_WRITE_LIFE_EXTREME = 5;
        
        public const int DN_ACCESS = 1;
        
        public const int DN_MODIFY = 2;
        
        public const int DN_CREATE = 4;
        
        public const int DN_DELETE = 8;
        
        public const int DN_RENAME = 16;
        
        public const int DN_ATTRIB = 32;
        
        public const int DN_MULTISHOT = -2147483648;
        
        public const int F_OWNER_TID = 0;
        
        public const int F_OWNER_PID = 1;
        
        public const int F_OWNER_PGRP = 2;
        
        public const int F_OWNER_GID = 2;
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "creat")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int creat(byte* pathname, musl.mode_t mode);
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "creat")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int creat([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pathname, musl.mode_t mode);
        
        /// <summary>
        /// Manipulate file descriptor
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "fcntl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int fcntl(int fd, int cmd);
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int open(byte* pathname, int flags);
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int open([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pathname, int flags);
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "openat")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int openat(int dirfd, byte* pathname, int how);
        
        /// <summary>
        /// Open and possibly create a file
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "openat")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int openat(int dirfd, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pathname, int how);
        
        /// <summary>
        /// Predeclare an access pattern for file data
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "posix_fadvise")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int posix_fadvise(int fd, musl.off_t offset, musl.off_t len, int advice);
        
        /// <summary>
        /// Allocate file space
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "posix_fallocate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int posix_fallocate(int fd, musl.off_t offset, musl.off_t len);
        
        /// <summary>
        /// Manipulate file space
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "fallocate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int fallocate(int fd, int mode, musl.off_t offset, musl.off_t len);
        
        /// <summary>
        /// Obtain handle
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "name_to_handle_at")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int name_to_handle_at(int dirfd, byte* pathname, ref musl.file_handle handle, ref int mount_id, int flags);
        
        /// <summary>
        /// Obtain handle
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "name_to_handle_at")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int name_to_handle_at(int dirfd, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pathname, ref musl.file_handle handle, ref int mount_id, int flags);
        
        /// <summary>
        /// Obtain handle
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "open_by_handle_at")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int open_by_handle_at(int mount_fd, ref musl.file_handle handle, int flags);
        
        /// <summary>
        /// Initiate file readahead into page cache
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "readahead")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint readahead(int fd, musl.off_t offset, nuint count);
        
        /// <summary>
        /// Sync a file segment with disk
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sync_file_range")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sync_file_range(int fd, musl.off_t offset, musl.off_t nbytes, uint flags);
        
        /// <summary>
        /// Splice user pages to/from a pipe
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "vmsplice")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint vmsplice(int fd, in musl.iovec iov, nuint nr_segs, uint flags);
        
        /// <summary>
        /// Splice data to/from a pipe
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "splice")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint splice(int fd_in, ref musl.off_t off_in, int fd_out, ref musl.off_t off_out, nuint len, uint flags);
        
        /// <summary>
        /// Duplicating pipe content
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "tee")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint tee(int fd_in, int fd_out, nuint len, uint flags);
    }
}
