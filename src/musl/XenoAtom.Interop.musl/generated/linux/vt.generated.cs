//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    public static unsafe partial class musl
    {
        public partial struct vt_mode
        {
            /// <summary>
            /// vt mode
            /// </summary>
            public byte mode;
            
            /// <summary>
            /// if set, hang on writes if not active
            /// </summary>
            public byte waitv;
            
            /// <summary>
            /// signal to raise on release req
            /// </summary>
            public short relsig;
            
            /// <summary>
            /// signal to raise on acquisition
            /// </summary>
            public short acqsig;
            
            /// <summary>
            /// unused (set to 0)
            /// </summary>
            public short frsig;
        }
        
        public partial struct vt_stat
        {
            /// <summary>
            /// active vt
            /// </summary>
            public ushort v_active;
            
            /// <summary>
            /// signal to send
            /// </summary>
            public ushort v_signal;
            
            /// <summary>
            /// vt bitmask
            /// </summary>
            public ushort v_state;
        }
        
        public partial struct vt_sizes
        {
            /// <summary>
            /// number of rows
            /// </summary>
            public ushort v_rows;
            
            /// <summary>
            /// number of columns
            /// </summary>
            public ushort v_cols;
            
            /// <summary>
            /// number of lines of scrollback
            /// </summary>
            public ushort v_scrollsize;
        }
        
        public partial struct vt_consize
        {
            /// <summary>
            /// number of rows
            /// </summary>
            public ushort v_rows;
            
            /// <summary>
            /// number of columns
            /// </summary>
            public ushort v_cols;
            
            /// <summary>
            /// number of pixel rows on screen
            /// </summary>
            public ushort v_vlin;
            
            /// <summary>
            /// number of pixel rows per character
            /// </summary>
            public ushort v_clin;
            
            /// <summary>
            /// number of pixel columns on screen
            /// </summary>
            public ushort v_vcol;
            
            /// <summary>
            /// number of pixel columns per character
            /// </summary>
            public ushort v_ccol;
        }
        
        public unsafe partial struct vt_event
        {
            public uint @event;
            
            /// <summary>
            /// Old console
            /// </summary>
            public uint oldev;
            
            /// <summary>
            /// New console (if changing)
            /// </summary>
            public uint newev;
            
            /// <summary>
            /// Padding for expansion
            /// </summary>
            public fixed uint pad[4];
        }
        
        public partial struct vt_setactivate
        {
            public uint console;
            
            public musl.vt_mode mode;
        }
        
        /// <summary>
        /// find available vt
        /// </summary>
        /// <summary>
        /// Returns the first available (non-opened) console.
        /// argp
        /// points to an
        /// int
        /// which is set to the
        /// number of the vt (1 &lt;=
        /// *argp
        /// &lt;= MAX_NR_CONSOLES).
        /// </summary>
        public const ushort VT_OPENQRY = 22016;
        
        /// <summary>
        /// get mode of active vt
        /// </summary>
        /// <summary>
        /// Get mode of active vt.
        /// argp
        /// points to a
        /// 
        /// +4n
        /// 
        /// struct vt_mode {
        ///     char  mode;    /* vt mode */
        ///     char  waitv;   /* if set, hang on writes if not active */
        ///     short relsig;  /* signal to raise on release req */
        ///     short acqsig;  /* signal to raise on acquisition */
        ///     short frsig;   /* unused (set to 0) */
        /// };
        /// 
        /// 
        /// 
        /// which is set to the mode of the active vt.
        /// mode
        /// is set to one of these values:
        /// 
        /// l l.
        /// VT_AUTO	auto vt switching
        /// VT_PROCESS	process controls switching
        /// VT_ACKACQ	acknowledge switch
        /// </summary>
        public const ushort VT_GETMODE = 22017;
        
        /// <summary>
        /// set mode of active vt
        /// </summary>
        /// <summary>
        /// Set mode of active vt.
        /// argp
        /// points to a
        /// "struct vt_mode" .
        /// </summary>
        public const ushort VT_SETMODE = 22018;
        
        /// <summary>
        /// auto vt switching
        /// </summary>
        public const ushort VT_AUTO = 0;
        
        /// <summary>
        /// process controls switching
        /// </summary>
        public const ushort VT_PROCESS = 1;
        
        /// <summary>
        /// acknowledge switch
        /// </summary>
        public const ushort VT_ACKACQ = 2;
        
        /// <summary>
        /// get global vt state info
        /// </summary>
        /// <summary>
        /// Get global vt state info.
        /// argp
        /// points to a
        /// 
        /// +4n
        /// 
        /// struct vt_stat {
        ///     unsigned short v_active;  /* active vt */
        ///     unsigned short v_signal;  /* signal to send */
        ///     unsigned short v_state;   /* vt bit mask */
        /// };
        /// 
        /// 
        /// 
        /// For each vt in use, the corresponding bit in the
        /// v_state
        /// member is set.
        /// (Linux 1.0 through Linux 1.1.92.)
        /// </summary>
        public const ushort VT_GETSTATE = 22019;
        
        /// <summary>
        /// signal to send to bitmask of vts
        /// </summary>
        public const ushort VT_SENDSIG = 22020;
        
        /// <summary>
        /// release display
        /// </summary>
        /// <summary>
        /// Release a display.
        /// </summary>
        public const ushort VT_RELDISP = 22021;
        
        /// <summary>
        /// make vt active
        /// </summary>
        /// <summary>
        /// Switch to vt
        /// argp
        /// (1 &lt;=
        /// argp
        /// &lt;= MAX_NR_CONSOLES).
        /// </summary>
        public const ushort VT_ACTIVATE = 22022;
        
        /// <summary>
        /// wait for vt active
        /// </summary>
        /// <summary>
        /// Wait until vt
        /// argp
        /// has been activated.
        /// </summary>
        public const ushort VT_WAITACTIVE = 22023;
        
        /// <summary>
        /// free memory associated to vt
        /// </summary>
        /// <summary>
        /// Deallocate the memory associated with vt
        /// argp .
        /// (Since Linux 1.1.54.)
        /// </summary>
        public const ushort VT_DISALLOCATE = 22024;
        
        /// <summary>
        /// set kernel's idea of screensize
        /// </summary>
        /// <summary>
        /// Set the kernel's idea of screensize.
        /// argp
        /// points to a
        /// 
        /// +4n
        /// 
        /// struct vt_sizes {
        ///     unsigned short v_rows;       /* # rows */
        ///     unsigned short v_cols;       /* # columns */
        ///     unsigned short v_scrollsize; /* no longer used */
        /// };
        /// 
        /// 
        /// 
        /// Note that this does not change the videomode.
        /// See
        /// resizecons (8).
        /// (Since Linux 1.1.54.)
        /// </summary>
        public const ushort VT_RESIZE = 22025;
        
        /// <summary>
        /// set kernel's idea of screensize + more
        /// </summary>
        /// <summary>
        /// Set the kernel's idea of various screen parameters.
        /// argp
        /// points to a
        /// 
        /// +4n
        /// 
        /// struct vt_consize {
        ///     unsigned short v_rows;  /* number of rows */
        ///     unsigned short v_cols;  /* number of columns */
        ///     unsigned short v_vlin;  /* number of pixel rows
        ///                                on screen */
        ///     unsigned short v_clin;  /* number of pixel rows
        ///                                per character */
        ///     unsigned short v_vcol;  /* number of pixel columns
        ///                                on screen */
        ///     unsigned short v_ccol;  /* number of pixel columns
        ///                                per character */
        /// };
        /// 
        /// 
        /// 
        /// Any parameter may be set to zero, indicating "no change", but if
        /// multiple parameters are set, they must be self-consistent.
        /// Note that this does not change the videomode.
        /// See
        /// resizecons (8).
        /// (Since Linux 1.3.3.)
        /// 
        /// The action of the following ioctls depends on the first byte in the struct
        /// pointed to by
        /// argp ,
        /// referred to here as the
        /// subcode .
        /// These are legal only for the superuser or the owner of the current terminal.
        /// Symbolic
        /// subcode s
        /// are available in
        /// &lt;linux/tiocl.h&gt;
        /// since
        /// Linux 2.5.71.
        /// </summary>
        public const ushort VT_RESIZEX = 22026;
        
        /// <summary>
        /// disallow vt switching
        /// </summary>
        public const ushort VT_LOCKSWITCH = 22027;
        
        /// <summary>
        /// allow vt switching
        /// </summary>
        public const ushort VT_UNLOCKSWITCH = 22028;
        
        /// <summary>
        /// return hi font mask
        /// </summary>
        public const ushort VT_GETHIFONTMASK = 22029;
        
        /// <summary>
        /// Console switch
        /// </summary>
        public const ushort VT_EVENT_SWITCH = 1;
        
        /// <summary>
        /// Screen blank
        /// </summary>
        public const ushort VT_EVENT_BLANK = 2;
        
        /// <summary>
        /// Screen unblank
        /// </summary>
        public const ushort VT_EVENT_UNBLANK = 4;
        
        /// <summary>
        /// Resize display
        /// </summary>
        public const ushort VT_EVENT_RESIZE = 8;
        
        public const ushort VT_MAX_EVENT = 15;
        
        /// <summary>
        /// Wait for an event
        /// </summary>
        public const ushort VT_WAITEVENT = 22030;
        
        /// <summary>
        /// Activate and set the mode of a console
        /// </summary>
        public const ushort VT_SETACTIVATE = 22031;
    }
}
