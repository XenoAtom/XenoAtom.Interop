//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct rlimit
        {
            public musl.rlim_t rlim_cur;
            
            public musl.rlim_t rlim_max;
        }
        
        public readonly partial struct rlim_t : IEquatable<musl.rlim_t>
        {
            public rlim_t(ulong value) => this.Value = value;
            
            public ulong Value { get; }
            
            public override bool Equals(object obj) => obj is rlim_t other && Equals(other);
            
            public bool Equals(rlim_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong (musl.rlim_t from) => from.Value;
            
            public static implicit operator musl.rlim_t (ulong from) => new musl.rlim_t(from);
            
            public static bool operator ==(rlim_t left, rlim_t right) => left.Equals(right);
            
            public static bool operator !=(rlim_t left, rlim_t right) => !left.Equals(right);
        }
        
        public partial struct rusage
        {
            public musl.timeval ru_utime;
            
            public musl.timeval ru_stime;
            
            /// <summary>
            /// linux extentions, but useful
            /// </summary>
            public nint ru_maxrss;
            
            public nint ru_ixrss;
            
            public nint ru_idrss;
            
            public nint ru_isrss;
            
            public nint ru_minflt;
            
            public nint ru_majflt;
            
            public nint ru_nswap;
            
            public nint ru_inblock;
            
            public nint ru_oublock;
            
            public nint ru_msgsnd;
            
            public nint ru_msgrcv;
            
            public nint ru_nsignals;
            
            public nint ru_nvcsw;
            
            public nint ru_nivcsw;
            
            /// <summary>
            /// room for more...
            /// </summary>
            public FixedArray16<nint> __reserved;
        }
        
        public const int PRIO_MIN = -20;
        
        public const int PRIO_MAX = 20;
        
        public const int PRIO_PROCESS = 0;
        
        public const int PRIO_PGRP = 1;
        
        public const int PRIO_USER = 2;
        
        /// <summary>
        /// Return resource usage statistics for the calling process,
        /// which is the sum of resources used by all threads in the process.
        /// </summary>
        public const int RUSAGE_SELF = 0;
        
        /// <summary>
        /// Return resource usage statistics for all children of the
        /// calling process that have terminated and been waited for.
        /// These statistics will include the resources used by grandchildren,
        /// and further removed descendants,
        /// if all of the intervening descendants waited on their terminated children.
        /// </summary>
        public const int RUSAGE_CHILDREN = -1;
        
        public const int RUSAGE_THREAD = 1;
        
        public const int RLIM_INFINITY = -1;
        
        public const int RLIM_SAVED_CUR = -1;
        
        public const int RLIM_SAVED_MAX = -1;
        
        /// <summary>
        /// This is a limit, in seconds,
        /// on the amount of CPU time that the process can consume.
        /// When the process reaches the soft limit, it is sent a
        /// SIGXCPU
        /// signal.
        /// The default action for this signal is to terminate the process.
        /// However, the signal can be caught, and the handler can return control to
        /// the main program.
        /// If the process continues to consume CPU time, it will be sent
        /// SIGXCPU
        /// once per second until the hard limit is reached, at which time
        /// it is sent
        /// SIGKILL .
        /// (This latter point describes Linux behavior.
        /// Implementations vary in how they treat processes which continue to
        /// consume CPU time after reaching the soft limit.
        /// Portable applications that need to catch this signal should
        /// perform an orderly termination upon first receipt of
        /// SIGXCPU .)
        /// </summary>
        public const int RLIMIT_CPU = 0;
        
        /// <summary>
        /// This is the maximum size in bytes of files that the process may create.
        /// Attempts to extend a file beyond this limit result in delivery of a
        /// SIGXFSZ
        /// signal.
        /// By default, this signal terminates a process, but a process can
        /// catch this signal instead, in which case the relevant system call (e.g.,
        /// write (2),
        /// truncate (2))
        /// fails with the error
        /// EFBIG .
        /// </summary>
        public const int RLIMIT_FSIZE = 1;
        
        /// <summary>
        /// This is the maximum size
        /// of the process's data segment (initialized data,
        /// uninitialized data, and heap).
        /// The limit is specified in bytes, and is rounded down to the system page size.
        /// This limit affects calls to
        /// brk (2),
        /// sbrk (2),
        /// and (since Linux 4.7)
        /// mmap (2),
        /// commits 84638335900f1995495838fe1bd4870c43ec1f67
        /// ("mm: rework virtual memory accounting"),
        /// f4fcd55841fc9e46daac553b39361572453c2b88
        /// (mm: enable RLIMIT_DATA by default with workaround for valgrind).
        /// which fail with the error
        /// ENOMEM
        /// upon encountering the soft limit of this resource.
        /// </summary>
        public const int RLIMIT_DATA = 2;
        
        /// <summary>
        /// This is the maximum size of the process stack, in bytes.
        /// Upon reaching this limit, a
        /// SIGSEGV
        /// signal is generated.
        /// To handle this signal, a process must employ an alternate signal stack
        /// ( sigaltstack (2)).
        /// 
        /// Since Linux 2.6.23,
        /// this limit also determines the amount of space used for the process's
        /// command-line arguments and environment variables; for details, see
        /// execve (2).
        /// </summary>
        public const int RLIMIT_STACK = 3;
        
        /// <summary>
        /// This is the maximum size of a
        /// core
        /// file (see
        /// core (5))
        /// in bytes that the process may dump.
        /// When 0 no core dump files are created.
        /// When nonzero, larger dumps are truncated to this size.
        /// </summary>
        public const int RLIMIT_CORE = 4;
        
        /// <summary>
        /// This is a limit (in bytes) on the process's resident set
        /// (the number of virtual pages resident in RAM).
        /// This limit has effect only in Linux 2.4.x, x &lt; 30, and there
        /// affects only calls to
        /// madvise (2)
        /// specifying
        /// MADV_WILLNEED .
        /// As at Linux 2.6.12, this limit still does nothing in Linux 2.6 though
        /// talk of making it do something has surfaced from time to time in LKML
        /// -- MTK, Jul 05
        /// </summary>
        public const int RLIMIT_RSS = 5;
        
        /// <summary>
        /// This is a limit on the number of extant process
        /// (or, more precisely on Linux, threads)
        /// for the real user ID of the calling process.
        /// So long as the current number of processes belonging to this
        /// process's real user ID is greater than or equal to this limit,
        /// fork (2)
        /// fails with the error
        /// EAGAIN .
        /// 
        /// The
        /// RLIMIT_NPROC
        /// limit is not enforced for processes that have either the
        /// CAP_SYS_ADMIN
        /// or the
        /// CAP_SYS_RESOURCE
        /// capability,
        /// or run with real user ID 0.
        /// </summary>
        public const int RLIMIT_NPROC = 6;
        
        /// <summary>
        /// This specifies a value one greater than the maximum file descriptor number
        /// that can be opened by this process.
        /// Attempts
        /// ( open (2),
        /// pipe (2),
        /// dup (2),
        /// etc.)
        /// to exceed this limit yield the error
        /// EMFILE .
        /// (Historically, this limit was named
        /// RLIMIT_OFILE
        /// on BSD.)
        /// 
        /// Since Linux 4.5,
        /// this limit also defines the maximum number of file descriptors that
        /// an unprivileged process (one without the
        /// CAP_SYS_RESOURCE
        /// capability) may have "in flight" to other processes,
        /// by being passed across UNIX domain sockets.
        /// This limit applies to the
        /// sendmsg (2)
        /// system call.
        /// For further details, see
        /// unix (7).
        /// </summary>
        public const int RLIMIT_NOFILE = 7;
        
        /// <summary>
        /// This is the maximum number of bytes of memory that may be locked
        /// into RAM.
        /// This limit is in effect rounded down to the nearest multiple
        /// of the system page size.
        /// This limit affects
        /// mlock (2),
        /// mlockall (2),
        /// and the
        /// mmap (2)
        /// MAP_LOCKED
        /// operation.
        /// Since Linux 2.6.9, it also affects the
        /// shmctl (2)
        /// SHM_LOCK
        /// operation, where it sets a maximum on the total bytes in
        /// shared memory segments (see
        /// shmget (2))
        /// that may be locked by the real user ID of the calling process.
        /// The
        /// shmctl (2)
        /// SHM_LOCK
        /// locks are accounted for separately from the per-process memory
        /// locks established by
        /// mlock (2),
        /// mlockall (2),
        /// and
        /// mmap (2)
        /// MAP_LOCKED ;
        /// a process can lock bytes up to this limit in each of these
        /// two categories.
        /// 
        /// Before Linux 2.6.9, this limit controlled the amount of
        /// memory that could be locked by a privileged process.
        /// Since Linux 2.6.9, no limits are placed on the amount of memory
        /// that a privileged process may lock, and this limit instead governs
        /// the amount of memory that an unprivileged process may lock.
        /// </summary>
        public const int RLIMIT_MEMLOCK = 8;
        
        /// <summary>
        /// This is the maximum size of the process's virtual memory
        /// (address space).
        /// The limit is specified in bytes, and is rounded down to the system page size.
        /// since Linux 2.0.27 / Linux 2.1.12
        /// This limit affects calls to
        /// brk (2),
        /// mmap (2),
        /// and
        /// mremap (2),
        /// which fail with the error
        /// ENOMEM
        /// upon exceeding this limit.
        /// In addition, automatic stack expansion fails
        /// (and generates a
        /// SIGSEGV
        /// that kills the process if no alternate stack
        /// has been made available via
        /// sigaltstack (2)).
        /// Since the value is a \fIlong\fP, on machines with a 32-bit \fIlong\fP
        /// either this limit is at most 2\ GiB, or this resource is unlimited.
        /// </summary>
        public const int RLIMIT_AS = 9;
        
        public const int RLIMIT_LOCKS = 10;
        
        public const int RLIMIT_SIGPENDING = 11;
        
        public const int RLIMIT_MSGQUEUE = 12;
        
        public const int RLIMIT_NICE = 13;
        
        public const int RLIMIT_RTPRIO = 14;
        
        public const int RLIMIT_RTTIME = 15;
        
        public const int RLIMIT_NLIMITS = 16;
        
        /// <summary>
        /// Get/set resource limits
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getrlimit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getrlimit(int resource, ref musl.rlimit rlim);
        
        /// <summary>
        /// Get/set resource limits
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "setrlimit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int setrlimit(int resource, in musl.rlimit rlim);
        
        /// <summary>
        /// Get resource usage
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getrusage")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getrusage(int who, ref musl.rusage usage);
        
        /// <summary>
        /// Get/set program scheduling priority
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getpriority")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getpriority(int which, musl.id_t who);
        
        /// <summary>
        /// Get/set program scheduling priority
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "setpriority")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int setpriority(int which, musl.id_t who, int prio);
        
        /// <summary>
        /// Get/set resource limits
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "prlimit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int prlimit(musl.pid_t pid, int resource, in musl.rlimit new_limit, ref musl.rlimit old_limit);
    }
}
