//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct prctl_mm_map
        {
            public ulong start_code;
            
            public ulong end_code;
            
            public ulong start_data;
            
            public ulong end_data;
            
            public ulong start_brk;
            
            public ulong brk;
            
            public ulong start_stack;
            
            public ulong arg_start;
            
            public ulong arg_end;
            
            public ulong env_start;
            
            public ulong env_end;
            
            public ulong* auxv;
            
            public uint auxv_size;
            
            public uint exe_fd;
        }
        
        public const int PR_SET_PDEATHSIG = 1;
        
        public const int PR_GET_PDEATHSIG = 2;
        
        public const int PR_GET_DUMPABLE = 3;
        
        public const int PR_SET_DUMPABLE = 4;
        
        /// <summary>
        /// (See
        /// PR_SET_UNALIGN
        /// for information on versions and architectures.)
        /// Return unaligned access control bits, in the location pointed to by
        /// "(unsigned int\~*) arg2" .
        /// prctl PR_GET_AUXV
        /// </summary>
        public const int PR_GET_UNALIGN = 5;
        
        /// <summary>
        /// (Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15;
        /// PowerPC, since Linux 2.6.18; Alpha, since Linux 2.6.22;
        /// sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
        /// tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
        /// sh, since Linux 2.6.34; tile, since Linux 3.12)
        /// Set unaligned access control bits to \fIarg2\fP.
        /// Pass
        /// \fBPR_UNALIGN_NOPRINT\fP to silently fix up unaligned user accesses,
        /// or \fBPR_UNALIGN_SIGBUS\fP to generate
        /// SIGBUS
        /// on unaligned user access.
        /// Alpha also supports an additional flag with the value
        /// of 4 and no corresponding named constant,
        /// which instructs kernel to not fix up
        /// unaligned accesses (it is analogous to providing the
        /// UAC_NOFIX
        /// flag in
        /// SSI_NVPAIRS
        /// operation of the
        /// setsysinfo ()
        /// system call on Tru64).
        /// prctl PR_GET_UNALIGN
        /// </summary>
        public const int PR_SET_UNALIGN = 6;
        
        public const int PR_UNALIGN_NOPRINT = 1;
        
        public const int PR_UNALIGN_SIGBUS = 2;
        
        public const int PR_GET_KEEPCAPS = 7;
        
        public const int PR_SET_KEEPCAPS = 8;
        
        public const int PR_GET_FPEMU = 9;
        
        public const int PR_SET_FPEMU = 10;
        
        public const int PR_FPEMU_NOPRINT = 1;
        
        public const int PR_FPEMU_SIGFPE = 2;
        
        public const int PR_GET_FPEXC = 11;
        
        public const int PR_SET_FPEXC = 12;
        
        public const int PR_FP_EXC_SW_ENABLE = 128;
        
        public const int PR_FP_EXC_DIV = 65536;
        
        public const int PR_FP_EXC_OVF = 131072;
        
        public const int PR_FP_EXC_UND = 262144;
        
        public const int PR_FP_EXC_RES = 524288;
        
        public const int PR_FP_EXC_INV = 1048576;
        
        public const int PR_FP_EXC_DISABLED = 0;
        
        public const int PR_FP_EXC_NONRECOV = 1;
        
        public const int PR_FP_EXC_ASYNC = 2;
        
        public const int PR_FP_EXC_PRECISE = 3;
        
        public const int PR_GET_TIMING = 13;
        
        public const int PR_SET_TIMING = 14;
        
        public const int PR_TIMING_STATISTICAL = 0;
        
        public const int PR_TIMING_TIMESTAMP = 1;
        
        public const int PR_SET_NAME = 15;
        
        public const int PR_GET_NAME = 16;
        
        public const int PR_GET_ENDIAN = 19;
        
        public const int PR_SET_ENDIAN = 20;
        
        public const int PR_ENDIAN_BIG = 0;
        
        public const int PR_ENDIAN_LITTLE = 1;
        
        public const int PR_ENDIAN_PPC_LITTLE = 2;
        
        public const int PR_GET_SECCOMP = 21;
        
        public const int PR_SET_SECCOMP = 22;
        
        public const int PR_CAPBSET_READ = 23;
        
        public const int PR_CAPBSET_DROP = 24;
        
        public const int PR_GET_TSC = 25;
        
        public const int PR_SET_TSC = 26;
        
        public const int PR_TSC_ENABLE = 1;
        
        public const int PR_TSC_SIGSEGV = 2;
        
        public const int PR_GET_SECUREBITS = 27;
        
        public const int PR_SET_SECUREBITS = 28;
        
        public const int PR_SET_TIMERSLACK = 29;
        
        public const int PR_GET_TIMERSLACK = 30;
        
        public const int PR_TASK_PERF_EVENTS_DISABLE = 31;
        
        public const int PR_TASK_PERF_EVENTS_ENABLE = 32;
        
        public const int PR_MCE_KILL = 33;
        
        public const int PR_MCE_KILL_CLEAR = 0;
        
        public const int PR_MCE_KILL_SET = 1;
        
        public const int PR_MCE_KILL_LATE = 0;
        
        public const int PR_MCE_KILL_EARLY = 1;
        
        public const int PR_MCE_KILL_DEFAULT = 2;
        
        public const int PR_MCE_KILL_GET = 34;
        
        public const int PR_SET_MM = 35;
        
        public const int PR_SET_MM_START_CODE = 1;
        
        public const int PR_SET_MM_END_CODE = 2;
        
        public const int PR_SET_MM_START_DATA = 3;
        
        public const int PR_SET_MM_END_DATA = 4;
        
        public const int PR_SET_MM_START_STACK = 5;
        
        public const int PR_SET_MM_START_BRK = 6;
        
        public const int PR_SET_MM_BRK = 7;
        
        public const int PR_SET_MM_ARG_START = 8;
        
        public const int PR_SET_MM_ARG_END = 9;
        
        public const int PR_SET_MM_ENV_START = 10;
        
        public const int PR_SET_MM_ENV_END = 11;
        
        public const int PR_SET_MM_AUXV = 12;
        
        public const int PR_SET_MM_EXE_FILE = 13;
        
        public const int PR_SET_MM_MAP = 14;
        
        public const int PR_SET_MM_MAP_SIZE = 15;
        
        public const int PR_SET_PTRACER = 1499557217;
        
        public const int PR_SET_PTRACER_ANY = -1;
        
        public const int PR_SET_CHILD_SUBREAPER = 36;
        
        public const int PR_GET_CHILD_SUBREAPER = 37;
        
        public const int PR_SET_NO_NEW_PRIVS = 38;
        
        public const int PR_GET_NO_NEW_PRIVS = 39;
        
        public const int PR_GET_TID_ADDRESS = 40;
        
        public const int PR_SET_THP_DISABLE = 41;
        
        public const int PR_GET_THP_DISABLE = 42;
        
        /// <summary>
        /// PR_MPX_DISABLE_MANAGEMENT " (since Linux 3.19, removed in Linux 5.4; only on x86)"
        /// commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
        /// See also http://lwn.net/Articles/582712/
        /// See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
        /// Enable or disable kernel management of Memory Protection eXtensions (MPX)
        /// bounds tables.
        /// The
        /// arg2 ,
        /// arg3 ,
        /// arg4 ,
        /// and
        /// arg5
        /// commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
        /// arguments must be zero.
        /// 
        /// MPX is a hardware-assisted mechanism for performing bounds checking on
        /// pointers.
        /// It consists of a set of registers storing bounds information
        /// and a set of special instruction prefixes that tell the CPU on which
        /// instructions it should do bounds enforcement.
        /// There is a limited number of these registers and
        /// when there are more pointers than registers,
        /// their contents must be "spilled" into a set of tables.
        /// These tables are called "bounds tables" and the MPX
        /// prctl ()
        /// operations control
        /// whether the kernel manages their allocation and freeing.
        /// 
        /// When management is enabled, the kernel will take over allocation
        /// and freeing of the bounds tables.
        /// It does this by trapping the #BR exceptions that result
        /// at first use of missing bounds tables and
        /// instead of delivering the exception to user space,
        /// it allocates the table and populates the bounds directory
        /// with the location of the new table.
        /// For freeing, the kernel checks to see if bounds tables are
        /// present for memory which is not allocated, and frees them if so.
        /// 
        /// Before enabling MPX management using
        /// PR_MPX_ENABLE_MANAGEMENT ,
        /// the application must first have allocated a user-space buffer for
        /// the bounds directory and placed the location of that directory in the
        /// bndcfgu
        /// register.
        /// 
        /// These calls fail if the CPU or kernel does not support MPX.
        /// Kernel support for MPX is enabled via the
        /// CONFIG_X86_INTEL_MPX
        /// configuration option.
        /// You can check whether the CPU supports MPX by looking for the
        /// mpx
        /// CPUID bit, like with the following command:
        /// 
        /// +4n
        /// 
        /// cat /proc/cpuinfo | grep \[aq] mpx \[aq]
        /// 
        /// 
        /// 
        /// A thread may not switch in or out of long (64-bit) mode while MPX is
        /// enabled.
        /// 
        /// All threads in a process are affected by these calls.
        /// 
        /// The child of a
        /// fork (2)
        /// inherits the state of MPX management.
        /// During
        /// execve (2),
        /// MPX management is reset to a state as if
        /// PR_MPX_DISABLE_MANAGEMENT
        /// had been called.
        /// 
        /// For further information on Intel MPX, see the kernel source file
        /// Documentation/x86/intel_mpx.txt .
        /// 
        /// commit f240652b6032b48ad7fa35c5e701cc4c8d697c0b
        /// See also https://lkml.kernel.org/r/20190705175321.DB42F0AD@viggo.jf.intel.com
        /// Due to a lack of toolchain support,
        /// PR_MPX_ENABLE_MANAGEMENT " and " PR_MPX_DISABLE_MANAGEMENT
        /// are not supported in Linux 5.4 and later.
        /// prctl PR_SET_NAME
        /// </summary>
        public const int PR_MPX_ENABLE_MANAGEMENT = 43;
        
        public const int PR_MPX_DISABLE_MANAGEMENT = 44;
        
        public const int PR_SET_FP_MODE = 45;
        
        public const int PR_GET_FP_MODE = 46;
        
        public const int PR_FP_MODE_FR = 1;
        
        public const int PR_FP_MODE_FRE = 2;
        
        public const int PR_CAP_AMBIENT = 47;
        
        public const int PR_CAP_AMBIENT_IS_SET = 1;
        
        public const int PR_CAP_AMBIENT_RAISE = 2;
        
        public const int PR_CAP_AMBIENT_LOWER = 3;
        
        public const int PR_CAP_AMBIENT_CLEAR_ALL = 4;
        
        public const int PR_SVE_SET_VL = 50;
        
        public const int PR_SVE_SET_VL_ONEXEC = 262144;
        
        public const int PR_SVE_GET_VL = 51;
        
        public const int PR_SVE_VL_LEN_MASK = 65535;
        
        public const int PR_SVE_VL_INHERIT = 131072;
        
        public const int PR_GET_SPECULATION_CTRL = 52;
        
        public const int PR_SET_SPECULATION_CTRL = 53;
        
        public const int PR_SPEC_STORE_BYPASS = 0;
        
        public const int PR_SPEC_INDIRECT_BRANCH = 1;
        
        public const int PR_SPEC_NOT_AFFECTED = 0;
        
        public const int PR_SPEC_PRCTL = 1;
        
        public const int PR_SPEC_ENABLE = 2;
        
        public const int PR_SPEC_DISABLE = 4;
        
        public const int PR_SPEC_FORCE_DISABLE = 8;
        
        public const int PR_SPEC_DISABLE_NOEXEC = 16;
        
        public const int PR_PAC_RESET_KEYS = 54;
        
        public const int PR_PAC_APIAKEY = 1;
        
        public const int PR_PAC_APIBKEY = 2;
        
        public const int PR_PAC_APDAKEY = 4;
        
        public const int PR_PAC_APDBKEY = 8;
        
        public const int PR_PAC_APGAKEY = 16;
        
        public const int PR_SET_TAGGED_ADDR_CTRL = 55;
        
        public const int PR_GET_TAGGED_ADDR_CTRL = 56;
        
        public const int PR_TAGGED_ADDR_ENABLE = 1;
        
        public const int PR_MTE_TCF_SHIFT = 1;
        
        public const int PR_MTE_TCF_NONE = 0;
        
        public const int PR_MTE_TCF_SYNC = 2;
        
        public const int PR_MTE_TCF_ASYNC = 4;
        
        public const int PR_MTE_TCF_MASK = 6;
        
        public const int PR_MTE_TAG_SHIFT = 3;
        
        public const int PR_MTE_TAG_MASK = 524280;
        
        public const int PR_SET_IO_FLUSHER = 57;
        
        public const int PR_GET_IO_FLUSHER = 58;
        
        public const int PR_SET_SYSCALL_USER_DISPATCH = 59;
        
        public const int PR_SYS_DISPATCH_OFF = 0;
        
        public const int PR_SYS_DISPATCH_ON = 1;
        
        public const int SYSCALL_DISPATCH_FILTER_ALLOW = 0;
        
        public const int SYSCALL_DISPATCH_FILTER_BLOCK = 1;
        
        public const int PR_PAC_SET_ENABLED_KEYS = 60;
        
        public const int PR_PAC_GET_ENABLED_KEYS = 61;
        
        /// <summary>
        /// Operations on a process or thread
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "prctl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int prctl(int option);
    }
}
