//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct msghdr
        {
            public void* msg_name;
            
            public musl.socklen_t msg_namelen;
            
            public musl.iovec* msg_iov;
            
            public int msg_iovlen;
            
            public int __pad1;
            
            public void* msg_control;
            
            public musl.socklen_t msg_controllen;
            
            public int __pad2;
            
            public int msg_flags;
        }
        
        public partial struct cmsghdr
        {
            public musl.socklen_t cmsg_len;
            
            public int __pad1;
            
            public int cmsg_level;
            
            public int cmsg_type;
        }
        
        public partial struct ucred
        {
            public musl.pid_t pid;
            
            public musl.uid_t uid;
            
            public musl.gid_t gid;
        }
        
        public partial struct mmsghdr
        {
            public musl.msghdr msg_hdr;
            
            public uint msg_len;
        }
        
        public partial struct linger
        {
            public int l_onoff;
            
            public int l_linger;
        }
        
        public unsafe partial struct sockaddr
        {
            public musl.sa_family_t sa_family;
            
            public fixed byte sa_data[14];
        }
        
        public unsafe partial struct sockaddr_storage
        {
            public musl.sa_family_t ss_family;
            
            public fixed byte __ss_padding[118];
            
            public nuint __ss_align;
        }
        
        public const int SHUT_RD = 0;
        
        public const int SHUT_WR = 1;
        
        public const int SHUT_RDWR = 2;
        
        /// <summary>
        /// Provides sequenced, reliable, two-way, connection-based byte streams.
        /// An out-of-band data transmission mechanism may be supported.
        /// </summary>
        public const int SOCK_STREAM = 1;
        
        /// <summary>
        /// Supports datagrams (connectionless, unreliable messages of a fixed
        /// maximum length).
        /// </summary>
        public const int SOCK_DGRAM = 2;
        
        /// <summary>
        /// Provides raw network protocol access.
        /// </summary>
        public const int SOCK_RAW = 3;
        
        /// <summary>
        /// Provides a reliable datagram layer that does not guarantee ordering.
        /// </summary>
        public const int SOCK_RDM = 4;
        
        /// <summary>
        /// Provides a sequenced, reliable, two-way connection-based data
        /// transmission path for datagrams of fixed maximum length; a consumer is
        /// required to read an entire packet with each input system call.
        /// </summary>
        public const int SOCK_SEQPACKET = 5;
        
        public const int SOCK_DCCP = 6;
        
        /// <summary>
        /// Obsolete and should not be used in new programs;
        /// see
        /// packet (7).
        /// 
        /// Some socket types may not be implemented by all protocol families.
        /// 
        /// Since Linux 2.6.27, the
        /// type
        /// argument serves a second purpose:
        /// in addition to specifying a socket type,
        /// it may include the bitwise OR of any of the following values,
        /// to modify the behavior of
        /// socket ():
        /// </summary>
        public const int SOCK_PACKET = 10;
        
        /// <summary>
        /// Set the close-on-exec
        /// ( FD_CLOEXEC )
        /// flag on the new file descriptor.
        /// See the description of the
        /// O_CLOEXEC
        /// flag in
        /// open (2)
        /// for reasons why this may be useful.
        /// </summary>
        public const int SOCK_CLOEXEC = 524288;
        
        /// <summary>
        /// Set the
        /// O_NONBLOCK
        /// file status flag on the open file description (see
        /// open (2))
        /// referred to by the new file descriptor.
        /// Using this flag saves extra calls to
        /// fcntl (2)
        /// to achieve the same result.
        /// </summary>
        public const int SOCK_NONBLOCK = 2048;
        
        public const int PF_UNSPEC = 0;
        
        public const int PF_LOCAL = 1;
        
        public const int PF_UNIX = 1;
        
        public const int PF_FILE = 1;
        
        public const int PF_INET = 2;
        
        public const int PF_AX25 = 3;
        
        public const int PF_IPX = 4;
        
        public const int PF_APPLETALK = 5;
        
        public const int PF_NETROM = 6;
        
        public const int PF_BRIDGE = 7;
        
        public const int PF_ATMPVC = 8;
        
        public const int PF_X25 = 9;
        
        public const int PF_INET6 = 10;
        
        public const int PF_ROSE = 11;
        
        public const int PF_DECnet = 12;
        
        public const int PF_NETBEUI = 13;
        
        public const int PF_SECURITY = 14;
        
        public const int PF_KEY = 15;
        
        public const int PF_NETLINK = 16;
        
        public const int PF_ROUTE = 16;
        
        public const int PF_PACKET = 17;
        
        public const int PF_ASH = 18;
        
        public const int PF_ECONET = 19;
        
        public const int PF_ATMSVC = 20;
        
        public const int PF_RDS = 21;
        
        public const int PF_SNA = 22;
        
        public const int PF_IRDA = 23;
        
        public const int PF_PPPOX = 24;
        
        public const int PF_WANPIPE = 25;
        
        public const int PF_LLC = 26;
        
        public const int PF_IB = 27;
        
        public const int PF_MPLS = 28;
        
        public const int PF_CAN = 29;
        
        public const int PF_TIPC = 30;
        
        public const int PF_BLUETOOTH = 31;
        
        public const int PF_IUCV = 32;
        
        public const int PF_RXRPC = 33;
        
        public const int PF_ISDN = 34;
        
        public const int PF_PHONET = 35;
        
        public const int PF_IEEE802154 = 36;
        
        public const int PF_CAIF = 37;
        
        public const int PF_ALG = 38;
        
        public const int PF_NFC = 39;
        
        public const int PF_VSOCK = 40;
        
        public const int PF_KCM = 41;
        
        public const int PF_QIPCRTR = 42;
        
        public const int PF_SMC = 43;
        
        public const int PF_XDP = 44;
        
        public const int PF_MAX = 45;
        
        public const int AF_UNSPEC = 0;
        
        public const int AF_LOCAL = 1;
        
        public const int AF_UNIX = 1;
        
        public const int AF_FILE = 1;
        
        /// <summary>
        /// The
        /// name
        /// argument points to a dotted-quad IPv4 address or a name
        /// of an IPv4 network host.
        /// </summary>
        public const int AF_INET = 2;
        
        public const int AF_AX25 = 3;
        
        public const int AF_IPX = 4;
        
        public const int AF_APPLETALK = 5;
        
        public const int AF_NETROM = 6;
        
        public const int AF_BRIDGE = 7;
        
        public const int AF_ATMPVC = 8;
        
        public const int AF_X25 = 9;
        
        /// <summary>
        /// The
        /// name
        /// argument points to a hexadecimal IPv6 address or a name
        /// of an IPv6 network host.
        /// 
        /// The
        /// flags
        /// argument specifies additional options.
        /// More than one option can be specified by bitwise OR-ing
        /// them together.
        /// flags
        /// should be set to 0
        /// if no options are desired.
        /// </summary>
        public const int AF_INET6 = 10;
        
        public const int AF_ROSE = 11;
        
        public const int AF_DECnet = 12;
        
        public const int AF_NETBEUI = 13;
        
        public const int AF_SECURITY = 14;
        
        public const int AF_KEY = 15;
        
        public const int AF_NETLINK = 16;
        
        public const int AF_ROUTE = 16;
        
        public const int AF_PACKET = 17;
        
        public const int AF_ASH = 18;
        
        public const int AF_ECONET = 19;
        
        public const int AF_ATMSVC = 20;
        
        public const int AF_RDS = 21;
        
        public const int AF_SNA = 22;
        
        public const int AF_IRDA = 23;
        
        public const int AF_PPPOX = 24;
        
        public const int AF_WANPIPE = 25;
        
        public const int AF_LLC = 26;
        
        public const int AF_IB = 27;
        
        public const int AF_MPLS = 28;
        
        public const int AF_CAN = 29;
        
        public const int AF_TIPC = 30;
        
        public const int AF_BLUETOOTH = 31;
        
        public const int AF_IUCV = 32;
        
        public const int AF_RXRPC = 33;
        
        public const int AF_ISDN = 34;
        
        public const int AF_PHONET = 35;
        
        public const int AF_IEEE802154 = 36;
        
        public const int AF_CAIF = 37;
        
        public const int AF_ALG = 38;
        
        public const int AF_NFC = 39;
        
        public const int AF_VSOCK = 40;
        
        public const int AF_KCM = 41;
        
        public const int AF_QIPCRTR = 42;
        
        public const int AF_SMC = 43;
        
        public const int AF_XDP = 44;
        
        public const int AF_MAX = 45;
        
        public const int SO_DEBUG = 1;
        
        public const int SO_REUSEADDR = 2;
        
        public const int SO_TYPE = 3;
        
        public const int SO_ERROR = 4;
        
        public const int SO_DONTROUTE = 5;
        
        public const int SO_BROADCAST = 6;
        
        public const int SO_SNDBUF = 7;
        
        public const int SO_RCVBUF = 8;
        
        public const int SO_KEEPALIVE = 9;
        
        public const int SO_OOBINLINE = 10;
        
        public const int SO_NO_CHECK = 11;
        
        public const int SO_PRIORITY = 12;
        
        public const int SO_LINGER = 13;
        
        public const int SO_BSDCOMPAT = 14;
        
        public const int SO_REUSEPORT = 15;
        
        public const int SO_PASSCRED = 16;
        
        public const int SO_PEERCRED = 17;
        
        public const int SO_RCVLOWAT = 18;
        
        public const int SO_SNDLOWAT = 19;
        
        public const int SO_ACCEPTCONN = 30;
        
        public const int SO_PEERSEC = 31;
        
        public const int SO_SNDBUFFORCE = 32;
        
        public const int SO_RCVBUFFORCE = 33;
        
        public const int SO_PROTOCOL = 38;
        
        public const int SO_DOMAIN = 39;
        
        public const int SO_RCVTIMEO = 20;
        
        public const int SO_SNDTIMEO = 21;
        
        public const int SO_TIMESTAMP = 29;
        
        public const int SO_TIMESTAMPNS = 35;
        
        public const int SO_TIMESTAMPING = 37;
        
        public const int SO_SECURITY_AUTHENTICATION = 22;
        
        public const int SO_SECURITY_ENCRYPTION_TRANSPORT = 23;
        
        public const int SO_SECURITY_ENCRYPTION_NETWORK = 24;
        
        public const int SO_BINDTODEVICE = 25;
        
        public const int SO_ATTACH_FILTER = 26;
        
        public const int SO_DETACH_FILTER = 27;
        
        public const int SO_GET_FILTER = 26;
        
        public const int SO_PEERNAME = 28;
        
        public const int SCM_TIMESTAMP = 29;
        
        public const int SO_PASSSEC = 34;
        
        public const int SCM_TIMESTAMPNS = 35;
        
        public const int SO_MARK = 36;
        
        public const int SCM_TIMESTAMPING = 37;
        
        public const int SO_RXQ_OVFL = 40;
        
        public const int SO_WIFI_STATUS = 41;
        
        public const int SCM_WIFI_STATUS = 41;
        
        public const int SO_PEEK_OFF = 42;
        
        public const int SO_NOFCS = 43;
        
        public const int SO_LOCK_FILTER = 44;
        
        public const int SO_SELECT_ERR_QUEUE = 45;
        
        public const int SO_BUSY_POLL = 46;
        
        public const int SO_MAX_PACING_RATE = 47;
        
        public const int SO_BPF_EXTENSIONS = 48;
        
        public const int SO_INCOMING_CPU = 49;
        
        public const int SO_ATTACH_BPF = 50;
        
        public const int SO_DETACH_BPF = 27;
        
        public const int SO_ATTACH_REUSEPORT_CBPF = 51;
        
        public const int SO_ATTACH_REUSEPORT_EBPF = 52;
        
        public const int SO_CNX_ADVICE = 53;
        
        public const int SCM_TIMESTAMPING_OPT_STATS = 54;
        
        public const int SO_MEMINFO = 55;
        
        public const int SO_INCOMING_NAPI_ID = 56;
        
        public const int SO_COOKIE = 57;
        
        public const int SCM_TIMESTAMPING_PKTINFO = 58;
        
        public const int SO_PEERGROUPS = 59;
        
        public const int SO_ZEROCOPY = 60;
        
        public const int SO_TXTIME = 61;
        
        public const int SCM_TXTIME = 61;
        
        public const int SO_BINDTOIFINDEX = 62;
        
        public const int SO_DETACH_REUSEPORT_BPF = 68;
        
        public const int SO_PREFER_BUSY_POLL = 69;
        
        public const int SO_BUSY_POLL_BUDGET = 70;
        
        public const int SOL_SOCKET = 1;
        
        public const int SOL_IP = 0;
        
        public const int SOL_IPV6 = 41;
        
        public const int SOL_ICMPV6 = 58;
        
        public const int SOL_RAW = 255;
        
        public const int SOL_DECNET = 261;
        
        public const int SOL_X25 = 262;
        
        public const int SOL_PACKET = 263;
        
        public const int SOL_ATM = 264;
        
        public const int SOL_AAL = 265;
        
        public const int SOL_IRDA = 266;
        
        public const int SOL_NETBEUI = 267;
        
        public const int SOL_LLC = 268;
        
        public const int SOL_DCCP = 269;
        
        public const int SOL_NETLINK = 270;
        
        public const int SOL_TIPC = 271;
        
        public const int SOL_RXRPC = 272;
        
        public const int SOL_PPPOL2TP = 273;
        
        public const int SOL_BLUETOOTH = 274;
        
        public const int SOL_PNPIPE = 275;
        
        public const int SOL_RDS = 276;
        
        public const int SOL_IUCV = 277;
        
        public const int SOL_CAIF = 278;
        
        public const int SOL_ALG = 279;
        
        public const int SOL_NFC = 280;
        
        public const int SOL_KCM = 281;
        
        public const int SOL_TLS = 282;
        
        public const int SOL_XDP = 283;
        
        public const int SOMAXCONN = 128;
        
        /// <summary>
        /// This flag requests receipt of out-of-band data that would not be received
        /// in the normal data stream.
        /// Some protocols place expedited data
        /// at the head of the normal data queue, and thus this flag cannot
        /// be used with such protocols.
        /// </summary>
        public const int MSG_OOB = 1;
        
        /// <summary>
        /// This flag causes the receive operation to
        /// return data from the beginning of the
        /// receive queue without removing that data from the queue.
        /// Thus, a
        /// subsequent receive call will return the same data.
        /// </summary>
        public const int MSG_PEEK = 2;
        
        /// <summary>
        /// Don't use a gateway to send out the packet, send to hosts only on
        /// directly connected networks.
        /// This is usually used only
        /// by diagnostic or routing programs.
        /// This is defined only for protocol
        /// families that route; packet sockets don't.
        /// </summary>
        public const int MSG_DONTROUTE = 4;
        
        /// <summary>
        /// indicates that some control data was discarded due to lack of space in the
        /// buffer for ancillary data.
        /// </summary>
        public const int MSG_CTRUNC = 8;
        
        public const int MSG_PROXY = 16;
        
        /// <summary>
        /// indicates that the trailing portion of a datagram was discarded because the
        /// datagram was larger than the buffer supplied.
        /// </summary>
        public const int MSG_TRUNC = 32;
        
        public const int MSG_DONTWAIT = 64;
        
        /// <summary>
        /// indicates end-of-record; the data returned completed a record (generally
        /// used with sockets of type
        /// SOCK_SEQPACKET ).
        /// </summary>
        public const int MSG_EOR = 128;
        
        public const int MSG_WAITALL = 256;
        
        public const int MSG_FIN = 512;
        
        public const int MSG_SYN = 1024;
        
        public const int MSG_CONFIRM = 2048;
        
        public const int MSG_RST = 4096;
        
        /// <summary>
        /// indicates that no data was received but an extended error from the socket
        /// error queue.
        /// </summary>
        public const int MSG_ERRQUEUE = 8192;
        
        public const int MSG_NOSIGNAL = 16384;
        
        public const int MSG_MORE = 32768;
        
        public const int MSG_WAITFORONE = 65536;
        
        public const int MSG_BATCH = 262144;
        
        public const int MSG_ZEROCOPY = 67108864;
        
        public const int MSG_FASTOPEN = 536870912;
        
        public const int MSG_CMSG_CLOEXEC = 1073741824;
        
        public const int SCM_RIGHTS = 1;
        
        public const int SCM_CREDENTIALS = 2;
        
        /// <summary>
        /// Send multiple messages on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sendmmsg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sendmmsg(int sockfd, ref musl.mmsghdr msgvec, uint vlen, uint flags);
        
        /// <summary>
        /// Receive multiple messages on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "recvmmsg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int recvmmsg(int sockfd, ref musl.mmsghdr msgvec, uint vlen, uint flags, ref musl.timespec timeout);
        
        /// <summary>
        /// Create an endpoint for communication
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "socket")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int socket(int domain, int type, int protocol);
        
        /// <summary>
        /// Create a pair of connected sockets
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "socketpair")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int socketpair(int domain, int type, int protocol, FixedArray2<int> sv);
        
        /// <summary>
        /// Shut down part of a full-duplex connection
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shutdown")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int shutdown(int sockfd, int how);
        
        /// <summary>
        /// Bind a name to a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "bind")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int bind(int sockfd, in musl.sockaddr addr, musl.socklen_t addrlen);
        
        /// <summary>
        /// Initiate a connection on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "connect")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int connect(int sockfd, in musl.sockaddr addr, musl.socklen_t addrlen);
        
        /// <summary>
        /// Listen for connections on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "listen")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int listen(int sockfd, int backlog);
        
        /// <summary>
        /// Accept a connection on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "accept")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int accept(int sockfd, ref musl.sockaddr addr, ref musl.socklen_t addrlen);
        
        /// <summary>
        /// Accept a connection on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "accept4")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int accept4(int sockfd, ref musl.sockaddr addr, ref musl.socklen_t addrlen, int flags);
        
        /// <summary>
        /// Get socket name
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getsockname")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getsockname(int sockfd, ref musl.sockaddr addr, ref musl.socklen_t addrlen);
        
        /// <summary>
        /// Get name of connected peer socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getpeername")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getpeername(int sockfd, ref musl.sockaddr addr, ref musl.socklen_t addrlen);
        
        /// <summary>
        /// Send a message on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "send")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint send(int sockfd, void* buf, nuint len, int flags);
        
        /// <summary>
        /// Receive a message from a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "recv")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint recv(int sockfd, void* buf, nuint len, int flags);
        
        /// <summary>
        /// Send a message on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sendto")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint sendto(int sockfd, void* buf, nuint len, int flags, in musl.sockaddr dest_addr, musl.socklen_t addrlen);
        
        /// <summary>
        /// Receive a message from a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "recvfrom")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint recvfrom(int sockfd, void* buf, nuint len, int flags, ref musl.sockaddr src_addr, ref musl.socklen_t addrlen);
        
        /// <summary>
        /// Send a message on a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sendmsg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint sendmsg(int sockfd, in musl.msghdr msg, int flags);
        
        /// <summary>
        /// Receive a message from a socket
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "recvmsg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nint recvmsg(int sockfd, ref musl.msghdr msg, int flags);
        
        /// <summary>
        /// Get and set options on sockets
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "getsockopt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int getsockopt(int sockfd, int level, int optname, void* optval, ref musl.socklen_t optlen);
        
        /// <summary>
        /// Get and set options on sockets
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "setsockopt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int setsockopt(int sockfd, int level, int optname, void* optval, musl.socklen_t optlen);
        
        /// <summary>
        /// Determine whether socket is at out-of-band mark
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sockatmark")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sockatmark(int sockfd);
    }
}
