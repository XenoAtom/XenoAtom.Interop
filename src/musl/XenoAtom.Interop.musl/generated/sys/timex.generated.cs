//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct ntptimeval
        {
            public musl.timeval time;
            
            public nint maxerror;
            
            public nint esterror;
        }
        
        public unsafe partial struct timex
        {
            public uint modes;
            
            public nint offset;
            
            public nint freq;
            
            public nint maxerror;
            
            public nint esterror;
            
            public int status;
            
            public nint constant;
            
            public nint precision;
            
            public nint tolerance;
            
            public musl.timeval time;
            
            public nint tick;
            
            public nint ppsfreq;
            
            public nint jitter;
            
            public int shift;
            
            public nint stabil;
            
            public nint jitcnt;
            
            public nint calcnt;
            
            public nint errcnt;
            
            public nint stbcnt;
            
            public int tai;
            
            public fixed int __padding[11];
        }
        
        /// <summary>
        /// Set time offset from
        /// buf.offset .
        /// Since Linux 2.6.26,
        /// commit 074b3b87941c99bc0ce35385b5817924b1ed0c23
        /// the supplied value is clamped to the range (\-0.5s, +0.5s).
        /// In older kernels, an
        /// EINVAL
        /// error occurs if the supplied value is out of range.
        /// </summary>
        public const int ADJ_OFFSET = 1;
        
        /// <summary>
        /// Set frequency offset from
        /// buf.freq .
        /// Since Linux 2.6.26,
        /// commit 074b3b87941c99bc0ce35385b5817924b1ed0c23
        /// the supplied value is clamped to the range (\-32768000, +32768000).
        /// In older kernels, an
        /// EINVAL
        /// error occurs if the supplied value is out of range.
        /// </summary>
        public const int ADJ_FREQUENCY = 2;
        
        /// <summary>
        /// Set maximum time error from
        /// buf.maxerror .
        /// </summary>
        public const int ADJ_MAXERROR = 4;
        
        /// <summary>
        /// Set estimated time error from
        /// buf.esterror .
        /// </summary>
        public const int ADJ_ESTERROR = 8;
        
        /// <summary>
        /// Set clock status bits from
        /// buf.status .
        /// A description of these bits is provided below.
        /// </summary>
        public const int ADJ_STATUS = 16;
        
        /// <summary>
        /// Set PLL time constant from
        /// buf.constant .
        /// If the
        /// STA_NANO
        /// status flag (see below) is clear, the kernel adds 4 to this value.
        /// </summary>
        public const int ADJ_TIMECONST = 32;
        
        public const int ADJ_TAI = 128;
        
        public const int ADJ_SETOFFSET = 256;
        
        public const int ADJ_MICRO = 4096;
        
        public const int ADJ_NANO = 8192;
        
        /// <summary>
        /// Set tick value from
        /// buf.tick .
        /// 
        /// Alternatively,
        /// modes
        /// can be specified as either of the following (multibit mask) values,
        /// in which case other bits should not be specified in
        /// modes :
        /// In general, the other bits are ignored, but ADJ_OFFSET_SINGLESHOT 0x8001
        /// ORed with ADJ_NANO (0x2000) gives 0xa0001 == ADJ_OFFSET_SS_READ!!
        /// </summary>
        public const int ADJ_TICK = 16384;
        
        /// <summary>
        /// In user space, ADJ_OFFSET_SINGLESHOT is 0x8001
        /// In kernel space it is 0x0001, and must be ANDed with ADJ_ADJTIME (0x8000)
        /// Old-fashioned
        /// adjtime (3):
        /// (gradually) adjust time by value specified in
        /// buf.offset ,
        /// which specifies an adjustment in microseconds.
        /// </summary>
        public const int ADJ_OFFSET_SINGLESHOT = 32769;
        
        public const int ADJ_OFFSET_SS_READ = 40961;
        
        public const int MOD_OFFSET = 1;
        
        public const int MOD_FREQUENCY = 2;
        
        public const int MOD_MAXERROR = 4;
        
        public const int MOD_ESTERROR = 8;
        
        public const int MOD_STATUS = 16;
        
        public const int MOD_TIMECONST = 32;
        
        public const int MOD_CLKB = 16384;
        
        public const int MOD_CLKA = 32769;
        
        public const int MOD_TAI = 128;
        
        public const int MOD_MICRO = 4096;
        
        public const int MOD_NANO = 8192;
        
        public const int STA_PLL = 1;
        
        public const int STA_PPSFREQ = 2;
        
        public const int STA_PPSTIME = 4;
        
        public const int STA_FLL = 8;
        
        public const int STA_INS = 16;
        
        public const int STA_DEL = 32;
        
        public const int STA_UNSYNC = 64;
        
        public const int STA_FREQHOLD = 128;
        
        public const int STA_PPSSIGNAL = 256;
        
        public const int STA_PPSJITTER = 512;
        
        public const int STA_PPSWANDER = 1024;
        
        public const int STA_PPSERROR = 2048;
        
        public const int STA_CLOCKERR = 4096;
        
        public const int STA_NANO = 8192;
        
        public const int STA_MODE = 16384;
        
        public const int STA_CLK = 32768;
        
        public const int STA_RONLY = 65280;
        
        /// <summary>
        /// Clock synchronized, no leap second adjustment pending.
        /// </summary>
        public const int TIME_OK = 0;
        
        /// <summary>
        /// Indicates that a leap second will be added at the end of the UTC day.
        /// </summary>
        public const int TIME_INS = 1;
        
        /// <summary>
        /// Indicates that a leap second will be deleted at the end of the UTC day.
        /// </summary>
        public const int TIME_DEL = 2;
        
        /// <summary>
        /// Insertion of a leap second is in progress.
        /// </summary>
        public const int TIME_OOP = 3;
        
        /// <summary>
        /// A leap-second insertion or deletion has been completed.
        /// This value will be returned until the next
        /// ADJ_STATUS
        /// operation clears the
        /// STA_INS
        /// and
        /// STA_DEL
        /// flags.
        /// </summary>
        public const int TIME_WAIT = 4;
        
        /// <summary>
        /// The system clock is not synchronized to a reliable server.
        /// This value is returned when any of the following holds true:
        /// \[bu] 3
        /// Either
        /// STA_UNSYNC
        /// or
        /// STA_CLOCKERR
        /// is set.
        /// \[bu]
        /// STA_PPSSIGNAL
        /// is clear and either
        /// STA_PPSFREQ
        /// or
        /// STA_PPSTIME
        /// is set.
        /// \[bu]
        /// STA_PPSTIME
        /// and
        /// STA_PPSJITTER
        /// are both set.
        /// \[bu]
        /// STA_PPSFREQ
        /// is set and either
        /// STA_PPSWANDER
        /// or
        /// STA_PPSJITTER
        /// is set.
        /// 
        /// The symbolic name
        /// TIME_BAD
        /// is a synonym for
        /// TIME_ERROR ,
        /// provided for backward compatibility.
        /// 
        /// Note that starting with Linux 3.4,
        /// commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d changed to asynchronous
        /// operation, so we can no longer rely on the return code.
        /// the call operates asynchronously and the return value usually will
        /// not reflect a state change caused by the call itself.
        /// 
        /// On failure, these calls return \-1 and set
        /// errno
        /// to indicate the error.
        /// </summary>
        public const int TIME_ERROR = 5;
        
        public const int TIME_BAD = 5;
        
        public const int MAXTC = 6;
        
        /// <summary>
        /// Tune kernel clock
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "adjtimex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int adjtimex(ref musl.timex buf);
        
        /// <summary>
        /// Tune kernel clock
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "clock_adjtime")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int clock_adjtime(musl.clockid_t clk_id, ref musl.timex buf);
    }
}
