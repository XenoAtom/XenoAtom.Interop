//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public const int BLKROSET = 4701;
        
        public const int BLKROGET = 4702;
        
        public const int BLKRRPART = 4703;
        
        public const int BLKGETSIZE = 4704;
        
        public const int BLKFLSBUF = 4705;
        
        public const int BLKRASET = 4706;
        
        public const int BLKRAGET = 4707;
        
        public const int BLKFRASET = 4708;
        
        public const int BLKFRAGET = 4709;
        
        public const int BLKSECTSET = 4710;
        
        public const int BLKSECTGET = 4711;
        
        public const int BLKSSZGET = 4712;
        
        public const int BLKBSZGET = -2146954640;
        
        public const int BLKBSZSET = 1074270833;
        
        public const int BLKGETSIZE64 = -2146954638;
        
        /// <summary>
        /// Mount filesystem read-only.
        /// </summary>
        public const int MS_RDONLY = 1;
        
        /// <summary>
        /// Do not honor set-user-ID and set-group-ID bits or file capabilities
        /// when executing programs from this filesystem.
        /// In addition, SELinux domain
        /// transitions require the permission
        /// nosuid_transition ,
        /// which in turn needs
        /// also the policy capability
        /// nnp_nosuid_transition .
        /// (This is a security feature to prevent users executing set-user-ID and
        /// set-group-ID programs from removable disk devices.)
        /// </summary>
        public const int MS_NOSUID = 2;
        
        /// <summary>
        /// Do not allow access to devices (special files) on this filesystem.
        /// </summary>
        public const int MS_NODEV = 4;
        
        /// <summary>
        /// Do not allow programs to be executed from this filesystem.
        /// (Possibly useful for a filesystem that contains non-Linux executables.
        /// Often used as a security feature, e.g., to make sure that restricted
        /// users cannot execute files uploaded using ftp or so.)
        /// </summary>
        public const int MS_NOEXEC = 8;
        
        /// <summary>
        /// Make writes on this filesystem synchronous (as though
        /// the
        /// O_SYNC
        /// flag to
        /// open (2)
        /// was specified for all file opens to this filesystem).
        /// </summary>
        public const int MS_SYNCHRONOUS = 16;
        
        public const int MS_REMOUNT = 32;
        
        /// <summary>
        /// Permit mandatory locking on files in this filesystem.
        /// (Mandatory locking must still be enabled on a per-file basis,
        /// as described in
        /// fcntl (2).)
        /// Since Linux 4.5,
        /// commit 95ace75414f312f9a7b93d873f386987b92a5301
        /// this mount option requires the
        /// CAP_SYS_ADMIN
        /// capability and a kernel configured with the
        /// CONFIG_MANDATORY_FILE_LOCKING
        /// option.
        /// Mandatory locking has been fully deprecated in Linux 5.15, so
        /// this flag should be considered deprecated.
        /// </summary>
        public const int MS_MANDLOCK = 64;
        
        public const int MS_DIRSYNC = 128;
        
        public const int MS_NOSYMFOLLOW = 256;
        
        /// <summary>
        /// Do not update access times for (all types of) files on this filesystem.
        /// </summary>
        public const int MS_NOATIME = 1024;
        
        /// <summary>
        /// Do not update access times for directories on this filesystem.
        /// This flag provides a subset of the functionality provided by
        /// MS_NOATIME ;
        /// that is,
        /// MS_NOATIME
        /// implies
        /// MS_NODIRATIME .
        /// </summary>
        public const int MS_NODIRATIME = 2048;
        
        public const int MS_BIND = 4096;
        
        public const int MS_MOVE = 8192;
        
        public const int MS_REC = 16384;
        
        public const int MS_SILENT = 32768;
        
        public const int MS_POSIXACL = 65536;
        
        /// <summary>
        /// Make this mount unbindable.
        /// This is like a private mount,
        /// and in addition this mount can't be bind mounted.
        /// When a recursive bind mount
        /// ( mount ()
        /// with the
        /// MS_BIND
        /// and
        /// MS_REC
        /// flags) is performed on a directory subtree,
        /// any unbindable mounts within the subtree are automatically pruned
        /// (i.e., not replicated)
        /// when replicating that subtree to produce the target subtree.
        /// 
        /// By default, changing the propagation type affects only the
        /// target
        /// mount.
        /// If the
        /// MS_REC
        /// flag is also specified in
        /// mountflags ,
        /// then the propagation type of all mounts under
        /// target
        /// is also changed.
        /// 
        /// For further details regarding mount propagation types
        /// (including the default propagation type assigned to new mounts), see
        /// mount_namespaces (7).
        /// </summary>
        public const int MS_UNBINDABLE = 131072;
        
        /// <summary>
        /// Make this mount private.
        /// Mount and unmount events do not propagate into or out of this mount.
        /// </summary>
        public const int MS_PRIVATE = 262144;
        
        /// <summary>
        /// If this is a shared mount that is a member of a peer group
        /// that contains other members, convert it to a slave mount.
        /// If this is a shared mount that is a member of a peer group
        /// that contains no other members, convert it to a private mount.
        /// Otherwise, the propagation type of the mount is left unchanged.
        /// 
        /// When a mount is a slave,
        /// mount and unmount events propagate into this mount from
        /// the (master) shared peer group of which it was formerly a member.
        /// Mount and unmount events under this mount do not propagate to any peer.
        /// 
        /// A mount can be the slave of another peer group
        /// while at the same time sharing mount and unmount events
        /// with a peer group of which it is a member.
        /// </summary>
        public const int MS_SLAVE = 524288;
        
        /// <summary>
        /// Make this mount shared.
        /// Mount and unmount events immediately under this mount will propagate
        /// to the other mounts that are members of this mount's peer group.
        /// Propagation here means that the same mount or unmount will automatically
        /// occur under all of the other mounts in the peer group.
        /// Conversely, mount and unmount events that take place under
        /// peer mounts will propagate to this mount.
        /// </summary>
        public const int MS_SHARED = 1048576;
        
        public const int MS_RELATIME = 2097152;
        
        public const int MS_KERNMOUNT = 4194304;
        
        public const int MS_I_VERSION = 8388608;
        
        public const int MS_STRICTATIME = 16777216;
        
        public const int MS_LAZYTIME = 33554432;
        
        public const int MS_NOREMOTELOCK = 134217728;
        
        public const int MS_NOSEC = 268435456;
        
        public const int MS_BORN = 536870912;
        
        public const int MS_ACTIVE = 1073741824;
        
        public const int MS_NOUSER = -2147483648;
        
        public const int MS_RMT_MASK = 41943121;
        
        public const int MS_MGC_VAL = -1058209792;
        
        public const int MS_MGC_MSK = -65536;
        
        /// <summary>
        /// Mount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "mount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int mount(byte* source, byte* target, byte* filesystemtype, nuint mountflags, void* data);
        
        /// <summary>
        /// Mount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "mount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int mount([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> source, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> target, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> filesystemtype, nuint mountflags, void* data);
        
        /// <summary>
        /// Unmount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "umount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int umount(byte* target);
        
        /// <summary>
        /// Unmount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "umount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int umount([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> target);
        
        /// <summary>
        /// Unmount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "umount2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int umount2(byte* target, int flags);
        
        /// <summary>
        /// Unmount filesystem
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "umount2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int umount2([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> target, int flags);
    }
}
