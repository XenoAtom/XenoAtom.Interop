//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public readonly partial struct shmatt_t : IEquatable<musl.shmatt_t>
        {
            public shmatt_t(nuint value) => this.Value = value;
            
            public nuint Value { get; }
            
            public override bool Equals(object obj) => obj is shmatt_t other && Equals(other);
            
            public bool Equals(shmatt_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator nuint (musl.shmatt_t from) => from.Value;
            
            public static implicit operator musl.shmatt_t (nuint from) => new musl.shmatt_t(from);
            
            public static bool operator ==(shmatt_t left, shmatt_t right) => left.Equals(right);
            
            public static bool operator !=(shmatt_t left, shmatt_t right) => !left.Equals(right);
        }
        
        public const int SHM_R = 256;
        
        public const int SHM_W = 128;
        
        /// <summary>
        /// Attach the segment for read-only access.
        /// The process must have read permission for the segment.
        /// If this flag is not specified,
        /// the segment is attached for read and write access,
        /// and the process must have read and write permission for the segment.
        /// There is no notion of a write-only shared memory segment.
        /// </summary>
        public const int SHM_RDONLY = 4096;
        
        public const int SHM_RND = 8192;
        
        public const int SHM_REMAP = 16384;
        
        public const int SHM_EXEC = 32768;
        
        public const int SHM_LOCK = 11;
        
        public const int SHM_UNLOCK = 12;
        
        public const int SHM_STAT = 13;
        
        public const int SHM_INFO = 14;
        
        public const int SHM_STAT_ANY = 15;
        
        public const int SHM_DEST = 512;
        
        public const int SHM_LOCKED = 1024;
        
        public const int SHM_HUGETLB = 2048;
        
        public const int SHM_NORESERVE = 4096;
        
        public const int SHM_HUGE_SHIFT = 26;
        
        public const int SHM_HUGE_MASK = 63;
        
        public const int SHM_HUGE_64KB = 1073741824;
        
        public const int SHM_HUGE_512KB = 1275068416;
        
        public const int SHM_HUGE_1MB = 1342177280;
        
        /// <summary>
        /// SHM_HUGE_1GB " (since Linux 3.8)"
        /// See https://lwn.net/Articles/533499/
        /// Used in conjunction with
        /// SHM_HUGETLB
        /// to select alternative hugetlb page sizes (respectively, 2\ MB and 1\ GB)
        /// on systems that support multiple hugetlb page sizes.
        /// 
        /// More generally, the desired huge page size can be configured by encoding
        /// the base-2 logarithm of the desired page size in the six bits at the offset
        /// SHM_HUGE_SHIFT .
        /// Thus, the above two constants are defined as:
        /// 
        /// +4n
        /// 
        /// #define SHM_HUGE_2MB    (21 &lt;&lt; SHM_HUGE_SHIFT)
        /// #define SHM_HUGE_1GB    (30 &lt;&lt; SHM_HUGE_SHIFT)
        /// 
        /// 
        /// 
        /// For some additional details,
        /// see the discussion of the similarly named constants in
        /// mmap (2).
        /// </summary>
        public const int SHM_HUGE_2MB = 1409286144;
        
        public const int SHM_HUGE_8MB = 1543503872;
        
        public const int SHM_HUGE_16MB = 1610612736;
        
        public const int SHM_HUGE_32MB = 1677721600;
        
        public const int SHM_HUGE_256MB = 1879048192;
        
        public const int SHM_HUGE_512MB = 1946157056;
        
        public const int SHM_HUGE_1GB = 2013265920;
        
        public const int SHM_HUGE_2GB = 2080374784;
        
        public const int SHM_HUGE_16GB = -2013265920;
        
        /// <summary>
        /// System V shared memory operations
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shmat")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* shmat(int shmid, void* shmaddr, int shmflg);
        
        /// <summary>
        /// System V shared memory control
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shmctl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int shmctl(int shmid, int cmd, ref musl.shmid_ds buf);
        
        /// <summary>
        /// System V shared memory operations
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shmdt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int shmdt(void* shmaddr);
        
        /// <summary>
        /// Allocates a System V shared memory segment
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "shmget")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int shmget(musl.key_t key, nuint size, int shmflg);
    }
}
