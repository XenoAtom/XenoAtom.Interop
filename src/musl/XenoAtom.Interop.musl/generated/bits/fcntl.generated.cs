//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    public static unsafe partial class musl
    {
        /// <summary>
        /// If
        /// pathname
        /// does not exist, create it as a regular file.
        /// 
        /// The owner (user ID) of the new file is set to the effective user ID
        /// of the process.
        /// 
        /// The group ownership (group ID) of the new file is set either to
        /// the effective group ID of the process (System V semantics)
        /// or to the group ID of the parent directory (BSD semantics).
        /// On Linux, the behavior depends on whether the
        /// set-group-ID mode bit is set on the parent directory:
        /// if that bit is set, then BSD semantics apply;
        /// otherwise, System V semantics apply.
        /// For some filesystems, the behavior also depends on the
        /// bsdgroups
        /// and
        /// sysvgroups
        /// mount options described in
        /// mount (8).
        /// As at Linux 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
        /// XFS (since Linux 2.6.14).
        /// 
        /// The
        /// mode
        /// argument specifies the file mode bits to be applied when a new file is created.
        /// If neither
        /// O_CREAT
        /// nor
        /// O_TMPFILE
        /// is specified in
        /// flags ,
        /// then
        /// mode
        /// is ignored (and can thus be specified as 0, or simply omitted).
        /// The
        /// mode
        /// argument
        /// must
        /// be supplied if
        /// O_CREAT
        /// or
        /// O_TMPFILE
        /// is specified in
        /// flags ;
        /// if it is not supplied,
        /// some arbitrary bytes from the stack will be applied as the file mode.
        /// 
        /// The effective mode is modified by the process's
        /// umask
        /// in the usual way: in the absence of a default ACL, the mode of the
        /// created file is
        /// "(mode\ &amp;\ \[ti]umask)" .
        /// 
        /// Note that
        /// mode
        /// applies only to future accesses of the
        /// newly created file; the
        /// open ()
        /// call that creates a read-only file may well return a read/write
        /// file descriptor.
        /// 
        /// The following symbolic constants are provided for
        /// mode :
        /// S_IRWXU
        /// 00700 user (file owner) has read, write, and execute permission
        /// S_IRUSR
        /// 00400 user has read permission
        /// S_IWUSR
        /// 00200 user has write permission
        /// S_IXUSR
        /// 00100 user has execute permission
        /// S_IRWXG
        /// 00070 group has read, write, and execute permission
        /// S_IRGRP
        /// 00040 group has read permission
        /// S_IWGRP
        /// 00020 group has write permission
        /// S_IXGRP
        /// 00010 group has execute permission
        /// S_IRWXO
        /// 00007 others have read, write, and execute permission
        /// S_IROTH
        /// 00004 others have read permission
        /// S_IWOTH
        /// 00002 others have write permission
        /// S_IXOTH
        /// 00001 others have execute permission
        /// 
        /// According to POSIX, the effect when other bits are set in
        /// mode
        /// is unspecified.
        /// On Linux, the following bits are also honored in
        /// mode :
        /// S_ISUID
        /// 0004000 set-user-ID bit
        /// S_ISGID
        /// 0002000 set-group-ID bit (see
        /// inode (7)).
        /// S_ISVTX
        /// 0001000 sticky bit (see
        /// inode (7)).
        /// </summary>
        public const int O_CREAT = 64;
        
        /// <summary>
        /// Ensure that this call creates the file:
        /// if this flag is specified in conjunction with
        /// O_CREAT ,
        /// and
        /// pathname
        /// already exists, then
        /// open ()
        /// fails with the error
        /// EEXIST .
        /// 
        /// When these two flags are specified, symbolic links are not followed:
        /// POSIX.1-2001 explicitly requires this behavior.
        /// if
        /// pathname
        /// is a symbolic link, then
        /// open ()
        /// fails regardless of where the symbolic link points.
        /// 
        /// In general, the behavior of
        /// O_EXCL
        /// is undefined if it is used without
        /// O_CREAT .
        /// There is one exception: on Linux 2.6 and later,
        /// O_EXCL
        /// can be used without
        /// O_CREAT
        /// if
        /// pathname
        /// refers to a block device.
        /// If the block device is in use by the system (e.g., mounted),
        /// open ()
        /// fails with the error
        /// EBUSY .
        /// 
        /// On NFS,
        /// O_EXCL
        /// is supported only when using NFSv3 or later on kernel 2.6 or later.
        /// In NFS environments where
        /// O_EXCL
        /// support is not provided, programs that rely on it
        /// for performing locking tasks will contain a race condition.
        /// Portable programs that want to perform atomic file locking using a lockfile,
        /// and need to avoid reliance on NFS support for
        /// O_EXCL ,
        /// can create a unique file on
        /// the same filesystem (e.g., incorporating hostname and PID), and use
        /// link (2)
        /// to make a link to the lockfile.
        /// If
        /// link (2)
        /// returns 0, the lock is successful.
        /// Otherwise, use
        /// stat (2)
        /// on the unique file to check if its link count has increased to 2,
        /// in which case the lock is also successful.
        /// </summary>
        public const int O_EXCL = 128;
        
        /// <summary>
        /// If
        /// pathname
        /// refers to a terminal device\[em]see
        /// tty (4)\[em]it
        /// will not become the process's controlling terminal even if the
        /// process does not have one.
        /// </summary>
        public const int O_NOCTTY = 256;
        
        /// <summary>
        /// If the file already exists and is a regular file and the access mode allows
        /// writing (i.e., is
        /// O_RDWR
        /// or
        /// O_WRONLY )
        /// it will be truncated to length 0.
        /// If the file is a FIFO or terminal device file, the
        /// O_TRUNC
        /// flag is ignored.
        /// Otherwise, the effect of
        /// O_TRUNC
        /// is unspecified.
        /// </summary>
        public const int O_TRUNC = 512;
        
        /// <summary>
        /// The file is opened in append mode.
        /// Before each
        /// write (2),
        /// the file offset is positioned at the end of the file,
        /// as if with
        /// lseek (2).
        /// The modification of the file offset and the write operation
        /// are performed as a single atomic step.
        /// 
        /// O_APPEND
        /// may lead to corrupted files on NFS filesystems if more than one process
        /// appends data to a file at once.
        /// For more background, see
        /// http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
        /// http://nfs.sourceforge.net/
        /// This is because NFS does not support
        /// appending to a file, so the client kernel has to simulate it, which
        /// can't be done without a race condition.
        /// </summary>
        public const int O_APPEND = 1024;
        
        /// <summary>
        /// Set the
        /// O_NONBLOCK
        /// file status flag on the open file descriptions
        /// referred to by the new file descriptors.
        /// Using this flag saves extra calls to
        /// fcntl (2)
        /// to achieve the same result.
        /// </summary>
        public const int O_NONBLOCK = 2048;
        
        /// <summary>
        /// Write operations on the file will complete according to the requirements of
        /// synchronized I/O
        /// data
        /// integrity completion.
        /// 
        /// By the time
        /// write (2)
        /// (and similar)
        /// return, the output data
        /// has been transferred to the underlying hardware,
        /// along with any file metadata that would be required to retrieve that data
        /// (i.e., as though each
        /// write (2)
        /// was followed by a call to
        /// fdatasync (2)).
        /// "See NOTES below" .
        /// </summary>
        public const int O_DSYNC = 4096;
        
        /// <summary>
        /// Write operations on the file will complete according to the requirements of
        /// synchronized I/O
        /// file
        /// integrity completion
        /// (by contrast with the
        /// synchronized I/O
        /// data
        /// integrity completion
        /// provided by
        /// O_DSYNC .)
        /// 
        /// By the time
        /// write (2)
        /// (or similar)
        /// returns, the output data and associated file metadata
        /// have been transferred to the underlying hardware
        /// (i.e., as though each
        /// write (2)
        /// was followed by a call to
        /// fsync (2)).
        /// "See NOTES below" .
        /// </summary>
        public const int O_SYNC = 1052672;
        
        public const int O_RSYNC = 1052672;
        
        /// <summary>
        /// Set the close-on-exec
        /// ( FD_CLOEXEC )
        /// flag on the two new file descriptors.
        /// See the description of the same flag in
        /// open (2)
        /// for reasons why this may be useful.
        /// </summary>
        public const int O_CLOEXEC = 524288;
        
        /// <summary>
        /// Enable signal-driven I/O:
        /// generate a signal
        /// ( SIGIO
        /// by default, but this can be changed via
        /// fcntl (2))
        /// when input or output becomes possible on this file descriptor.
        /// This feature is available only for terminals, pseudoterminals,
        /// sockets, and (since Linux 2.6) pipes and FIFOs.
        /// See
        /// fcntl (2)
        /// for further details.
        /// See also BUGS, below.
        /// </summary>
        public const int O_ASYNC = 8192;
        
        public const int O_NOATIME = 262144;
        
        public const int O_PATH = 2097152;
        
        public const int O_NDELAY = 2048;
        
        /// <summary>
        /// The new file descriptor.
        /// </summary>
        public const int F_DUPFD = 0;
        
        /// <summary>
        /// Value of file descriptor flags.
        /// </summary>
        public const int F_GETFD = 1;
        
        public const int F_SETFD = 2;
        
        /// <summary>
        /// Value of file status flags.
        /// </summary>
        public const int F_GETFL = 3;
        
        public const int F_SETFL = 4;
        
        public const int F_SETOWN = 8;
        
        /// <summary>
        /// Value of file descriptor owner.
        /// </summary>
        public const int F_GETOWN = 9;
        
        public const int F_SETSIG = 10;
        
        /// <summary>
        /// Value of signal sent when read or write becomes possible, or zero
        /// for traditional
        /// SIGIO
        /// behavior.
        /// </summary>
        public const int F_GETSIG = 11;
        
        public const int F_GETLK = 5;
        
        public const int F_SETLK = 6;
        
        public const int F_SETLKW = 7;
        
        public const int F_SETOWN_EX = 15;
        
        public const int F_GETOWN_EX = 16;
        
        public const int F_GETOWNER_UIDS = 17;
    }
}
