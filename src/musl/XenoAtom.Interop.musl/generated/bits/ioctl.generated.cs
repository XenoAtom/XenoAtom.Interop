//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    public static unsafe partial class musl
    {
        /// <summary>
        /// Argument:
        /// "struct termios\~*" argp
        /// 
        /// Equivalent to
        /// "tcgetattr(fd, argp)" .
        /// 
        /// Get the current serial port settings.
        /// </summary>
        public const int TCGETS = 21505;
        
        /// <summary>
        /// Argument:
        /// "const struct termios\~*" argp
        /// 
        /// Equivalent to
        /// "tcsetattr(fd, TCSANOW, argp)" .
        /// 
        /// Set the current serial port settings.
        /// </summary>
        public const int TCSETS = 21506;
        
        /// <summary>
        /// Argument:
        /// "const struct termios\~*" argp
        /// 
        /// Equivalent to
        /// "tcsetattr(fd, TCSADRAIN, argp)" .
        /// 
        /// Allow the output buffer to drain, and
        /// set the current serial port settings.
        /// </summary>
        public const int TCSETSW = 21507;
        
        /// <summary>
        /// Argument:
        /// "const struct termios\~*" argp
        /// 
        /// Equivalent to
        /// "tcsetattr(fd, TCSAFLUSH, argp)" .
        /// 
        /// Allow the output buffer to drain, discard pending input, and
        /// set the current serial port settings.
        /// 
        /// The following four ioctls, added in Linux 2.6.20,
        /// commit 64bb6c5e1ddcd47c951740485026ef08975ee2e6
        /// commit 592ee3a5e5e2a981ef2829a0380093006d045661
        /// are just like
        /// TCGETS ,
        /// TCSETS ,
        /// TCSETSW ,
        /// TCSETSF ,
        /// except that they take a
        /// "struct termios2\~*"
        /// instead of a
        /// "struct termios\~*" .
        /// If the structure member
        /// c_cflag
        /// contains the flag
        /// BOTHER ,
        /// then the baud rate is stored in the structure members
        /// c_ispeed
        /// and
        /// c_ospeed
        /// as integer values.
        /// These ioctls are not supported on all architectures.
        /// 
        /// lb l.
        /// TCGETS2	\fBstruct termios2 *\fPargp
        /// TCSETS2	\fBconst struct termios2 *\fPargp
        /// TCSETSW2	\fBconst struct termios2 *\fPargp
        /// TCSETSF2	\fBconst struct termios2 *\fPargp
        /// 
        /// 
        /// The following four ioctls are just like
        /// TCGETS ,
        /// TCSETS ,
        /// TCSETSW ,
        /// TCSETSF ,
        /// except that they take a
        /// "struct termio\~*"
        /// instead of a
        /// "struct termios\~*" .
        /// 
        /// lb l.
        /// TCGETA	\fBstruct termio *\fPargp
        /// TCSETA	\fBconst struct termio *\fPargp
        /// TCSETAW	\fBconst struct termio *\fPargp
        /// TCSETAF	\fBconst struct termio *\fPargp
        /// </summary>
        public const int TCSETSF = 21508;
        
        public const int TCGETA = 21509;
        
        public const int TCSETA = 21510;
        
        public const int TCSETAW = 21511;
        
        public const int TCSETAF = 21512;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// Equivalent to
        /// "tcsendbreak(fd, arg)" .
        /// 
        /// If the terminal is using asynchronous serial data transmission, and
        /// arg
        /// is zero, then send a break (a stream of zero bits) for between
        /// 0.25 and 0.5 seconds.
        /// If the terminal is not using asynchronous
        /// serial data transmission, then either a break is sent, or the function
        /// returns without doing anything.
        /// When
        /// arg
        /// is nonzero, nobody knows what will happen.
        /// 
        /// (SVr4, UnixWare, Solaris, and Linux treat
        /// "tcsendbreak(fd,arg)"
        /// with nonzero
        /// arg
        /// like
        /// "tcdrain(fd)" .
        /// SunOS treats
        /// arg
        /// as a multiplier, and sends a stream of bits
        /// arg
        /// times as long as done for zero
        /// arg .
        /// DG/UX and AIX treat
        /// arg
        /// (when nonzero) as a time interval measured in milliseconds.
        /// HP-UX ignores
        /// arg .)
        /// </summary>
        public const int TCSBRK = 21513;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// Equivalent to
        /// "tcflow(fd, arg)" .
        /// 
        /// See
        /// tcflow (3)
        /// for the argument values
        /// TCOOFF ,
        /// TCOON ,
        /// TCIOFF ,
        /// TCION .
        /// </summary>
        public const int TCXONC = 21514;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// Equivalent to
        /// "tcflush(fd, arg)" .
        /// 
        /// See
        /// tcflush (3)
        /// for the argument values
        /// TCIFLUSH ,
        /// TCOFLUSH ,
        /// TCIOFLUSH .
        /// </summary>
        public const int TCFLSH = 21515;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// Put the terminal into exclusive mode.
        /// No further
        /// open (2)
        /// operations on the terminal are permitted.
        /// (They fail with
        /// EBUSY ,
        /// except for a process with the
        /// CAP_SYS_ADMIN
        /// capability.)
        /// </summary>
        public const int TIOCEXCL = 21516;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// Disable exclusive mode.
        /// </summary>
        public const int TIOCNXCL = 21517;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// Make the given terminal the controlling terminal of the calling process.
        /// The calling process must be a session leader and not have a
        /// controlling terminal already.
        /// For this case,
        /// arg
        /// should be specified as zero.
        /// 
        /// If this terminal is already the controlling terminal
        /// of a different session group, then the ioctl fails with
        /// EPERM ,
        /// unless the caller has the
        /// CAP_SYS_ADMIN
        /// capability and
        /// arg
        /// equals 1, in which case the terminal is stolen, and all processes that had
        /// it as controlling terminal lose it.
        /// </summary>
        public const int TIOCSCTTY = 21518;
        
        /// <summary>
        /// Argument:
        /// "pid_t\~*" argp
        /// 
        /// When successful, equivalent to
        /// "*argp = tcgetpgrp(fd)" .
        /// 
        /// Get the process group ID of the foreground process group on this terminal.
        /// </summary>
        public const int TIOCGPGRP = 21519;
        
        /// <summary>
        /// Argument:
        /// "const pid_t\~*" argp
        /// 
        /// Equivalent to
        /// "tcsetpgrp(fd, *argp)" .
        /// 
        /// Set the foreground process group ID of this terminal.
        /// </summary>
        public const int TIOCSPGRP = 21520;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Get the number of bytes in the output buffer.
        /// </summary>
        public const int TIOCOUTQ = 21521;
        
        /// <summary>
        /// Argument:
        /// "const char\~*" argp
        /// 
        /// Insert the given byte in the input queue.
        /// </summary>
        public const int TIOCSTI = 21522;
        
        /// <summary>
        /// Argument:
        /// "struct winsize\~*" argp
        /// 
        /// Get window size.
        /// </summary>
        public const int TIOCGWINSZ = 21523;
        
        /// <summary>
        /// Argument:
        /// "const struct winsize\~*" argp
        /// 
        /// Set window size.
        /// 
        /// The struct used by these ioctls is defined as
        /// 
        /// +4n
        /// 
        /// struct winsize {
        ///     unsigned short ws_row;
        ///     unsigned short ws_col;
        ///     unsigned short ws_xpixel;   /* unused */
        ///     unsigned short ws_ypixel;   /* unused */
        /// };
        /// 
        /// 
        /// 
        /// When the window size changes, a
        /// SIGWINCH
        /// signal is sent to the
        /// foreground process group.
        /// </summary>
        public const int TIOCSWINSZ = 21524;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Get the status of modem bits.
        /// </summary>
        public const int TIOCMGET = 21525;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// Set the indicated modem bits.
        /// 
        /// The following bits are used by the above ioctls:
        /// 
        /// 
        /// lb l.
        /// TIOCM_LE	DSR (data set ready/line enable)
        /// TIOCM_DTR	DTR (data terminal ready)
        /// TIOCM_RTS	RTS (request to send)
        /// TIOCM_ST	Secondary TXD (transmit)
        /// TIOCM_SR	Secondary RXD (receive)
        /// TIOCM_CTS	CTS (clear to send)
        /// TIOCM_CAR	DCD (data carrier detect)
        /// TIOCM_CD	see TIOCM_CAR
        /// TIOCM_RNG	RNG (ring)
        /// TIOCM_RI	see TIOCM_RNG
        /// TIOCM_DSR	DSR (data set ready)
        /// </summary>
        public const int TIOCMBIS = 21526;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// Clear the indicated modem bits.
        /// </summary>
        public const int TIOCMBIC = 21527;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// Set the status of modem bits.
        /// </summary>
        public const int TIOCMSET = 21528;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// ("Get software carrier flag")
        /// Get the status of the CLOCAL flag in the c_cflag field of the
        /// termios
        /// structure.
        /// </summary>
        public const int TIOCGSOFTCAR = 21529;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// ("Set software carrier flag")
        /// Set the CLOCAL flag in the
        /// termios
        /// structure when
        /// * argp
        /// is nonzero, and clear it otherwise.
        /// 
        /// If the
        /// CLOCAL
        /// flag for a line is off, the hardware carrier detect (DCD)
        /// signal is significant, and an
        /// open (2)
        /// of the corresponding terminal will block until DCD is asserted,
        /// unless the
        /// O_NONBLOCK
        /// flag is given.
        /// If
        /// CLOCAL
        /// is set, the line behaves as if DCD is always asserted.
        /// The software carrier flag is usually turned on for local devices,
        /// and is off for lines with modems.
        /// </summary>
        public const int TIOCSSOFTCAR = 21530;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Get the number of bytes in the input buffer.
        /// </summary>
        public const int FIONREAD = 21531;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Same as
        /// FIONREAD .
        /// </summary>
        public const int TIOCINQ = 21531;
        
        public const int TIOCLINUX = 21532;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// Redirect output that would have gone to
        /// /dev/console
        /// or
        /// /dev/tty0
        /// to the given terminal.
        /// If that was a pseudoterminal master, send it to the slave.
        /// Before Linux 2.6.10,
        /// anybody can do this as long as the output was not redirected yet;
        /// since Linux 2.6.10, only a process with the
        /// CAP_SYS_ADMIN
        /// capability may do this.
        /// If output was redirected already, then
        /// EBUSY
        /// is returned,
        /// but redirection can be stopped by using this ioctl with
        /// fd
        /// pointing at
        /// /dev/console
        /// or
        /// /dev/tty0 .
        /// </summary>
        public const int TIOCCONS = 21533;
        
        public const int TIOCGSERIAL = 21534;
        
        public const int TIOCSSERIAL = 21535;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// Enable (when
        /// * argp
        /// is nonzero) or disable packet mode.
        /// Can be applied to the master side of a pseudoterminal only (and will return
        /// ENOTTY
        /// otherwise).
        /// In packet mode, each subsequent
        /// read (2)
        /// will return a packet that either contains a single nonzero control byte,
        /// or has a single byte containing zero (\[aq]\e0\[aq]) followed by data
        /// written on the slave side of the pseudoterminal.
        /// If the first byte is not
        /// TIOCPKT_DATA
        /// (0), it is an OR of one
        /// or more of the following bits:
        /// 
        /// l
        /// 
        /// lb l.
        /// TIOCPKT_FLUSHREAD	T{
        /// The read queue for the terminal is flushed.
        /// T}
        /// TIOCPKT_FLUSHWRITE	T{
        /// The write queue for the terminal is flushed.
        /// T}
        /// TIOCPKT_STOP	T{
        /// Output to the terminal is stopped.
        /// T}
        /// TIOCPKT_START	T{
        /// Output to the terminal is restarted.
        /// T}
        /// TIOCPKT_DOSTOP	T{
        /// The start and stop characters are \fB\[ha]S\fP/\fB\[ha]Q\fP.
        /// T}
        /// TIOCPKT_NOSTOP	T{
        /// The start and stop characters are not \fB\[ha]S\fP/\fB\[ha]Q\fP.
        /// T}
        /// 
        /// 
        /// 
        /// While packet mode is in use, the presence
        /// of control status information to be read
        /// from the master side may be detected by a
        /// select (2)
        /// for exceptional conditions or a
        /// poll (2)
        /// for the
        /// POLLPRI
        /// event.
        /// 
        /// This mode is used by
        /// rlogin (1)
        /// and
        /// rlogind (8)
        /// to implement a remote-echoed,
        /// locally \fB\[ha]S\fP/\fB\[ha]Q\fP flow-controlled remote login.
        /// </summary>
        public const int TIOCPKT = 21536;
        
        public const int FIONBIO = 21537;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// If the given terminal was the controlling terminal of the calling process,
        /// give up this controlling terminal.
        /// If the process was session leader,
        /// then send
        /// SIGHUP
        /// and
        /// SIGCONT
        /// to the foreground process group
        /// and all processes in the current session lose their controlling terminal.
        /// </summary>
        public const int TIOCNOTTY = 21538;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// Set the line discipline of the terminal.
        /// </summary>
        public const int TIOCSETD = 21539;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Get the line discipline of the terminal.
        /// </summary>
        public const int TIOCGETD = 21540;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// So-called "POSIX version" of
        /// TCSBRK .
        /// It treats nonzero
        /// arg
        /// as a time interval measured in deciseconds, and does nothing
        /// when the driver does not support breaks.
        /// </summary>
        public const int TCSBRKP = 21541;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// Turn break on, that is, start sending zero bits.
        /// </summary>
        public const int TIOCSBRK = 21543;
        
        /// <summary>
        /// Argument:
        /// void
        /// 
        /// Turn break off, that is, stop sending zero bits.
        /// </summary>
        public const int TIOCCBRK = 21544;
        
        /// <summary>
        /// Argument:
        /// "pid_t\~*" argp
        /// 
        /// When successful, equivalent to
        /// "*argp = tcgetsid(fd)" .
        /// 
        /// Get the session ID of the given terminal.
        /// This fails with the error
        /// ENOTTY
        /// if the terminal is not a master pseudoterminal
        /// and not our controlling terminal.
        /// Strange.
        /// </summary>
        public const int TIOCGSID = 21545;
        
        public const int TIOCGRS485 = 21550;
        
        public const int TIOCSRS485 = 21551;
        
        public const int TIOCGPTN = -2147199952;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Set (if
        /// *argp
        /// is nonzero) or remove (if
        /// *argp
        /// is zero) the lock on the pseudoterminal slave device.
        /// (See also
        /// unlockpt (3).)
        /// </summary>
        public const int TIOCSPTLCK = 1074025521;
        
        public const int TIOCGDEV = -2147199950;
        
        public const int TCGETX = 21554;
        
        public const int TCSETX = 21555;
        
        public const int TCSETXF = 21556;
        
        public const int TCSETXW = 21557;
        
        public const int TIOCSIG = 1074025526;
        
        public const int TIOCVHANGUP = 21559;
        
        /// <summary>
        /// Argument:
        /// "const int\~*" argp
        /// 
        /// (since Linux 3.8)
        /// Return the current packet mode setting in the integer pointed to by
        /// argp .
        /// </summary>
        public const int TIOCGPKT = -2147199944;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// (since Linux 3.8)
        /// Place the current lock state of the pseudoterminal slave device
        /// in the location pointed to by
        /// argp .
        /// </summary>
        public const int TIOCGPTLCK = -2147199943;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// (since Linux 3.8)
        /// If the terminal is currently in exclusive mode,
        /// place a nonzero value in the location pointed to by
        /// argp ;
        /// otherwise, place zero in
        /// *argp .
        /// </summary>
        public const int TIOCGEXCL = -2147199936;
        
        /// <summary>
        /// Argument:
        /// "int " flags
        /// 
        /// commit 54ebbfb1603415d9953c150535850d30609ef077
        /// (since Linux 4.13)
        /// Given a file descriptor in
        /// fd
        /// that refers to a pseudoterminal master,
        /// open (with the given
        /// open (2)-style
        /// flags )
        /// and return a new file descriptor that refers to the peer
        /// pseudoterminal slave device.
        /// This operation can be performed
        /// regardless of whether the pathname of the slave device
        /// is accessible through the calling process's mount namespace.
        /// 
        /// Security-conscious programs interacting with namespaces may wish to use this
        /// operation rather than
        /// open (2)
        /// with the pathname returned by
        /// ptsname (3),
        /// and similar library functions that have insecure APIs.
        /// (For example, confusion can occur in some cases using
        /// ptsname (3)
        /// with a pathname where a devpts filesystem
        /// has been mounted in a different mount namespace.)
        /// 
        /// The BSD ioctls
        /// TIOCSTOP ,
        /// TIOCSTART ,
        /// TIOCUCNTL ,
        /// and
        /// TIOCREMOTE
        /// have not been implemented under Linux.
        /// </summary>
        public const int TIOCGPTPEER = 21569;
        
        public const int TIOCGISO7816 = -2144840638;
        
        public const int TIOCSISO7816 = -1071098813;
        
        public const int FIONCLEX = 21584;
        
        public const int FIOCLEX = 21585;
        
        public const int FIOASYNC = 21586;
        
        public const int TIOCSERCONFIG = 21587;
        
        public const int TIOCSERGWILD = 21588;
        
        public const int TIOCSERSWILD = 21589;
        
        /// <summary>
        /// Argument:
        /// "struct termios\~*" argp
        /// 
        /// Gets the locking status of the
        /// termios
        /// structure of the terminal.
        /// </summary>
        public const int TIOCGLCKTRMIOS = 21590;
        
        /// <summary>
        /// Argument:
        /// "const struct termios\~*" argp
        /// 
        /// Sets the locking status of the
        /// termios
        /// structure of the terminal.
        /// Only a process with the
        /// CAP_SYS_ADMIN
        /// capability can do this.
        /// </summary>
        public const int TIOCSLCKTRMIOS = 21591;
        
        public const int TIOCSERGSTRUCT = 21592;
        
        /// <summary>
        /// Argument:
        /// "int\~*" argp
        /// 
        /// Get line status register.
        /// Status register has
        /// TIOCSER_TEMT
        /// bit set when
        /// output buffer is empty and also hardware transmitter is physically empty.
        /// 
        /// Does not have to be supported by all serial tty drivers.
        /// 
        /// tcdrain (3)
        /// does not wait and returns immediately when
        /// TIOCSER_TEMT
        /// bit is set.
        /// </summary>
        public const int TIOCSERGETLSR = 21593;
        
        public const int TIOCSERGETMULTI = 21594;
        
        public const int TIOCSERSETMULTI = 21595;
        
        /// <summary>
        /// Argument:
        /// "int " arg
        /// 
        /// Wait for any of the 4 modem bits (DCD, RI, DSR, CTS) to change.
        /// The bits of interest are specified as a bit mask in
        /// arg ,
        /// by ORing together any of the bit values,
        /// TIOCM_RNG ,
        /// TIOCM_DSR ,
        /// TIOCM_CD ,
        /// and
        /// TIOCM_CTS .
        /// The caller should use
        /// TIOCGICOUNT
        /// to see which bit has changed.
        /// </summary>
        public const int TIOCMIWAIT = 21596;
        
        /// <summary>
        /// Argument:
        /// "struct serial_icounter_struct\~*" argp
        /// 
        /// Get counts of input serial line interrupts (DCD, RI, DSR, CTS).
        /// The counts are written to the
        /// serial_icounter_struct
        /// structure pointed to by
        /// argp .
        /// 
        /// Note: both 1-&gt;0 and 0-&gt;1 transitions are counted, except for
        /// RI, where only 0-&gt;1 transitions are counted.
        /// </summary>
        public const int TIOCGICOUNT = 21597;
        
        public const int FIOQSIZE = 21600;
        
        public const int TIOCM_LE = 1;
        
        public const int TIOCM_DTR = 2;
        
        public const int TIOCM_RTS = 4;
        
        public const int TIOCM_ST = 8;
        
        public const int TIOCM_SR = 16;
        
        public const int TIOCM_CTS = 32;
        
        public const int TIOCM_CAR = 64;
        
        public const int TIOCM_RNG = 128;
        
        public const int TIOCM_DSR = 256;
        
        public const int TIOCM_CD = 64;
        
        public const int TIOCM_RI = 128;
        
        public const int TIOCM_OUT1 = 8192;
        
        public const int TIOCM_OUT2 = 16384;
        
        public const int TIOCM_LOOP = 32768;
        
        public const int FIOSETOWN = 35073;
        
        public const int SIOCSPGRP = 35074;
        
        public const int FIOGETOWN = 35075;
        
        public const int SIOCGPGRP = 35076;
        
        public const int SIOCATMARK = 35077;
        
        public const int SIOCGSTAMP = 35078;
        
        public const int SIOCGSTAMPNS = 35079;
    }
}
