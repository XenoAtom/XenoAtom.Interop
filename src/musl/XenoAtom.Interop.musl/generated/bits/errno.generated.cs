//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    public static unsafe partial class musl
    {
        /// <summary>
        /// Firewall rules forbid connection.
        /// </summary>
        public const int EPERM = 1;
        
        /// <summary>
        /// A component of
        /// pathname
        /// does not exist or is a dangling symbolic link.
        /// </summary>
        public const int ENOENT = 2;
        
        /// <summary>
        /// No such thread.
        /// </summary>
        public const int ESRCH = 3;
        
        /// <summary>
        /// The system call was interrupted by a signal that was caught
        /// before a valid connection arrived; see
        /// signal (7).
        /// </summary>
        public const int EINTR = 4;
        
        /// <summary>
        /// An I/O error occurred.
        /// </summary>
        public const int EIO = 5;
        
        /// <summary>
        /// whence
        /// is
        /// SEEK_DATA
        /// or
        /// SEEK_HOLE ,
        /// and
        /// offset
        /// is beyond the end of the file, or
        /// whence
        /// is
        /// SEEK_DATA
        /// and
        /// offset
        /// is within a hole at the end of the file.
        /// </summary>
        public const int ENXIO = 6;
        
        /// <summary>
        /// An executable is not in a recognized format, is for the wrong
        /// architecture, or has some other format error that means it cannot be
        /// executed.
        /// </summary>
        public const int ENOEXEC = 8;
        
        /// <summary>
        /// sockfd
        /// is not an open file descriptor.
        /// </summary>
        public const int EBADF = 9;
        
        /// <summary>
        /// (for
        /// wait ())
        /// The calling process does not have any unwaited-for children.
        /// </summary>
        public const int ECHILD = 10;
        
        /// <summary>
        /// For
        /// BPF_PROG_LOAD ,
        /// indicates that needed resources are blocked.
        /// This happens when the verifier detects pending signals
        /// while it is checking the validity of the bpf program.
        /// In this case, just call
        /// bpf ()
        /// again with the same parameters.
        /// </summary>
        public const int EAGAIN = 11;
        
        /// <summary>
        /// Insufficient kernel memory was available.
        /// </summary>
        public const int ENOMEM = 12;
        
        /// <summary>
        /// The requested access would be denied to the file, or search permission
        /// is denied for one of the directories in the path prefix of
        /// pathname .
        /// (See also
        /// path_resolution (7).)
        /// </summary>
        public const int EACCES = 13;
        
        /// <summary>
        /// The
        /// addr
        /// argument is not in a writable part of the user address space.
        /// </summary>
        public const int EFAULT = 14;
        
        /// <summary>
        /// source
        /// is not a block device (and a device was required).
        /// </summary>
        public const int ENOTBLK = 15;
        
        /// <summary>
        /// An attempt was made to enter the daemon code after
        /// another process has already entered.
        /// </summary>
        public const int EBUSY = 16;
        
        /// <summary>
        /// A module by that name already exists.
        /// </summary>
        public const int EEXIST = 17;
        
        /// <summary>
        /// The filesystem object indicated by
        /// pathname
        /// resides within a filesystem subvolume (e.g.,
        /// btrfs (5))
        /// which uses a different
        /// fsid
        /// than its root superblock.
        /// This error can be returned only with an fanotify group that identifies
        /// filesystem objects by file handles.
        /// </summary>
        public const int EXDEV = 18;
        
        /// <summary>
        /// The hot-pluggable device (like USB for example) represented by a
        /// dynamic
        /// clk_id
        /// has disappeared after its character device was opened.
        /// See
        /// clock_gettime (2)
        /// for a discussion of dynamic clocks.
        /// </summary>
        public const int ENODEV = 19;
        
        /// <summary>
        /// A component used as a directory in
        /// pathname
        /// is not, in fact, a directory.
        /// </summary>
        public const int ENOTDIR = 20;
        
        /// <summary>
        /// filename
        /// is a directory.
        /// </summary>
        public const int EISDIR = 21;
        
        /// <summary>
        /// Socket is not listening for connections, or
        /// addrlen
        /// is invalid (e.g., is negative).
        /// </summary>
        public const int EINVAL = 22;
        
        /// <summary>
        /// The system-wide limit on the total number of open files has been reached.
        /// </summary>
        public const int ENFILE = 23;
        
        /// <summary>
        /// The per-process limit on the number of open file descriptors has been reached.
        /// </summary>
        public const int EMFILE = 24;
        
        /// <summary>
        /// fd
        /// is not associated with a character special device.
        /// </summary>
        public const int ENOTTY = 25;
        
        /// <summary>
        /// Write access was requested to an executable which is being
        /// executed.
        /// </summary>
        public const int ETXTBSY = 26;
        
        /// <summary>
        /// An attempt was made to write at a position past the maximum file offset the
        /// kernel supports.
        /// </summary>
        public const int EFBIG = 27;
        
        /// <summary>
        /// There is not enough space on the target filesystem to complete the copy.
        /// </summary>
        public const int ENOSPC = 28;
        
        /// <summary>
        /// fd
        /// refers to a pipe or FIFO.
        /// </summary>
        public const int ESPIPE = 29;
        
        /// <summary>
        /// Write permission was requested for a file on a read-only filesystem.
        /// </summary>
        public const int EROFS = 30;
        
        /// <summary>
        /// The file referred to by
        /// oldpath
        /// already has the maximum number of links to it.
        /// For example, on an
        /// ext4 (5)
        /// filesystem that does not employ the
        /// dir_index
        /// feature, the limit on the number of hard links to a file is 65,000; on
        /// btrfs (5),
        /// the limit is 65,535 links.
        /// </summary>
        public const int EMLINK = 31;
        
        /// <summary>
        /// The local end has been shut down on a connection oriented socket.
        /// In this case, the process
        /// will also receive a
        /// SIGPIPE
        /// unless
        /// MSG_NOSIGNAL
        /// is set.
        /// </summary>
        public const int EPIPE = 32;
        
        /// <summary>
        /// Mathematics argument out of domain of function (POSIX.1, C99).
        /// EDOTDOT is defined but appears to be unused
        /// </summary>
        public const int EDOM = 33;
        
        /// <summary>
        /// The
        /// size
        /// of the
        /// value
        /// buffer is too small to hold the result.
        /// 
        /// In addition, the errors documented in
        /// stat (2)
        /// can also occur.
        /// </summary>
        public const int ERANGE = 34;
        
        /// <summary>
        /// It was detected that the specified
        /// F_SETLKW
        /// command would cause a deadlock.
        /// </summary>
        public const int EDEADLK = 35;
        
        /// <summary>
        /// pathname
        /// is too long.
        /// </summary>
        public const int ENAMETOOLONG = 36;
        
        /// <summary>
        /// Too many segment locks open, lock table is full, or a remote locking
        /// protocol failed (e.g., locking over NFS).
        /// </summary>
        public const int ENOLCK = 37;
        
        /// <summary>
        /// BSD process accounting has not been enabled when the operating system
        /// kernel was compiled.
        /// The kernel configuration parameter controlling this feature is
        /// CONFIG_BSD_PROCESS_ACCT .
        /// </summary>
        public const int ENOSYS = 38;
        
        /// <summary>
        /// pathname
        /// contains entries other than
        /// . " and " .. " ;"
        /// or,
        /// pathname
        /// has
        /// ..
        /// as its final component.
        /// POSIX.1 also allows
        /// POSIX.1-2001, POSIX.1-2008
        /// EEXIST
        /// for this condition.
        /// </summary>
        public const int ENOTEMPTY = 39;
        
        /// <summary>
        /// Too many symbolic links were encountered in resolving
        /// pathname .
        /// </summary>
        public const int ELOOP = 40;
        
        /// <summary>
        /// Other modules depend on this module;
        /// or,
        /// O_NONBLOCK
        /// was specified in
        /// flags ,
        /// but the reference count of this module is nonzero and
        /// O_TRUNC
        /// was not specified in
        /// flags .
        /// </summary>
        public const int EWOULDBLOCK = 11;
        
        /// <summary>
        /// Empty accesses (i.e.,
        /// rule_attr\-&gt;allowed_access
        /// is 0).
        /// </summary>
        public const int ENOMSG = 42;
        
        /// <summary>
        /// The message queue was removed.
        /// </summary>
        public const int EIDRM = 43;
        
        /// <summary>
        /// Channel number out of range.
        /// </summary>
        public const int ECHRNG = 44;
        
        /// <summary>
        /// ELNRNG appears to be used by a few drivers
        /// Link number out of range.
        /// </summary>
        public const int ELNRNG = 48;
        
        /// <summary>
        /// Protocol driver not attached.
        /// </summary>
        public const int EUNATCH = 49;
        
        public const int ENOCSI = 50;
        
        /// <summary>
        /// Invalid exchange.
        /// </summary>
        public const int EBADE = 52;
        
        /// <summary>
        /// Invalid request descriptor.
        /// </summary>
        public const int EBADR = 53;
        
        /// <summary>
        /// Exchange full.
        /// </summary>
        public const int EXFULL = 54;
        
        /// <summary>
        /// ENOANO appears to be used by a few drivers
        /// No anode.
        /// </summary>
        public const int ENOANO = 55;
        
        /// <summary>
        /// Invalid request code.
        /// </summary>
        public const int EBADRQC = 56;
        
        /// <summary>
        /// Invalid slot.
        /// EBFONT is defined but appears not to be used by kernel or glibc.
        /// </summary>
        public const int EBADSLT = 57;
        
        /// <summary>
        /// On most architectures, a synonym for
        /// EDEADLK .
        /// On some architectures (e.g., Linux MIPS, PowerPC, SPARC),
        /// it is a separate error code "File locking deadlock error".
        /// </summary>
        public const int EDEADLOCK = 35;
        
        public const int EBFONT = 59;
        
        /// <summary>
        /// Not a STREAM (POSIX.1 (XSI STREAMS option)).
        /// </summary>
        public const int ENOSTR = 60;
        
        /// <summary>
        /// The named attribute does not exist, or the process has no access to
        /// this attribute.
        /// .RB ( ENOATTR
        /// is defined to be a synonym for
        /// .BR ENODATA
        /// in
        /// .IR &lt;attr/attributes.h&gt; .)
        /// </summary>
        public const int ENODATA = 61;
        
        /// <summary>
        /// Timer expired
        /// (POSIX.1 (XSI STREAMS option)).
        /// 
        /// (POSIX.1 says "STREAM
        /// ioctl (2)
        /// timeout".)
        /// </summary>
        public const int ETIME = 62;
        
        /// <summary>
        /// No STREAM resources (POSIX.1 (XSI STREAMS option)).
        /// </summary>
        public const int ENOSR = 63;
        
        /// <summary>
        /// Machine is not on the network.
        /// </summary>
        public const int ENONET = 64;
        
        /// <summary>
        /// ( pipe2 ())
        /// O_NOTIFICATION_PIPE
        /// was passed in
        /// flags
        /// and support for notifications
        /// ( CONFIG_WATCH_QUEUE )
        /// is not compiled into the kernel.
        /// </summary>
        public const int ENOPKG = 65;
        
        /// <summary>
        /// Object is remote.
        /// </summary>
        public const int EREMOTE = 66;
        
        /// <summary>
        /// POSIX says "Reserved"
        /// Link has been severed (POSIX.1-2001).
        /// </summary>
        public const int ENOLINK = 67;
        
        public const int EADV = 68;
        
        public const int ESRMNT = 69;
        
        /// <summary>
        /// Communication error on send.
        /// </summary>
        public const int ECOMM = 70;
        
        /// <summary>
        /// Protocol error.
        /// 
        /// In addition, network errors for the new socket and as defined
        /// for the protocol may be returned.
        /// Various Linux kernels can
        /// return other errors such as
        /// ENOSR ,
        /// ESOCKTNOSUPPORT ,
        /// EPROTONOSUPPORT ,
        /// ETIMEDOUT .
        /// The value
        /// ERESTARTSYS
        /// may be seen during a trace.
        /// </summary>
        public const int EPROTO = 71;
        
        /// <summary>
        /// POSIX says "Reserved"
        /// Multihop attempted (POSIX.1-2001).
        /// </summary>
        public const int EMULTIHOP = 72;
        
        public const int EDOTDOT = 73;
        
        /// <summary>
        /// The filesystem has detected a checksum error in the metadata.
        /// </summary>
        public const int EBADMSG = 74;
        
        /// <summary>
        /// The requested source or destination range is too large to represent in the
        /// specified data types.
        /// </summary>
        public const int EOVERFLOW = 75;
        
        /// <summary>
        /// Name not unique on network.
        /// </summary>
        public const int ENOTUNIQ = 76;
        
        /// <summary>
        /// ruleset_fd
        /// is not a ruleset file descriptor,
        /// or a member of
        /// rule_attr
        /// is not the expected file descriptor type.
        /// </summary>
        public const int EBADFD = 77;
        
        /// <summary>
        /// Remote address changed.
        /// </summary>
        public const int EREMCHG = 78;
        
        /// <summary>
        /// Cannot access a needed shared library.
        /// </summary>
        public const int ELIBACC = 79;
        
        /// <summary>
        /// An ELF interpreter was not in a recognized format.
        /// </summary>
        public const int ELIBBAD = 80;
        
        /// <summary>
        /// \&amp;.lib section in a.out corrupted
        /// </summary>
        public const int ELIBSCN = 81;
        
        /// <summary>
        /// Attempting to link in too many shared libraries.
        /// </summary>
        public const int ELIBMAX = 82;
        
        /// <summary>
        /// Cannot exec a shared library directly.
        /// </summary>
        public const int ELIBEXEC = 83;
        
        /// <summary>
        /// Invalid or incomplete multibyte or wide character (POSIX.1, C99).
        /// 
        /// The text shown here is the glibc error description;
        /// in POSIX.1, this error is described as "Illegal byte sequence".
        /// </summary>
        public const int EILSEQ = 84;
        
        /// <summary>
        /// Interrupted system call should be restarted.
        /// </summary>
        public const int ERESTART = 85;
        
        /// <summary>
        /// Streams pipe error.
        /// </summary>
        public const int ESTRPIPE = 86;
        
        /// <summary>
        /// There are no more free file structures or we ran out of memory.
        /// </summary>
        public const int EUSERS = 87;
        
        /// <summary>
        /// The file descriptor
        /// sockfd
        /// does not refer to a socket.
        /// </summary>
        public const int ENOTSOCK = 88;
        
        /// <summary>
        /// The socket is not connection-mode, and no peer address is set.
        /// </summary>
        public const int EDESTADDRREQ = 89;
        
        /// <summary>
        /// operation
        /// was
        /// KEYCTL_DH_COMPUTE
        /// and the buffer length exceeds
        /// KEYCTL_KDF_MAX_OUTPUT_LEN
        /// (which is 1024 currently)
        /// or the
        /// otherinfolen
        /// field of the
        /// struct keyctl_kdf_parms
        /// passed in
        /// arg5
        /// exceeds
        /// KEYCTL_KDF_MAX_OI_LEN
        /// (which is 64 currently).
        /// </summary>
        public const int EMSGSIZE = 90;
        
        /// <summary>
        /// The socket type does not support the requested communications protocol.
        /// This error can occur, for example,
        /// on an attempt to connect a UNIX domain datagram socket to a stream socket.
        /// </summary>
        public const int EPROTOTYPE = 91;
        
        /// <summary>
        /// The option is unknown at the level indicated.
        /// </summary>
        public const int ENOPROTOOPT = 92;
        
        /// <summary>
        /// The protocol type or the specified protocol is not
        /// supported within this domain.
        /// 
        /// Other errors may be generated by the underlying protocol modules.
        /// </summary>
        public const int EPROTONOSUPPORT = 93;
        
        /// <summary>
        /// Socket type not supported.
        /// </summary>
        public const int ESOCKTNOSUPPORT = 94;
        
        /// <summary>
        /// The referenced socket is not of type
        /// SOCK_STREAM .
        /// </summary>
        public const int EOPNOTSUPP = 95;
        
        /// <summary>
        /// ( fchmodat ())
        /// flags
        /// specified
        /// AT_SYMLINK_NOFOLLOW ,
        /// which is not supported.
        /// </summary>
        public const int ENOTSUP = 95;
        
        /// <summary>
        /// Protocol family not supported.
        /// </summary>
        public const int EPFNOSUPPORT = 96;
        
        /// <summary>
        /// The passed address didn't have the correct address family in its
        /// sa_family
        /// field.
        /// </summary>
        public const int EAFNOSUPPORT = 97;
        
        /// <summary>
        /// The given address is already in use.
        /// </summary>
        public const int EADDRINUSE = 98;
        
        /// <summary>
        /// A nonexistent interface was requested or the requested
        /// address was not local.
        /// </summary>
        public const int EADDRNOTAVAIL = 99;
        
        /// <summary>
        /// Network is down (POSIX.1-2001).
        /// </summary>
        public const int ENETDOWN = 100;
        
        /// <summary>
        /// Network is unreachable.
        /// </summary>
        public const int ENETUNREACH = 101;
        
        /// <summary>
        /// Connection aborted by network (POSIX.1-2001).
        /// </summary>
        public const int ENETRESET = 102;
        
        /// <summary>
        /// A connection has been aborted.
        /// </summary>
        public const int ECONNABORTED = 103;
        
        /// <summary>
        /// Connection reset by peer.
        /// </summary>
        public const int ECONNRESET = 104;
        
        /// <summary>
        /// Insufficient resources were available in the system
        /// to perform the operation.
        /// </summary>
        public const int ENOBUFS = 105;
        
        /// <summary>
        /// The socket is already connected.
        /// </summary>
        public const int EISCONN = 106;
        
        /// <summary>
        /// The socket is not connected.
        /// </summary>
        public const int ENOTCONN = 107;
        
        /// <summary>
        /// Cannot send after transport endpoint shutdown.
        /// </summary>
        public const int ESHUTDOWN = 108;
        
        /// <summary>
        /// ETOOMANYREFS seems to be used in net/unix/af_unix.c
        /// Too many references: cannot splice.
        /// </summary>
        public const int ETOOMANYREFS = 109;
        
        /// <summary>
        /// Timeout while attempting connection.
        /// The server may be too
        /// busy to accept new connections.
        /// Note that for IP sockets the timeout may
        /// be very long when syncookies are enabled on the server.
        /// </summary>
        public const int ETIMEDOUT = 110;
        
        /// <summary>
        /// A
        /// connect ()
        /// on a stream socket found no one listening on the remote address.
        /// </summary>
        public const int ECONNREFUSED = 111;
        
        /// <summary>
        /// Host is down.
        /// </summary>
        public const int EHOSTDOWN = 112;
        
        /// <summary>
        /// Host is unreachable (POSIX.1-2001).
        /// </summary>
        public const int EHOSTUNREACH = 113;
        
        /// <summary>
        /// The socket is nonblocking and a previous connection attempt has not yet
        /// been completed.
        /// </summary>
        public const int EALREADY = 114;
        
        /// <summary>
        /// The socket is nonblocking and the connection cannot be completed immediately.
        /// (UNIX domain sockets failed with
        /// EAGAIN
        /// instead.)
        /// It is possible to
        /// select (2)
        /// or
        /// poll (2)
        /// for completion by selecting the socket for writing.
        /// After
        /// select (2)
        /// indicates writability, use
        /// getsockopt (2)
        /// to read the
        /// SO_ERROR
        /// option at level
        /// SOL_SOCKET
        /// to determine whether
        /// connect ()
        /// completed successfully
        /// ( SO_ERROR
        /// is zero) or unsuccessfully
        /// ( SO_ERROR
        /// is one of the usual error codes listed here,
        /// explaining the reason for the failure).
        /// </summary>
        public const int EINPROGRESS = 115;
        
        /// <summary>
        /// The specified
        /// handle
        /// is not valid.
        /// This error will occur if, for example, the file has been deleted.
        /// </summary>
        public const int ESTALE = 116;
        
        /// <summary>
        /// The filesystem metadata is corrupt and needs repair.
        /// </summary>
        public const int EUCLEAN = 117;
        
        public const int ENOTNAM = 118;
        
        public const int ENAVAIL = 119;
        
        /// <summary>
        /// Is a named type file.
        /// </summary>
        public const int EISNAM = 120;
        
        /// <summary>
        /// Remote I/O error.
        /// </summary>
        public const int EREMOTEIO = 121;
        
        /// <summary>
        /// The key quota for this user would be exceeded by creating this key or linking
        /// it to the keyring.
        /// </summary>
        public const int EDQUOT = 122;
        
        /// <summary>
        /// No medium found.
        /// </summary>
        public const int ENOMEDIUM = 123;
        
        /// <summary>
        /// Wrong medium type.
        /// </summary>
        public const int EMEDIUMTYPE = 124;
        
        /// <summary>
        /// See NOTES.
        /// </summary>
        public const int ECANCELED = 125;
        
        /// <summary>
        /// The keyring doesn't exist.
        /// </summary>
        public const int ENOKEY = 126;
        
        /// <summary>
        /// The keyring has expired.
        /// </summary>
        public const int EKEYEXPIRED = 127;
        
        /// <summary>
        /// The keyring has been revoked.
        /// </summary>
        public const int EKEYREVOKED = 128;
        
        /// <summary>
        /// A rejected key was found or specified.
        /// </summary>
        public const int EKEYREJECTED = 129;
        
        /// <summary>
        /// Used at least by the user-space side of rubost mutexes
        /// Owner died (POSIX.1-2008).
        /// </summary>
        public const int EOWNERDEAD = 130;
        
        /// <summary>
        /// State not recoverable (POSIX.1-2008).
        /// </summary>
        public const int ENOTRECOVERABLE = 131;
        
        /// <summary>
        /// ERFKILL appears to be used by various drivers
        /// Operation not possible due to RF-kill.
        /// </summary>
        public const int ERFKILL = 132;
        
        /// <summary>
        /// advice
        /// is
        /// MADV_POPULATE_READ
        /// or
        /// MADV_POPULATE_WRITE ,
        /// and populating (prefaulting) page tables failed because a HW poisoned page
        /// (HW poisoned pages can,
        /// for example,
        /// be created using the
        /// MADV_HWPOISON
        /// flag described elsewhere in this page)
        /// was encountered.
        /// </summary>
        public const int EHWPOISON = 133;
    }
}
