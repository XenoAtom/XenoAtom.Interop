//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class musl
    {
        public partial struct sched_param
        {
            public partial struct sched_param_
            {
                public musl.time_t __reserved1;
                
                public nint __reserved2;
            }
            
            public int sched_priority;
            
            public int __reserved1;
            
            public musl.sched_param.sched_param_ sched_param__2;
            
            public FixedArray2<musl.sched_param.sched_param_> __reserved2;
            
            public int __reserved3;
        }
        
        public partial struct cpu_set_t
        {
            public FixedArray16<nuint> __bits;
        }
        
        /// <summary>
        /// the standard round-robin time-sharing policy;
        /// In the 2.6 kernel sources, SCHED_OTHER is actually called
        /// SCHED_NORMAL.
        /// </summary>
        public const int SCHED_OTHER = 0;
        
        /// <summary>
        /// a first-in, first-out policy; and
        /// </summary>
        public const int SCHED_FIFO = 1;
        
        /// <summary>
        /// a round-robin policy.
        /// 
        /// Linux also provides the following policy:
        /// </summary>
        public const int SCHED_RR = 2;
        
        /// <summary>
        /// for "batch" style execution of processes; and
        /// </summary>
        public const int SCHED_BATCH = 3;
        
        /// <summary>
        /// for running
        /// very
        /// low priority background jobs.
        /// 
        /// Various "real-time" policies are also supported,
        /// for special time-critical applications that need precise control over
        /// the way in which runnable threads are selected for execution.
        /// For the rules governing when a process may use these policies, see
        /// sched (7).
        /// The real-time policies that may be specified in
        /// policy
        /// are:
        /// </summary>
        public const int SCHED_IDLE = 5;
        
        /// <summary>
        /// a deadline scheduling policy; see
        /// sched (7)
        /// for details.
        /// 
        /// The
        /// attr
        /// argument is a pointer to a structure that defines
        /// the new scheduling policy and attributes for the specified thread.
        /// This structure has the following form:
        /// 
        /// +4n
        /// 
        /// struct sched_attr {
        ///     u32 size;              /* Size of this structure */
        ///     u32 sched_policy;      /* Policy (SCHED_*) */
        ///     u64 sched_flags;       /* Flags */
        ///     s32 sched_nice;        /* Nice value (SCHED_OTHER,
        ///                               SCHED_BATCH) */
        ///     u32 sched_priority;    /* Static priority (SCHED_FIFO,
        ///                               SCHED_RR) */
        ///     /* Remaining fields are for SCHED_DEADLINE */
        ///     u64 sched_runtime;
        ///     u64 sched_deadline;
        ///     u64 sched_period;
        /// };
        /// 
        /// 
        /// 
        /// The fields of the
        /// sched_attr
        /// structure are as follows:
        /// </summary>
        public const int SCHED_DEADLINE = 6;
        
        public const int SCHED_RESET_ON_FORK = 1073741824;
        
        public const int CLONE_NEWTIME = 128;
        
        public const int CLONE_VM = 256;
        
        /// <summary>
        /// Reverse the effect of the
        /// clone (2)
        /// CLONE_FS
        /// flag.
        /// Unshare filesystem attributes, so that the calling process
        /// no longer shares its root directory
        /// ( chroot (2)),
        /// current directory
        /// ( chdir (2)),
        /// or umask
        /// ( umask (2))
        /// attributes with any other process.
        /// </summary>
        public const int CLONE_FS = 512;
        
        /// <summary>
        /// Reverse the effect of the
        /// clone (2)
        /// CLONE_FILES
        /// flag.
        /// Unshare the file descriptor table, so that the calling process
        /// no longer shares its file descriptors with any other process.
        /// </summary>
        public const int CLONE_FILES = 1024;
        
        public const int CLONE_SIGHAND = 2048;
        
        public const int CLONE_PIDFD = 4096;
        
        public const int CLONE_PTRACE = 8192;
        
        public const int CLONE_VFORK = 16384;
        
        public const int CLONE_PARENT = 32768;
        
        public const int CLONE_THREAD = 65536;
        
        /// <summary>
        /// These flag name are inconsistent:
        /// CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
        /// CLONE_FS, and CLONE_FILES reverse the action of the clone()
        /// flags of the same name.
        /// This flag has the same effect as the
        /// clone (2)
        /// CLONE_NEWNS
        /// flag.
        /// Unshare the mount namespace,
        /// so that the calling process has a private copy of
        /// its namespace which is not shared with any other process.
        /// Specifying this flag automatically implies
        /// CLONE_FS
        /// as well.
        /// Use of
        /// CLONE_NEWNS
        /// requires the
        /// CAP_SYS_ADMIN
        /// capability.
        /// For further information, see
        /// mount_namespaces (7).
        /// </summary>
        public const int CLONE_NEWNS = 131072;
        
        public const int CLONE_SYSVSEM = 262144;
        
        public const int CLONE_SETTLS = 524288;
        
        public const int CLONE_PARENT_SETTID = 1048576;
        
        public const int CLONE_CHILD_CLEARTID = 2097152;
        
        public const int CLONE_DETACHED = 4194304;
        
        public const int CLONE_UNTRACED = 8388608;
        
        public const int CLONE_CHILD_SETTID = 16777216;
        
        public const int CLONE_NEWCGROUP = 33554432;
        
        public const int CLONE_NEWUTS = 67108864;
        
        public const int CLONE_NEWIPC = 134217728;
        
        /// <summary>
        /// (This flag first became meaningful for
        /// clone ()
        /// in Linux 2.6.23,
        /// the current
        /// clone ()
        /// semantics were merged in Linux 3.5,
        /// and the final pieces to make the user namespaces completely usable were
        /// merged in Linux 3.8.)
        /// 
        /// If
        /// CLONE_NEWUSER
        /// is set, then create the process in a new user namespace.
        /// If this flag is not set, then (as with
        /// fork (2))
        /// the process is created in the same user namespace as the calling process.
        /// 
        /// For further information on user namespaces, see
        /// namespaces (7)
        /// and
        /// user_namespaces (7).
        /// 
        /// Before Linux 3.8, use of
        /// CLONE_NEWUSER
        /// required that the caller have three capabilities:
        /// CAP_SYS_ADMIN ,
        /// CAP_SETUID ,
        /// and
        /// CAP_SETGID .
        /// Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
        /// Starting with Linux 3.8,
        /// no privileges are needed to create a user namespace.
        /// 
        /// This flag can't be specified in conjunction with
        /// CLONE_THREAD
        /// or
        /// CLONE_PARENT .
        /// For security reasons,
        /// commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
        /// https://lwn.net/Articles/543273/
        /// The fix actually went into Linux 3.9 and into Linux 3.8.3. However, user namespaces
        /// were, for practical purposes, unusable in earlier Linux 3.8.x because of the
        /// various filesystems that didn't support userns.
        /// CLONE_NEWUSER
        /// cannot be specified in conjunction with
        /// CLONE_FS .
        /// </summary>
        public const int CLONE_NEWUSER = 268435456;
        
        public const int CLONE_NEWPID = 536870912;
        
        public const int CLONE_NEWNET = 1073741824;
        
        public const int CLONE_IO = -2147483648;
        
        public const int CPU_SETSIZE = 1024;
        
        /// <summary>
        /// Get static priority range
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_get_priority_max")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_get_priority_max(int policy);
        
        /// <summary>
        /// Get static priority range
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_get_priority_min")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_get_priority_min(int policy);
        
        /// <summary>
        /// Set and get scheduling parameters
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_getparam")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_getparam(musl.pid_t pid, ref musl.sched_param param);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_getscheduler")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_getscheduler(musl.pid_t pid);
        
        /// <summary>
        /// Get the SCHED_RR interval for the named process
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_rr_get_interval")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_rr_get_interval(musl.pid_t pid, ref musl.timespec tp);
        
        /// <summary>
        /// Set and get scheduling parameters
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_setparam")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_setparam(musl.pid_t pid, in musl.sched_param param);
        
        /// <summary>
        /// sched_setscheduler, sched_getscheduler \-
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_setscheduler")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_setscheduler(musl.pid_t pid, int policy, in musl.sched_param param);
        
        /// <summary>
        /// Yield the processor
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_yield")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_yield();
        
        /// <summary>
        /// Create a child process
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "clone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int clone(delegate*unmanaged[Cdecl]<void*, int> fn, void* stack, int flags, void* arg);
        
        /// <summary>
        /// Disassociate parts of the process execution context
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "unshare")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int unshare(int flags);
        
        /// <summary>
        /// Reassociate thread with a namespace
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "setns")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int setns(int fd, int nstype);
        
        /// <summary>
        /// Copy memory area
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "memcpy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* memcpy(void* dest, void* src, nuint n);
        
        /// <summary>
        /// Compare memory areas
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "memcmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int memcmp(void* s1, void* s2, nuint n);
        
        /// <summary>
        /// Fill memory with a constant byte
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "memset")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* memset(void* s, int c, nuint n);
        
        /// <summary>
        /// Allocate and free dynamic memory
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "calloc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* calloc(nuint nmemb, nuint size);
        
        /// <summary>
        /// Allocate and free dynamic memory
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void free(void* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "__sched_cpucount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int __sched_cpucount(nuint arg0, in musl.cpu_set_t arg1);
        
        /// <summary>
        /// Determine CPU on which the calling thread is running
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_getcpu")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_getcpu();
        
        /// <summary>
        /// \
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_getaffinity")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_getaffinity(musl.pid_t pid, nuint cpusetsize, ref musl.cpu_set_t mask);
        
        /// <summary>
        /// \
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "sched_setaffinity")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int sched_setaffinity(musl.pid_t pid, nuint cpusetsize, in musl.cpu_set_t mask);
    }
}
