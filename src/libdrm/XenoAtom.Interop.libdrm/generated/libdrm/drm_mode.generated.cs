//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    public static unsafe partial class libdrm
    {
        /// <summary>
        /// This is for connectors with multiple signal types.
        /// </summary>
        /// <remarks>
        /// Try to match DRM_MODE_CONNECTOR_X as closely as possible.
        /// </remarks>
        public enum drm_mode_subconnector : uint
        {
            /// <summary>
            /// DVI-I, TV
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Automatic = unchecked((uint)0),
            
            /// <summary>
            /// DVI-I, TV, DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Unknown = unchecked((uint)0),
            
            /// <summary>
            /// DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_VGA = unchecked((uint)1),
            
            /// <summary>
            /// DVI-I      DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_DVID = unchecked((uint)3),
            
            /// <summary>
            /// DVI-I
            /// </summary>
            DRM_MODE_SUBCONNECTOR_DVIA = unchecked((uint)4),
            
            /// <summary>
            /// TV
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Composite = unchecked((uint)5),
            
            /// <summary>
            /// TV
            /// </summary>
            DRM_MODE_SUBCONNECTOR_SVIDEO = unchecked((uint)6),
            
            /// <summary>
            /// TV
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Component = unchecked((uint)8),
            
            /// <summary>
            /// TV
            /// </summary>
            DRM_MODE_SUBCONNECTOR_SCART = unchecked((uint)9),
            
            /// <summary>
            /// DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_DisplayPort = unchecked((uint)10),
            
            /// <summary>
            /// DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_HDMIA = unchecked((uint)11),
            
            /// <summary>
            /// DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Native = unchecked((uint)15),
            
            /// <summary>
            /// DP
            /// </summary>
            DRM_MODE_SUBCONNECTOR_Wireless = unchecked((uint)18),
        }
        
        /// <summary>
        /// DVI-I, TV
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Automatic = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Automatic;
        
        /// <summary>
        /// DVI-I, TV, DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Unknown = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Unknown;
        
        /// <summary>
        /// DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_VGA = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_VGA;
        
        /// <summary>
        /// DVI-I      DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_DVID = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_DVID;
        
        /// <summary>
        /// DVI-I
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_DVIA = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_DVIA;
        
        /// <summary>
        /// TV
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Composite = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Composite;
        
        /// <summary>
        /// TV
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_SVIDEO = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_SVIDEO;
        
        /// <summary>
        /// TV
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Component = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Component;
        
        /// <summary>
        /// TV
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_SCART = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_SCART;
        
        /// <summary>
        /// DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_DisplayPort = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_DisplayPort;
        
        /// <summary>
        /// DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_HDMIA = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_HDMIA;
        
        /// <summary>
        /// DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Native = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Native;
        
        /// <summary>
        /// DP
        /// </summary>
        public const libdrm.drm_mode_subconnector DRM_MODE_SUBCONNECTOR_Wireless = drm_mode_subconnector.DRM_MODE_SUBCONNECTOR_Wireless;
        
        /// <summary>
        /// struct drm_mode_modeinfo - Display mode information.
        /// @clock : pixel clock in kHz
        /// @hdisplay : horizontal display size
        /// @hsync _start: horizontal sync start
        /// @hsync _end: horizontal sync end
        /// @htotal : horizontal total size
        /// @hskew : horizontal skew
        /// @vdisplay : vertical display size
        /// @vsync _start: vertical sync start
        /// @vsync _end: vertical sync end
        /// @vtotal : vertical total size
        /// @vscan : vertical scan
        /// @vrefresh : approximate vertical refresh rate in Hz
        /// @flags : bitmask of misc. flags, see DRM_MODE_FLAG_* defines
        /// @type : bitmask of type flags, see DRM_MODE_TYPE_* defines
        /// </summary>
        /// <remarks>
        /// : string describing the mode resolutionThis is the user-space API display mode information structure. For the
        /// kernel version see struct drm_display_mode.
        /// </remarks>
        public unsafe partial struct drm_mode_modeinfo
        {
            public uint clock;
            
            public ushort hdisplay;
            
            public ushort hsync_start;
            
            public ushort hsync_end;
            
            public ushort htotal;
            
            public ushort hskew;
            
            public ushort vdisplay;
            
            public ushort vsync_start;
            
            public ushort vsync_end;
            
            public ushort vtotal;
            
            public ushort vscan;
            
            public uint vrefresh;
            
            public libdrm.drm_mode_flag flags;
            
            public libdrm.drm_mode_type type;
            
            public fixed byte name[32];
        }
        
        public partial struct drm_mode_card_res
        {
            public ulong fb_id_ptr;
            
            public ulong crtc_id_ptr;
            
            public ulong connector_id_ptr;
            
            public ulong encoder_id_ptr;
            
            public uint count_fbs;
            
            public uint count_crtcs;
            
            public uint count_connectors;
            
            public uint count_encoders;
            
            public uint min_width;
            
            public uint max_width;
            
            public uint min_height;
            
            public uint max_height;
        }
        
        public partial struct drm_mode_crtc
        {
            public ulong set_connectors_ptr;
            
            public uint count_connectors;
            
            /// <summary>
            /// Id
            /// </summary>
            public uint crtc_id;
            
            /// <summary>
            /// Id of framebuffer
            /// </summary>
            public uint fb_id;
            
            /// <summary>
            /// x Position on the framebuffer
            /// </summary>
            public uint x;
            
            /// <summary>
            /// y Position on the framebuffer
            /// </summary>
            public uint y;
            
            public uint gamma_size;
            
            public uint mode_valid;
            
            public libdrm.drm_mode_modeinfo mode;
        }
        
        /// <summary>
        /// Planes blend with or override other bits on the CRTC
        /// </summary>
        public partial struct drm_mode_set_plane
        {
            public uint plane_id;
            
            public uint crtc_id;
            
            /// <summary>
            /// fb object contains surface format type
            /// </summary>
            public uint fb_id;
            
            /// <summary>
            /// see above flags
            /// </summary>
            public uint flags;
            
            /// <summary>
            /// Signed dest location allows it to be partially off screen
            /// </summary>
            public int crtc_x;
            
            public int crtc_y;
            
            public uint crtc_w;
            
            public uint crtc_h;
            
            /// <summary>
            /// Source values are 16.16 fixed point
            /// </summary>
            public uint src_x;
            
            public uint src_y;
            
            public uint src_h;
            
            public uint src_w;
        }
        
        /// <summary>
        /// struct drm_mode_get_plane - Get plane metadata.
        /// </summary>
        /// <remarks>
        /// Userspace can perform a GETPLANE ioctl to retrieve information about a
        /// plane.To retrieve the number of formats supported, set @count _format_types to zero
        /// and call the ioctl. @count _format_types will be updated with the value.To retrieve these formats, allocate an array with the memory needed to store
        /// @count _format_types formats. Point @format _type_ptr to this array and call
        /// the ioctl again (with @count _format_types still set to the value returned in
        /// the first ioctl call).
        /// </remarks>
        public partial struct drm_mode_get_plane
        {
            /// <summary>
            /// @plane _id: Object ID of the plane whose information should be
            /// retrieved. Set by caller.
            /// </summary>
            public uint plane_id;
            
            /// <summary>
            /// _id: Object ID of the current CRTC.
            /// </summary>
            public uint crtc_id;
            
            /// <summary>
            /// _id: Object ID of the current fb.
            /// </summary>
            public uint fb_id;
            
            /// <summary>
            /// @possible _crtcs: Bitmask of CRTC's compatible with the plane. CRTC's
            /// are created and they receive an index, which corresponds to their
            /// position in the bitmask. Bit N corresponds to
            /// :ref:`CRTC index
            /// &lt;crtc
            /// _index&gt;` N.
            /// </summary>
            public uint possible_crtcs;
            
            /// <summary>
            /// _size: Never used.
            /// </summary>
            public uint gamma_size;
            
            /// <summary>
            /// _format_types: Number of formats.
            /// </summary>
            public uint count_format_types;
            
            /// <summary>
            /// @format _type_ptr: Pointer to ``__u32`` array of formats that are
            /// supported by the plane. These formats do not require modifiers.
            /// </summary>
            public ulong format_type_ptr;
        }
        
        public partial struct drm_mode_get_plane_res
        {
            public ulong plane_id_ptr;
            
            public uint count_planes;
        }
        
        public partial struct drm_mode_get_encoder
        {
            public uint encoder_id;
            
            public uint encoder_type;
            
            /// <summary>
            /// Id of crtc
            /// </summary>
            public uint crtc_id;
            
            public uint possible_crtcs;
            
            public uint possible_clones;
        }
        
        /// <summary>
        /// struct drm_mode_get_connector - Get connector metadata.
        /// </summary>
        /// <remarks>
        /// User-space can perform a GETCONNECTOR ioctl to retrieve information about a
        /// connector. User-space is expected to retrieve encoders, modes and properties
        /// by performing this ioctl at least twice: the first time to retrieve the
        /// number of elements, the second time to retrieve the elements themselves.To retrieve the number of elements, set @count _props and @count _encoders to
        /// zero, set @count _modes to 1, and set @modes _ptr to a temporary struct
        /// drm_mode_modeinfo element.To retrieve the elements, allocate arrays for @encoders _ptr, @modes _ptr,
        /// @props _ptr and @prop _values_ptr, then set @count _modes, @count _props and
        /// @count _encoders to their capacity.Performing the ioctl only twice may be racy: the number of elements may have
        /// changed with a hotplug event in-between the two ioctls. User-space is
        /// expected to retry the last ioctl until the number of elements stabilizes.
        /// The kernel won't fill any array which doesn't have the expected length.**Force-probing a connector**If the @count _modes field is set to zero and the DRM client is the current
        /// DRM master, the kernel will perform a forced probe on the connector to
        /// refresh the connector status, modes and EDID. A forced-probe can be slow,
        /// might cause flickering and the ioctl will block.User-space needs to force-probe connectors to ensure their metadata is
        /// up-to-date at startup and after receiving a hot-plug event. User-space
        /// may perform a forced-probe when the user explicitly requests it. User-space
        /// shouldn't perform a forced-probe in other situations.
        /// </remarks>
        public partial struct drm_mode_get_connector
        {
            /// <summary>
            /// _ptr: Pointer to ``__u32`` array of object IDs.
            /// </summary>
            public ulong encoders_ptr;
            
            /// <summary>
            /// _ptr: Pointer to struct drm_mode_modeinfo array.
            /// </summary>
            public ulong modes_ptr;
            
            /// <summary>
            /// _ptr: Pointer to ``__u32`` array of property IDs.
            /// </summary>
            public ulong props_ptr;
            
            /// <summary>
            /// _values_ptr: Pointer to ``__u64`` array of property values.
            /// </summary>
            public ulong prop_values_ptr;
            
            /// <summary>
            /// _modes: Number of modes.
            /// </summary>
            public uint count_modes;
            
            /// <summary>
            /// _props: Number of properties.
            /// </summary>
            public uint count_props;
            
            /// <summary>
            /// _encoders: Number of encoders.
            /// </summary>
            public uint count_encoders;
            
            /// <summary>
            /// _id: Object ID of the current encoder.
            /// </summary>
            public uint encoder_id;
            
            /// <summary>
            /// _id: Object ID of the connector.
            /// </summary>
            public uint connector_id;
            
            /// <summary>
            /// _type: Type of the connector.
            /// </summary>
            /// <remarks>
            /// See DRM_MODE_CONNECTOR_* defines.
            /// </remarks>
            public uint connector_type;
            
            /// <summary>
            /// _type_id: Type-specific connector number.
            /// </summary>
            /// <remarks>
            /// This is not an object ID. This is a per-type connector number. Each
            /// (type, type_id) combination is unique across all connectors of a DRM
            /// device.The (type, type_id) combination is not a stable identifier: the
            /// type_id can change depending on the driver probe order.
            /// </remarks>
            public uint connector_type_id;
            
            /// <summary>
            /// : Status of the connector.
            /// </summary>
            /// <remarks>
            /// See enum drm_connector_status.
            /// </remarks>
            public uint connection;
            
            /// <summary>
            /// _width: Width of the connected sink in millimeters.
            /// </summary>
            public uint mm_width;
            
            /// <summary>
            /// _height: Height of the connected sink in millimeters.
            /// </summary>
            public uint mm_height;
            
            /// <summary>
            /// : Subpixel order of the connected sink.
            /// </summary>
            /// <remarks>
            /// See enum subpixel_order.
            /// </remarks>
            public uint subpixel;
            
            /// <par>
            /// : Padding, must be zero.
            /// </par>
            public uint pad;
        }
        
        /// <summary>
        /// struct drm_mode_property_enum - Description for an enum/bitfield entry.
        /// @value : numeric value for this enum entry.
        /// </summary>
        /// <remarks>
        /// : symbolic name for this enum entry.See struct drm_property_enum for details.
        /// </remarks>
        public unsafe partial struct drm_mode_property_enum
        {
            public ulong value;
            
            public fixed byte name[32];
        }
        
        /// <summary>
        /// struct drm_mode_get_property - Get property metadata.
        /// </summary>
        /// <remarks>
        /// User-space can perform a GETPROPERTY ioctl to retrieve information about a
        /// property. The same property may be attached to multiple objects, see
        /// "Modeset Base Object Abstraction".The meaning of the @values _ptr field changes depending on the property type.
        /// See 
        /// &amp;drm
        /// _property.flags for more details.The_blob_ptr and @count_enum_blobs fields are only meaningful when theproperty has the type 
        /// &amp;DRM
        /// _MODE_PROP_ENUM or 
        /// &amp;DRM
        /// _MODE_PROP_BITMASK. For
        /// backwards compatibility, the kernel will always set @count _enum_blobs to
        /// zero when the property has the type 
        /// &amp;DRM
        /// _MODE_PROP_BLOB. User-space must
        /// ignore these two fields if the property has a different type.User-space is expected to retrieve values and enums by performing this ioctl
        /// at least twice: the first time to retrieve the number of elements, the
        /// second time to retrieve the elements themselves.To retrieve the number of elements, set @count _values and @count _enum_blobs
        /// to zero, then call the ioctl. @count _values will be updated with the number
        /// of elements. If the property has the type 
        /// &amp;DRM
        /// _MODE_PROP_ENUM or
        /// &amp;DRM
        /// _MODE_PROP_BITMASK, @count _enum_blobs will be updated as well.To retrieve the elements themselves, allocate an array for @values _ptr and
        /// set @count _values to its capacity. If the property has the type
        /// &amp;DRM
        /// _MODE_PROP_ENUM or 
        /// &amp;DRM
        /// _MODE_PROP_BITMASK, allocate an array for_blob_ptr and set @count_enum_blobs to its capacity. Calling the ioctlagain will fill the arrays.
        /// </remarks>
        public unsafe partial struct drm_mode_get_property
        {
            /// <summary>
            /// _ptr: Pointer to a ``__u64`` array.
            /// </summary>
            public ulong values_ptr;
            
            /// <remarks>
            /// _blob_ptr: Pointer to a struct drm_mode_property_enum array.
            /// </remarks>
            public ulong enum_blob_ptr;
            
            /// <summary>
            /// @prop _id: Object ID of the property which should be retrieved. Set
            /// by the caller.
            /// </summary>
            public uint prop_id;
            
            /// <summary>
            /// @flags : ``DRM_MODE_PROP_*`` bitfield. See 
            /// &amp;drm
            /// _property.flags for
            /// a definition of the flags.
            /// </summary>
            public uint flags;
            
            /// <remarks>
            /// : Symbolic property name. User-space should use this field torecognize properties.
            /// </remarks>
            public fixed byte name[32];
            
            /// <summary>
            /// _values: Number of elements in @values _ptr.
            /// </summary>
            public uint count_values;
            
            /// <summary>
            /// _enum_blobs: Number of elements in
            /// </summary>
            /// <remarks>
            /// _blob_ptr.
            /// </remarks>
            public uint count_enum_blobs;
        }
        
        public partial struct drm_mode_connector_set_property
        {
            public ulong value;
            
            public uint prop_id;
            
            public uint connector_id;
        }
        
        public partial struct drm_mode_obj_get_properties
        {
            public ulong props_ptr;
            
            public ulong prop_values_ptr;
            
            public uint count_props;
            
            public uint obj_id;
            
            public uint obj_type;
        }
        
        public partial struct drm_mode_obj_set_property
        {
            public ulong value;
            
            public uint prop_id;
            
            public uint obj_id;
            
            public uint obj_type;
        }
        
        public partial struct drm_mode_get_blob
        {
            public uint blob_id;
            
            public uint length;
            
            public ulong data;
        }
        
        public partial struct drm_mode_fb_cmd
        {
            public uint fb_id;
            
            public uint width;
            
            public uint height;
            
            public uint pitch;
            
            public uint bpp;
            
            public uint depth;
            
            /// <summary>
            /// driver specific handle
            /// </summary>
            public uint handle;
        }
        
        /// <summary>
        /// struct drm_mode_fb_cmd2 - Frame-buffer metadata.
        /// </summary>
        /// <remarks>
        /// This struct holds frame-buffer metadata. There are two ways to use it:- User-space can fill this struct and perform a 
        /// &amp;DRM
        /// _IOCTL_MODE_ADDFB2
        /// ioctl to register a new frame-buffer. The new frame-buffer object ID will
        /// be set by the kernel in @fb _id.
        /// - User-space can set @fb _id and perform a 
        /// &amp;DRM
        /// _IOCTL_MODE_GETFB2 ioctl to
        /// fetch metadata about an existing frame-buffer.In case of planar formats, this struct allows up to 4 buffer objects with
        /// offsets and pitches per plane. The pitch and offset order are dictated by
        /// the format FourCC as defined by ``drm_fourcc.h``, e.g. NV12 is described as:YUV 4:2:0 image with a plane of 8-bit Y samples followed by an
        /// interleaved U/V plane containing 8-bit 2x2 subsampled colour difference
        /// samples.So it would consist of a Y plane at ``offsets[0]`` and a UV plane at
        /// ``offsets[1]``.To accommodate tiled, compressed, etc formats, a modifier can be specified.
        /// For more information see the "Format Modifiers" section. Note that even
        /// though it looks like we have a modifier per-plane, we in fact do not. The
        /// modifier for each plane must be identical. Thus all combinations of
        /// different data layouts for multi-plane formats must be enumerated as
        /// separate modifiers.All of the entries in @handles , @pitches , @offsets and @modifier must be
        /// zero when unused. Warning, for @offsets and @modifier zero can't be used to
        /// figure out whether the entry is used or not since it's a valid value (a zero
        /// offset is common, and a zero modifier is 
        /// &amp;DRM
        /// _FORMAT_MOD_LINEAR).
        /// </remarks>
        public unsafe partial struct drm_mode_fb_cmd2
        {
            /// <summary>
            /// _id: Object ID of the frame-buffer.
            /// </summary>
            public uint fb_id;
            
            /// <summary>
            /// : Width of the frame-buffer.
            /// </summary>
            public uint width;
            
            /// <summary>
            /// : Height of the frame-buffer.
            /// </summary>
            public uint height;
            
            /// <summary>
            /// @pixel _format: FourCC format code, see ``DRM_FORMAT_*`` constants in
            /// ``drm_fourcc.h``.
            /// </summary>
            public uint pixel_format;
            
            /// <summary>
            /// @flags : Frame-buffer flags (see 
            /// &amp;DRM
            /// _MODE_FB_INTERLACED and
            /// &amp;DRM
            /// _MODE_FB_MODIFIERS).
            /// </summary>
            public uint flags;
            
            /// <summary>
            /// @handles : GEM buffer handle, one per plane. Set to 0 if the plane is
            /// unused. The same handle can be used for multiple planes.
            /// </summary>
            public fixed uint handles[4];
            
            /// <summary>
            /// : Pitch (aka. stride) in bytes, one per plane.
            /// </summary>
            public fixed uint pitches[4];
            
            /// <summary>
            /// : Offset into the buffer in bytes, one per plane.
            /// </summary>
            public fixed uint offsets[4];
            
            /// <summary>
            /// @modifier : Format modifier, one per plane. See ``DRM_FORMAT_MOD_*``
            /// constants in ``drm_fourcc.h``. All planes must use the same
            /// modifier. Ignored unless 
            /// &amp;DRM
            /// _MODE_FB_MODIFIERS is set in @flags .
            /// </summary>
            public fixed ulong modifier[4];
        }
        
        /// <summary>
        /// Mark a region of a framebuffer as dirty.
        /// </summary>
        /// <remarks>
        /// Some hardware does not automatically update display contents
        /// as a hardware or software draw to a framebuffer. This ioctl
        /// allows userspace to tell the kernel and the hardware what
        /// regions of the framebuffer have changed.The kernel or hardware is free to update more then just the
        /// region specified by the clip rects. The kernel or hardware
        /// may also delay and/or coalesce several calls to dirty into a
        /// single update.Userspace may annotate the updates, the annotates are a
        /// promise made by the caller that the change is either a copy
        /// of pixels or a fill of a single color in the region specified.If the DRM_MODE_FB_DIRTY_ANNOTATE_COPY flag is given then
        /// the number of updated regions are half of num_clips given,
        /// where the clip rects are paired in src and dst. The width and
        /// height of each one of the pairs must match.If the DRM_MODE_FB_DIRTY_ANNOTATE_FILL flag is given the caller
        /// promises that the region specified of the clip rects is filled
        /// completely with a single color as given in the color argument.
        /// </remarks>
        public partial struct drm_mode_fb_dirty_cmd
        {
            public uint fb_id;
            
            public uint flags;
            
            public uint color;
            
            public uint num_clips;
            
            public ulong clips_ptr;
        }
        
        public partial struct drm_mode_mode_cmd
        {
            public uint connector_id;
            
            public libdrm.drm_mode_modeinfo mode;
        }
        
        /// <summary>
        /// depending on the value in flags different members are used.
        /// </summary>
        /// <remarks>
        /// CURSOR_BO uses
        /// crtc_id
        /// width
        /// height
        /// handle - if 0 turns the cursor offCURSOR_MOVE uses
        /// crtc_id
        /// x
        /// y
        /// </remarks>
        public partial struct drm_mode_cursor
        {
            public uint flags;
            
            public uint crtc_id;
            
            public int x;
            
            public int y;
            
            public uint width;
            
            public uint height;
            
            /// <summary>
            /// driver specific handle
            /// </summary>
            public uint handle;
        }
        
        public partial struct drm_mode_cursor2
        {
            public uint flags;
            
            public uint crtc_id;
            
            public int x;
            
            public int y;
            
            public uint width;
            
            public uint height;
            
            /// <summary>
            /// driver specific handle
            /// </summary>
            public uint handle;
            
            public int hot_x;
            
            public int hot_y;
        }
        
        public partial struct drm_mode_crtc_lut
        {
            public uint crtc_id;
            
            public uint gamma_size;
            
            /// <summary>
            /// pointers to arrays
            /// </summary>
            public ulong red;
            
            public ulong green;
            
            public ulong blue;
        }
        
        public unsafe partial struct drm_color_ctm
        {
            /// <summary>
            /// Conversion matrix in S31.32 sign-magnitude
            /// (not two's complement!) format.
            /// </summary>
            /// <remarks>
            /// out   matrix    in
            /// |R|   |0 1 2|   |R|
            /// |G| = |3 4 5| x |G|
            /// |B|   |6 7 8|   |B|
            /// </remarks>
            public fixed ulong matrix[9];
        }
        
        public partial struct drm_color_lut
        {
            /// <summary>
            /// Values are mapped linearly to 0.0 - 1.0 range, with 0x0 == 0.0 and
            /// 0xffff == 1.0.
            /// </summary>
            public ushort red;
            
            public ushort green;
            
            public ushort blue;
            
            public ushort reserved;
        }
        
        /// <summary>
        /// struct drm_plane_size_hint - Plane size hints
        /// </summary>
        /// <remarks>
        /// The plane SIZE_HINTS property blob contains an
        /// array of struct drm_plane_size_hint.
        /// </remarks>
        public partial struct drm_plane_size_hint
        {
            public ushort width;
            
            public ushort height;
        }
        
        /// <summary>
        /// struct hdr_metadata_infoframe - HDR Metadata Infoframe Data.
        /// </summary>
        /// <remarks>
        /// HDR Metadata Infoframe as per CTA 861.G spec. This is expected
        /// to match exactly with the spec.Userspace is expected to pass the metadata information as per
        /// the format described in this structure.
        /// </remarks>
        public partial struct hdr_metadata_infoframe
        {
            public partial struct hdr_metadata_infoframe__struct_0
            {
                public ushort x;
                
                public ushort y;
            }
            
            public partial struct hdr_metadata_infoframe__struct_1
            {
                public ushort x;
                
                public ushort y;
            }
            
            /// <summary>
            /// @eotf : Electro-Optical Transfer Function (EOTF)
            /// used in the stream.
            /// </summary>
            public byte eotf;
            
            /// <summary>
            /// _type: Static_Metadata_Descriptor_ID.
            /// </summary>
            public byte metadata_type;
            
            public FixedArray3<libdrm.hdr_metadata_infoframe.hdr_metadata_infoframe__struct_0> display_primaries;
            
            public libdrm.hdr_metadata_infoframe.hdr_metadata_infoframe__struct_1 white_point;
            
            /// <summary>
            /// @max _display_mastering_luminance: Max Mastering Display Luminance.
            /// This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
            /// where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.
            /// </summary>
            public ushort max_display_mastering_luminance;
            
            /// <summary>
            /// @min _display_mastering_luminance: Min Mastering Display Luminance.
            /// This value is coded as an unsigned 16-bit value in units of
            /// 0.0001 cd/m2, where 0x0001 represents 0.0001 cd/m2 and 0xFFFF
            /// represents 6.5535 cd/m2.
            /// </summary>
            public ushort min_display_mastering_luminance;
            
            /// <summary>
            /// @max _cll: Max Content Light Level.
            /// This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
            /// where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.
            /// </summary>
            public ushort max_cll;
            
            /// <summary>
            /// @max _fall: Max Frame Average Light Level.
            /// This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
            /// where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.
            /// </summary>
            public ushort max_fall;
        }
        
        /// <summary>
        /// struct hdr_output_metadata - HDR output metadata
        /// </summary>
        /// <remarks>
        /// Metadata Information to be passed from userspace
        /// </remarks>
        public partial struct hdr_output_metadata
        {
            [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
            public partial struct hdr_output_metadata__union_0
            {
                [FieldOffset(0)]
                public libdrm.hdr_metadata_infoframe hdmi_metadata_type1;
            }
            
            /// <summary>
            /// _type: Static_Metadata_Descriptor_ID.
            /// </summary>
            public uint metadata_type;
            
            /// <summary>
            /// _metadata_type1: HDR Metadata Infoframe.
            /// </summary>
            public libdrm.hdr_output_metadata.hdr_output_metadata__union_0 hdr_output_metadata__field_1;
        }
        
        /// <summary>
        /// Request a page flip on the specified crtc.
        /// </summary>
        /// <remarks>
        /// This ioctl will ask KMS to schedule a page flip for the specified
        /// crtc.  Once any pending rendering targeting the specified fb (as of
        /// ioctl time) has completed, the crtc will be reprogrammed to display
        /// that fb after the next vertical refresh.  The ioctl returns
        /// immediately, but subsequent rendering to the current fb will block
        /// in the execbuffer ioctl until the page flip happens.  If a page
        /// flip is already pending as the ioctl is called, EBUSY will be
        /// returned.Flag DRM_MODE_PAGE_FLIP_EVENT requests that drm sends back a vblank
        /// event (see drm.h: struct drm_event_vblank) when the page flip is
        /// done.  The user_data field passed in with this ioctl will be
        /// returned as the user_data field in the vblank event struct.Flag DRM_MODE_PAGE_FLIP_ASYNC requests that the flip happen
        /// 'as soon as possible', meaning that it not delay waiting for vblank.
        /// This may cause tearing on the screen.The reserved field must be zero.
        /// </remarks>
        public partial struct drm_mode_crtc_page_flip
        {
            public uint crtc_id;
            
            public uint fb_id;
            
            public uint flags;
            
            public uint reserved;
            
            public ulong user_data;
        }
        
        /// <summary>
        /// Request a page flip on the specified crtc.
        /// </summary>
        /// <remarks>
        /// Same as struct drm_mode_crtc_page_flip, but supports new flags and
        /// re-purposes the reserved field:The sequence field must be zero unless either of the
        /// DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE/RELATIVE flags is specified. When
        /// the ABSOLUTE flag is specified, the sequence field denotes the absolute
        /// vblank sequence when the flip should take effect. When the RELATIVE
        /// flag is specified, the sequence field denotes the relative (to the
        /// current one when the ioctl is called) vblank sequence when the flip
        /// should take effect. NOTE: DRM_IOCTL_WAIT_VBLANK must still be used to
        /// make sure the vblank sequence before the target one has passed before
        /// calling this ioctl. The purpose of the
        /// DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE/RELATIVE flags is merely to clarify
        /// the target for when code dealing with a page flip runs during a
        /// vertical blank period.
        /// </remarks>
        public partial struct drm_mode_crtc_page_flip_target
        {
            public uint crtc_id;
            
            public uint fb_id;
            
            public uint flags;
            
            public uint sequence;
            
            public ulong user_data;
        }
        
        /// <summary>
        /// struct drm_mode_create_dumb - Create a KMS dumb buffer for scanout.
        /// @height : buffer height in pixels
        /// @width : buffer width in pixels
        /// @bpp : bits per pixel
        /// @flags : must be zero
        /// @handle : buffer object handle
        /// @pitch : number of bytes between two consecutive lines
        /// @size : size of the whole buffer in bytes
        /// </summary>
        /// <remarks>
        /// User-space fills @height , @width , @bpp and @flags . If the IOCTL succeeds,
        /// the kernel fills @handle , @pitch and @size .
        /// </remarks>
        public partial struct drm_mode_create_dumb
        {
            public uint height;
            
            public uint width;
            
            public uint bpp;
            
            public uint flags;
            
            public uint handle;
            
            public uint pitch;
            
            public ulong size;
        }
        
        /// <summary>
        /// set up for mmap of a dumb scanout buffer
        /// </summary>
        public partial struct drm_mode_map_dumb
        {
            /// <summary>
            /// Handle for the object being mapped.
            /// </summary>
            public uint handle;
            
            public uint pad;
            
            /// <summary>
            /// Fake offset to use for subsequent mmap call
            /// </summary>
            /// <remarks>
            /// This is a fixed-size type for 32/64 compatibility.
            /// </remarks>
            public ulong offset;
        }
        
        public partial struct drm_mode_destroy_dumb
        {
            public uint handle;
        }
        
        public partial struct drm_mode_atomic
        {
            public uint flags;
            
            public uint count_objs;
            
            public ulong objs_ptr;
            
            public ulong count_props_ptr;
            
            public ulong props_ptr;
            
            public ulong prop_values_ptr;
            
            public ulong reserved;
            
            public ulong user_data;
        }
        
        public partial struct drm_format_modifier_blob
        {
            /// <summary>
            /// Version of this blob format
            /// </summary>
            public uint version;
            
            /// <summary>
            /// Flags
            /// </summary>
            public uint flags;
            
            /// <summary>
            /// Number of fourcc formats supported
            /// </summary>
            public uint count_formats;
            
            /// <summary>
            /// Where in this blob the formats exist (in bytes)
            /// </summary>
            public uint formats_offset;
            
            /// <summary>
            /// Number of drm_format_modifiers
            /// </summary>
            public uint count_modifiers;
            
            /// <summary>
            /// Where in this blob the modifiers exist (in bytes)
            /// </summary>
            public uint modifiers_offset;
        }
        
        public partial struct drm_format_modifier
        {
            /// <summary>
            /// Bitmask of formats in get_plane format list this info applies to. The
            /// offset allows a sliding window of which 64 formats (bits).
            /// </summary>
            /// <remarks>
            /// Some examples:
            /// In today's world with 
            /// &lt;
            /// 65 formats, and formats 0, and 2 are
            /// supported
            /// 0x0000000000000005
            /// ^-offset = 0, formats = 5If the number formats grew to 128, and formats 98-102 are
            /// supported with the modifier:0x0000007c00000000 0000000000000000
            /// ^
            /// |__offset = 64, formats = 0x7c00000000
            /// </remarks>
            public ulong formats;
            
            public uint offset;
            
            public uint pad;
            
            /// <summary>
            /// The modifier that applies to the &gt;get_plane format list bitmask.
            /// </summary>
            public ulong modifier;
        }
        
        /// <summary>
        /// struct drm_mode_create_blob - Create New blob property
        /// </summary>
        /// <remarks>
        /// Create a new 'blob' data property, copying length bytes from data pointer,
        /// and returning new blob ID.
        /// </remarks>
        public partial struct drm_mode_create_blob
        {
            /// <date>
            /// : Pointer to data to copy.
            /// </date>
            public ulong data;
            
            /// <summary>
            /// : Length of data to copy.
            /// </summary>
            public uint length;
            
            /// <summary>
            /// _id: Return: new property ID.
            /// </summary>
            public uint blob_id;
        }
        
        /// <summary>
        /// struct drm_mode_destroy_blob - Destroy user blob
        /// @blob _id: blob_id to destroy
        /// </summary>
        /// <remarks>
        /// Destroy a user-created blob property.User-space can release blobs as soon as they do not need to refer to them by
        /// their blob object ID.  For instance, if you are using a MODE_ID blob in an
        /// atomic commit and you will not make another commit re-using the same ID, you
        /// can destroy the blob as soon as the commit has been issued, without waiting
        /// for it to complete.
        /// </remarks>
        public partial struct drm_mode_destroy_blob
        {
            public uint blob_id;
        }
        
        /// <summary>
        /// struct drm_mode_create_lease - Create lease
        /// </summary>
        /// <remarks>
        /// Lease mode resources, creating another drm_master.The @object _ids array must reference at least one CRTC, one connector and
        /// one plane if 
        /// &amp;DRM
        /// _CLIENT_CAP_UNIVERSAL_PLANES is enabled. Alternatively,
        /// the lease can be completely empty.
        /// </remarks>
        public partial struct drm_mode_create_lease
        {
            /// <summary>
            /// _ids: Pointer to array of object ids (__u32)
            /// </summary>
            public ulong object_ids;
            
            /// <summary>
            /// _count: Number of object ids
            /// </summary>
            public uint object_count;
            
            /// <summary>
            /// : flags for new FD (O_CLOEXEC, etc)
            /// </summary>
            public uint flags;
            
            /// <summary>
            /// _id: Return: unique identifier for lessee.
            /// </summary>
            public uint lessee_id;
            
            /// <summary>
            /// : Return: file descriptor to new drm_master file
            /// </summary>
            public uint fd;
        }
        
        /// <summary>
        /// struct drm_mode_list_lessees - List lessees
        /// </summary>
        /// <remarks>
        /// List lesses from a drm_master.
        /// </remarks>
        public partial struct drm_mode_list_lessees
        {
            /// <summary>
            /// _lessees: Number of lessees.
            /// </summary>
            /// <remarks>
            /// On input, provides length of the array.
            /// On output, provides total number. No
            /// more than the input number will be written
            /// back, so two calls can be used to get
            /// the size and then the data.
            /// </remarks>
            public uint count_lessees;
            
            /// <par>
            /// : Padding.
            /// </par>
            public uint pad;
            
            /// <summary>
            /// _ptr: Pointer to lessees.
            /// </summary>
            /// <remarks>
            /// Pointer to __u64 array of lessee ids
            /// </remarks>
            public ulong lessees_ptr;
        }
        
        /// <summary>
        /// struct drm_mode_get_lease - Get Lease
        /// </summary>
        /// <remarks>
        /// Get leased objects.
        /// </remarks>
        public partial struct drm_mode_get_lease
        {
            /// <summary>
            /// _objects: Number of leased objects.
            /// </summary>
            /// <remarks>
            /// On input, provides length of the array.
            /// On output, provides total number. No
            /// more than the input number will be written
            /// back, so two calls can be used to get
            /// the size and then the data.
            /// </remarks>
            public uint count_objects;
            
            /// <par>
            /// : Padding.
            /// </par>
            public uint pad;
            
            /// <summary>
            /// _ptr: Pointer to objects.
            /// </summary>
            /// <remarks>
            /// Pointer to __u32 array of object ids.
            /// </remarks>
            public ulong objects_ptr;
        }
        
        /// <summary>
        /// struct drm_mode_revoke_lease - Revoke lease
        /// </summary>
        public partial struct drm_mode_revoke_lease
        {
            /// <summary>
            /// _id: Unique ID of lessee
            /// </summary>
            public uint lessee_id;
        }
        
        /// <summary>
        /// struct drm_mode_rect - Two dimensional rectangle.
        /// @x1 : Horizontal starting coordinate (inclusive).
        /// @y1 : Vertical starting coordinate (inclusive).
        /// @x2 : Horizontal ending coordinate (exclusive).
        /// @y2 : Vertical ending coordinate (exclusive).
        /// </summary>
        /// <remarks>
        /// With drm subsystem using struct drm_rect to manage rectangular area this
        /// export it to user-space.Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS.
        /// </remarks>
        public partial struct drm_mode_rect
        {
            public int x1;
            
            public int y1;
            
            public int x2;
            
            public int y2;
        }
        
        /// <summary>
        /// struct drm_mode_closefb
        /// @fb _id: Framebuffer ID.
        /// </summary>
        /// <par>
        /// : Must be zero.
        /// </par>
        public partial struct drm_mode_closefb
        {
            public uint fb_id;
            
            public uint pad;
        }
    }
}
