//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    public static unsafe partial class libdrm
    {
        /// <summary>
        /// Type of memory to map.
        /// </summary>
        public enum drm_map_type : uint
        {
            /// <summary>
            /// WC (no caching), no core dump
            /// </summary>
            _DRM_FRAME_BUFFER = unchecked((uint)0),
            
            /// <summary>
            /// no caching, no core dump
            /// </summary>
            _DRM_REGISTERS = unchecked((uint)1),
            
            /// <summary>
            /// shared, cached
            /// </summary>
            _DRM_SHM = unchecked((uint)2),
            
            /// <summary>
            /// AGP/GART
            /// </summary>
            _DRM_AGP = unchecked((uint)3),
            
            /// <summary>
            /// Scatter/gather memory for PCI DMA
            /// </summary>
            _DRM_SCATTER_GATHER = unchecked((uint)4),
            
            /// <summary>
            /// Consistent memory for PCI DMA
            /// </summary>
            _DRM_CONSISTENT = unchecked((uint)5),
        }
        
        /// <summary>
        /// WC (no caching), no core dump
        /// </summary>
        public const libdrm.drm_map_type _DRM_FRAME_BUFFER = drm_map_type._DRM_FRAME_BUFFER;
        
        /// <summary>
        /// no caching, no core dump
        /// </summary>
        public const libdrm.drm_map_type _DRM_REGISTERS = drm_map_type._DRM_REGISTERS;
        
        /// <summary>
        /// shared, cached
        /// </summary>
        public const libdrm.drm_map_type _DRM_SHM = drm_map_type._DRM_SHM;
        
        /// <summary>
        /// AGP/GART
        /// </summary>
        public const libdrm.drm_map_type _DRM_AGP = drm_map_type._DRM_AGP;
        
        /// <summary>
        /// Scatter/gather memory for PCI DMA
        /// </summary>
        public const libdrm.drm_map_type _DRM_SCATTER_GATHER = drm_map_type._DRM_SCATTER_GATHER;
        
        /// <summary>
        /// Consistent memory for PCI DMA
        /// </summary>
        public const libdrm.drm_map_type _DRM_CONSISTENT = drm_map_type._DRM_CONSISTENT;
        
        /// <summary>
        /// Memory mapping flags.
        /// </summary>
        public enum drm_map_flags : uint
        {
            /// <summary>
            /// Cannot be mapped to user-virtual
            /// </summary>
            _DRM_RESTRICTED = unchecked((uint)1),
            
            _DRM_READ_ONLY = unchecked((uint)2),
            
            /// <summary>
            /// shared, cached, locked
            /// </summary>
            _DRM_LOCKED = unchecked((uint)4),
            
            /// <summary>
            /// kernel requires access
            /// </summary>
            _DRM_KERNEL = unchecked((uint)8),
            
            /// <summary>
            /// use write-combining if available
            /// </summary>
            _DRM_WRITE_COMBINING = unchecked((uint)16),
            
            /// <summary>
            /// SHM page that contains lock
            /// </summary>
            _DRM_CONTAINS_LOCK = unchecked((uint)32),
            
            /// <summary>
            /// Removable mapping
            /// </summary>
            _DRM_REMOVABLE = unchecked((uint)64),
            
            /// <summary>
            /// Managed by driver
            /// </summary>
            _DRM_DRIVER = unchecked((uint)128),
        }
        
        /// <summary>
        /// Cannot be mapped to user-virtual
        /// </summary>
        public const libdrm.drm_map_flags _DRM_RESTRICTED = drm_map_flags._DRM_RESTRICTED;
        
        public const libdrm.drm_map_flags _DRM_READ_ONLY = drm_map_flags._DRM_READ_ONLY;
        
        /// <summary>
        /// shared, cached, locked
        /// </summary>
        public const libdrm.drm_map_flags _DRM_LOCKED = drm_map_flags._DRM_LOCKED;
        
        /// <summary>
        /// kernel requires access
        /// </summary>
        public const libdrm.drm_map_flags _DRM_KERNEL = drm_map_flags._DRM_KERNEL;
        
        /// <summary>
        /// use write-combining if available
        /// </summary>
        public const libdrm.drm_map_flags _DRM_WRITE_COMBINING = drm_map_flags._DRM_WRITE_COMBINING;
        
        /// <summary>
        /// SHM page that contains lock
        /// </summary>
        public const libdrm.drm_map_flags _DRM_CONTAINS_LOCK = drm_map_flags._DRM_CONTAINS_LOCK;
        
        /// <summary>
        /// Removable mapping
        /// </summary>
        public const libdrm.drm_map_flags _DRM_REMOVABLE = drm_map_flags._DRM_REMOVABLE;
        
        /// <summary>
        /// Managed by driver
        /// </summary>
        public const libdrm.drm_map_flags _DRM_DRIVER = drm_map_flags._DRM_DRIVER;
        
        public enum drm_stat_type : uint
        {
            _DRM_STAT_LOCK = unchecked((uint)0),
            
            _DRM_STAT_OPENS = unchecked((uint)1),
            
            _DRM_STAT_CLOSES = unchecked((uint)2),
            
            _DRM_STAT_IOCTLS = unchecked((uint)3),
            
            _DRM_STAT_LOCKS = unchecked((uint)4),
            
            _DRM_STAT_UNLOCKS = unchecked((uint)5),
            
            /// <summary>
            /// Generic value
            /// </summary>
            _DRM_STAT_VALUE = unchecked((uint)6),
            
            /// <summary>
            /// Generic byte counter (1024bytes/K)
            /// </summary>
            _DRM_STAT_BYTE = unchecked((uint)7),
            
            /// <summary>
            /// Generic non-byte counter (1000/k)
            /// </summary>
            _DRM_STAT_COUNT = unchecked((uint)8),
            
            /// <summary>
            /// IRQ
            /// </summary>
            _DRM_STAT_IRQ = unchecked((uint)9),
            
            /// <summary>
            /// Primary DMA bytes
            /// </summary>
            _DRM_STAT_PRIMARY = unchecked((uint)10),
            
            /// <summary>
            /// Secondary DMA bytes
            /// </summary>
            _DRM_STAT_SECONDARY = unchecked((uint)11),
            
            /// <summary>
            /// DMA
            /// </summary>
            _DRM_STAT_DMA = unchecked((uint)12),
            
            /// <summary>
            /// Special DMA (e.g., priority or polled)
            /// </summary>
            _DRM_STAT_SPECIAL = unchecked((uint)13),
            
            /// <summary>
            /// Missed DMA opportunity
            /// </summary>
            _DRM_STAT_MISSED = unchecked((uint)14),
        }
        
        public const libdrm.drm_stat_type _DRM_STAT_LOCK = drm_stat_type._DRM_STAT_LOCK;
        
        public const libdrm.drm_stat_type _DRM_STAT_OPENS = drm_stat_type._DRM_STAT_OPENS;
        
        public const libdrm.drm_stat_type _DRM_STAT_CLOSES = drm_stat_type._DRM_STAT_CLOSES;
        
        public const libdrm.drm_stat_type _DRM_STAT_IOCTLS = drm_stat_type._DRM_STAT_IOCTLS;
        
        public const libdrm.drm_stat_type _DRM_STAT_LOCKS = drm_stat_type._DRM_STAT_LOCKS;
        
        public const libdrm.drm_stat_type _DRM_STAT_UNLOCKS = drm_stat_type._DRM_STAT_UNLOCKS;
        
        /// <summary>
        /// Generic value
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_VALUE = drm_stat_type._DRM_STAT_VALUE;
        
        /// <summary>
        /// Generic byte counter (1024bytes/K)
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_BYTE = drm_stat_type._DRM_STAT_BYTE;
        
        /// <summary>
        /// Generic non-byte counter (1000/k)
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_COUNT = drm_stat_type._DRM_STAT_COUNT;
        
        /// <summary>
        /// IRQ
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_IRQ = drm_stat_type._DRM_STAT_IRQ;
        
        /// <summary>
        /// Primary DMA bytes
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_PRIMARY = drm_stat_type._DRM_STAT_PRIMARY;
        
        /// <summary>
        /// Secondary DMA bytes
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_SECONDARY = drm_stat_type._DRM_STAT_SECONDARY;
        
        /// <summary>
        /// DMA
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_DMA = drm_stat_type._DRM_STAT_DMA;
        
        /// <summary>
        /// Special DMA (e.g., priority or polled)
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_SPECIAL = drm_stat_type._DRM_STAT_SPECIAL;
        
        /// <summary>
        /// Missed DMA opportunity
        /// </summary>
        public const libdrm.drm_stat_type _DRM_STAT_MISSED = drm_stat_type._DRM_STAT_MISSED;
        
        /// <summary>
        /// Hardware locking flags.
        /// </summary>
        public enum drm_lock_flags : uint
        {
            /// <summary>
            /// Wait until hardware is ready for DMA
            /// </summary>
            _DRM_LOCK_READY = unchecked((uint)1),
            
            /// <summary>
            /// Wait until hardware quiescent
            /// </summary>
            _DRM_LOCK_QUIESCENT = unchecked((uint)2),
            
            /// <summary>
            /// Flush this context's DMA queue first
            /// </summary>
            _DRM_LOCK_FLUSH = unchecked((uint)4),
            
            /// <summary>
            /// Flush all DMA queues first
            /// </summary>
            _DRM_LOCK_FLUSH_ALL = unchecked((uint)8),
            
            /// <summary>
            /// Halt all current and future queues
            /// </summary>
            _DRM_HALT_ALL_QUEUES = unchecked((uint)16),
            
            /// <summary>
            /// Halt all current queues
            /// </summary>
            _DRM_HALT_CUR_QUEUES = unchecked((uint)32),
        }
        
        /// <summary>
        /// Wait until hardware is ready for DMA
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_LOCK_READY = drm_lock_flags._DRM_LOCK_READY;
        
        /// <summary>
        /// Wait until hardware quiescent
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_LOCK_QUIESCENT = drm_lock_flags._DRM_LOCK_QUIESCENT;
        
        /// <summary>
        /// Flush this context's DMA queue first
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_LOCK_FLUSH = drm_lock_flags._DRM_LOCK_FLUSH;
        
        /// <summary>
        /// Flush all DMA queues first
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_LOCK_FLUSH_ALL = drm_lock_flags._DRM_LOCK_FLUSH_ALL;
        
        /// <summary>
        /// Halt all current and future queues
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_HALT_ALL_QUEUES = drm_lock_flags._DRM_HALT_ALL_QUEUES;
        
        /// <summary>
        /// Halt all current queues
        /// </summary>
        public const libdrm.drm_lock_flags _DRM_HALT_CUR_QUEUES = drm_lock_flags._DRM_HALT_CUR_QUEUES;
        
        /// <summary>
        /// DMA flags
        /// </summary>
        /// <seealso cref="drm_dma."/>
        /// <warning>
        /// @warning These values @e must match xf86drm.h.
        /// </warning>
        public enum drm_dma_flags : uint
        {
            /// <summary>
            /// Block until buffer dispatched.
            /// </summary>
            /// <note>
            /// @note The buffer may not yet have
            /// been processed by the hardware --
            /// getting a hardware lock with the
            /// hardware quiescent will ensure
            /// that the buffer has been
            /// processed.
            /// </note>
            _DRM_DMA_BLOCK = unchecked((uint)1),
            
            /// <summary>
            /// Dispatch while lock held
            /// </summary>
            _DRM_DMA_WHILE_LOCKED = unchecked((uint)2),
            
            /// <summary>
            /// High priority dispatch
            /// </summary>
            _DRM_DMA_PRIORITY = unchecked((uint)4),
            
            /// <summary>
            /// Wait for free buffers
            /// </summary>
            _DRM_DMA_WAIT = unchecked((uint)16),
            
            /// <summary>
            /// Smaller-than-requested buffers OK
            /// </summary>
            _DRM_DMA_SMALLER_OK = unchecked((uint)32),
            
            /// <summary>
            /// Larger-than-requested buffers OK
            /// </summary>
            _DRM_DMA_LARGER_OK = unchecked((uint)64),
        }
        
        /// <summary>
        /// Block until buffer dispatched.
        /// </summary>
        /// <note>
        /// @note The buffer may not yet have
        /// been processed by the hardware --
        /// getting a hardware lock with the
        /// hardware quiescent will ensure
        /// that the buffer has been
        /// processed.
        /// </note>
        public const libdrm.drm_dma_flags _DRM_DMA_BLOCK = drm_dma_flags._DRM_DMA_BLOCK;
        
        /// <summary>
        /// Dispatch while lock held
        /// </summary>
        public const libdrm.drm_dma_flags _DRM_DMA_WHILE_LOCKED = drm_dma_flags._DRM_DMA_WHILE_LOCKED;
        
        /// <summary>
        /// High priority dispatch
        /// </summary>
        public const libdrm.drm_dma_flags _DRM_DMA_PRIORITY = drm_dma_flags._DRM_DMA_PRIORITY;
        
        /// <summary>
        /// Wait for free buffers
        /// </summary>
        public const libdrm.drm_dma_flags _DRM_DMA_WAIT = drm_dma_flags._DRM_DMA_WAIT;
        
        /// <summary>
        /// Smaller-than-requested buffers OK
        /// </summary>
        public const libdrm.drm_dma_flags _DRM_DMA_SMALLER_OK = drm_dma_flags._DRM_DMA_SMALLER_OK;
        
        /// <summary>
        /// Larger-than-requested buffers OK
        /// </summary>
        public const libdrm.drm_dma_flags _DRM_DMA_LARGER_OK = drm_dma_flags._DRM_DMA_LARGER_OK;
        
        public enum drm_ctx_flags : uint
        {
            _DRM_CONTEXT_PRESERVED = unchecked((uint)1),
            
            _DRM_CONTEXT_2DONLY = unchecked((uint)2),
        }
        
        public const libdrm.drm_ctx_flags _DRM_CONTEXT_PRESERVED = drm_ctx_flags._DRM_CONTEXT_PRESERVED;
        
        public const libdrm.drm_ctx_flags _DRM_CONTEXT_2DONLY = drm_ctx_flags._DRM_CONTEXT_2DONLY;
        
        /// <summary>
        /// DRM_IOCTL_UPDATE_DRAW ioctl argument type.
        /// </summary>
        public enum drm_drawable_info_type_t : uint
        {
            DRM_DRAWABLE_CLIPRECTS = unchecked((uint)0),
        }
        
        public const libdrm.drm_drawable_info_type_t DRM_DRAWABLE_CLIPRECTS = drm_drawable_info_type_t.DRM_DRAWABLE_CLIPRECTS;
        
        public enum drm_vblank_seq_type : uint
        {
            /// <summary>
            /// Wait for specific vblank sequence number
            /// </summary>
            _DRM_VBLANK_ABSOLUTE = unchecked((uint)0),
            
            /// <summary>
            /// Wait for given number of vblanks
            /// </summary>
            _DRM_VBLANK_RELATIVE = unchecked((uint)1),
            
            /// <summary>
            /// bits 1-6 are reserved for high crtcs
            /// </summary>
            _DRM_VBLANK_HIGH_CRTC_MASK = unchecked((uint)62),
            
            /// <summary>
            /// Send event instead of blocking
            /// </summary>
            _DRM_VBLANK_EVENT = unchecked((uint)67108864),
            
            /// <summary>
            /// Scheduled buffer swap should flip
            /// </summary>
            _DRM_VBLANK_FLIP = unchecked((uint)134217728),
            
            /// <summary>
            /// If missed, wait for next vblank
            /// </summary>
            _DRM_VBLANK_NEXTONMISS = unchecked((uint)268435456),
            
            /// <summary>
            /// Secondary display controller
            /// </summary>
            _DRM_VBLANK_SECONDARY = unchecked((uint)536870912),
            
            /// <summary>
            /// Send signal instead of blocking, unsupported
            /// </summary>
            _DRM_VBLANK_SIGNAL = unchecked((uint)1073741824),
        }
        
        /// <summary>
        /// Wait for specific vblank sequence number
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_ABSOLUTE = drm_vblank_seq_type._DRM_VBLANK_ABSOLUTE;
        
        /// <summary>
        /// Wait for given number of vblanks
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_RELATIVE = drm_vblank_seq_type._DRM_VBLANK_RELATIVE;
        
        /// <summary>
        /// bits 1-6 are reserved for high crtcs
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_HIGH_CRTC_MASK = drm_vblank_seq_type._DRM_VBLANK_HIGH_CRTC_MASK;
        
        /// <summary>
        /// Send event instead of blocking
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_EVENT = drm_vblank_seq_type._DRM_VBLANK_EVENT;
        
        /// <summary>
        /// Scheduled buffer swap should flip
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_FLIP = drm_vblank_seq_type._DRM_VBLANK_FLIP;
        
        /// <summary>
        /// If missed, wait for next vblank
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_NEXTONMISS = drm_vblank_seq_type._DRM_VBLANK_NEXTONMISS;
        
        /// <summary>
        /// Secondary display controller
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_SECONDARY = drm_vblank_seq_type._DRM_VBLANK_SECONDARY;
        
        /// <summary>
        /// Send signal instead of blocking, unsupported
        /// </summary>
        public const libdrm.drm_vblank_seq_type _DRM_VBLANK_SIGNAL = drm_vblank_seq_type._DRM_VBLANK_SIGNAL;
        
        /// <summary>
        /// Cliprect.
        /// </summary>
        /// <note>
        /// @note KW: Actually it's illegal to change either for
        /// backwards-compatibility reasons.
        /// </note>
        /// <warning>
        /// @warning : If you change this structure, make sure you change
        /// XF86DRIClipRectRec in the server as well
        /// </warning>
        public partial struct drm_clip_rect
        {
            public ushort x1;
            
            public ushort y1;
            
            public ushort x2;
            
            public ushort y2;
        }
        
        /// <summary>
        /// Drawable information.
        /// </summary>
        public partial struct drm_drawable_info
        {
            public uint num_rects;
            
            public libdrm.drm_clip_rect* rects;
        }
        
        /// <summary>
        /// Texture region,
        /// </summary>
        public partial struct drm_tex_region
        {
            public byte next;
            
            public byte prev;
            
            public byte in_use;
            
            public byte padding;
            
            public uint age;
        }
        
        /// <summary>
        /// Hardware lock.
        /// </summary>
        /// <remarks>
        /// The lock structure is a simple cache-line aligned integer.  To avoid
        /// processor bus contention on a multiprocessor system, there should not be any
        /// other data stored in the same cache line.
        /// </remarks>
        public unsafe partial struct drm_hw_lock
        {
            /// <summary>
            /// lock variable
            /// </summary>
            public uint @lock;
            
            /// <summary>
            /// Pad to cache line
            /// </summary>
            public fixed byte padding[60];
        }
        
        /// <summary>
        /// DRM_IOCTL_VERSION ioctl argument type.
        /// </summary>
        /// <seealso cref="drmGetVersion()."/>
        public partial struct drm_version
        {
            /// <summary>
            /// Major version
            /// </summary>
            public int version_major;
            
            /// <summary>
            /// Minor version
            /// </summary>
            public int version_minor;
            
            /// <summary>
            /// Patch level
            /// </summary>
            public int version_patchlevel;
            
            /// <summary>
            /// Length of name buffer
            /// </summary>
            public nuint name_len;
            
            /// <summary>
            /// Name of driver
            /// </summary>
            public byte* name;
            
            /// <summary>
            /// Length of date buffer
            /// </summary>
            public nuint date_len;
            
            /// <summary>
            /// User-space buffer to hold date
            /// </summary>
            public byte* date;
            
            /// <summary>
            /// Length of desc buffer
            /// </summary>
            public nuint desc_len;
            
            /// <summary>
            /// User-space buffer to hold desc
            /// </summary>
            public byte* desc;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_UNIQUE ioctl argument type.
        /// </summary>
        /// <seealso cref="drmGetBusid() and drmSetBusId()."/>
        public partial struct drm_unique
        {
            /// <summary>
            /// Length of unique
            /// </summary>
            public nuint unique_len;
            
            /// <summary>
            /// Unique name for driver instantiation
            /// </summary>
            public byte* unique;
        }
        
        public partial struct drm_list
        {
            /// <summary>
            /// Length of user-space structures
            /// </summary>
            public int count;
            
            public libdrm.drm_version* version;
        }
        
        public partial struct drm_block
        {
            public int unused;
        }
        
        /// <summary>
        /// DRM_IOCTL_CONTROL ioctl argument type.
        /// </summary>
        /// <seealso cref="drmCtlInstHandler() and drmCtlUninstHandler()."/>
        public partial struct drm_control
        {
            public enum drm_control__enum_0 : uint
            {
                DRM_ADD_COMMAND = unchecked((uint)0),
                
                DRM_RM_COMMAND = unchecked((uint)1),
                
                DRM_INST_HANDLER = unchecked((uint)2),
                
                DRM_UNINST_HANDLER = unchecked((uint)3),
            }
            
            public libdrm.drm_control.drm_control__enum_0 func;
            
            public int irq;
        }
        
        public partial struct drm_ctx_priv_map
        {
            /// <summary>
            /// Context requesting private mapping
            /// </summary>
            public uint ctx_id;
            
            /// <summary>
            /// Handle of map
            /// </summary>
            public void* handle;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
        /// argument type.
        /// </summary>
        /// <seealso cref="drmAddMap()."/>
        public partial struct drm_map
        {
            /// <summary>
            /// Requested physical address (0 for SAREA)
            /// </summary>
            public nuint offset;
            
            /// <summary>
            /// Requested physical size (bytes)
            /// </summary>
            public nuint size;
            
            /// <summary>
            /// Type of memory to map
            /// </summary>
            public libdrm.drm_map_type type;
            
            /// <summary>
            /// Flags
            /// </summary>
            public libdrm.drm_map_flags flags;
            
            /// <summary>
            /// User-space: "Handle" to pass to mmap()
            /// </summary>
            /// <remarks>
            /// Kernel-space: kernel-virtual address
            /// </remarks>
            public void* handle;
            
            /// <summary>
            /// MTRR slot used
            /// </summary>
            public int mtrr;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_CLIENT ioctl argument type.
        /// </summary>
        public partial struct drm_client
        {
            /// <summary>
            /// Which client desired?
            /// </summary>
            public int idx;
            
            /// <summary>
            /// Is client authenticated?
            /// </summary>
            public int auth;
            
            /// <summary>
            /// Process ID
            /// </summary>
            public nuint pid;
            
            /// <summary>
            /// User ID
            /// </summary>
            public nuint uid;
            
            /// <summary>
            /// Magic
            /// </summary>
            public nuint magic;
            
            /// <summary>
            /// Ioctl count
            /// </summary>
            public nuint iocs;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_STATS ioctl argument type.
        /// </summary>
        public partial struct drm_stats
        {
            public partial struct drm_stats__struct_0
            {
                public nuint value;
                
                public libdrm.drm_stat_type type;
            }
            
            public nuint count;
            
            public FixedArray15<libdrm.drm_stats.drm_stats__struct_0> data;
        }
        
        /// <summary>
        /// DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
        /// </summary>
        /// <seealso cref="drmGetLock() and drmUnlock()."/>
        public partial struct drm_lock
        {
            public int context;
            
            public libdrm.drm_lock_flags flags;
        }
        
        /// <summary>
        /// DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
        /// </summary>
        /// <seealso cref="drmAddBufs()."/>
        public partial struct drm_buf_desc
        {
            public enum drm_buf_desc__enum_0 : uint
            {
                /// <summary>
                /// Align on page boundaries for DMA
                /// </summary>
                _DRM_PAGE_ALIGN = unchecked((uint)1),
                
                /// <summary>
                /// Buffer is in AGP space
                /// </summary>
                _DRM_AGP_BUFFER = unchecked((uint)2),
                
                /// <summary>
                /// Scatter/gather memory buffer
                /// </summary>
                _DRM_SG_BUFFER = unchecked((uint)4),
                
                /// <summary>
                /// Buffer is in frame buffer
                /// </summary>
                _DRM_FB_BUFFER = unchecked((uint)8),
                
                /// <summary>
                /// Map PCI DMA buffer read-only
                /// </summary>
                _DRM_PCI_BUFFER_RO = unchecked((uint)16),
            }
            
            /// <summary>
            /// Number of buffers of this size
            /// </summary>
            public int count;
            
            /// <summary>
            /// Size in bytes
            /// </summary>
            public int size;
            
            /// <summary>
            /// Low water mark
            /// </summary>
            public int low_mark;
            
            /// <summary>
            /// High water mark
            /// </summary>
            public int high_mark;
            
            public libdrm.drm_buf_desc.drm_buf_desc__enum_0 flags;
            
            /// <summary>
            /// Start address of where the AGP buffers are
            /// in the AGP aperture
            /// </summary>
            public nuint agp_start;
        }
        
        /// <summary>
        /// DRM_IOCTL_INFO_BUFS ioctl argument type.
        /// </summary>
        public partial struct drm_buf_info
        {
            /// <summary>
            /// Entries in list
            /// </summary>
            public int count;
            
            public libdrm.drm_buf_desc* list;
        }
        
        /// <summary>
        /// DRM_IOCTL_FREE_BUFS ioctl argument type.
        /// </summary>
        public partial struct drm_buf_free
        {
            public int count;
            
            public int* list;
        }
        
        /// <summary>
        /// Buffer information
        /// </summary>
        /// <seealso cref="drm_buf_map."/>
        public partial struct drm_buf_pub
        {
            /// <summary>
            /// Index into the master buffer list
            /// </summary>
            public int idx;
            
            /// <summary>
            /// Buffer size
            /// </summary>
            public int total;
            
            /// <summary>
            /// Amount of buffer in use (for DMA)
            /// </summary>
            public int used;
            
            /// <summary>
            /// Address of buffer
            /// </summary>
            public void* address;
        }
        
        /// <summary>
        /// DRM_IOCTL_MAP_BUFS ioctl argument type.
        /// </summary>
        public partial struct drm_buf_map
        {
            /// <summary>
            /// Length of the buffer list
            /// </summary>
            public int count;
            
            public void* virt;
            
            /// <summary>
            /// Buffer information
            /// </summary>
            public libdrm.drm_buf_pub* list;
        }
        
        /// <summary>
        /// DRM_IOCTL_DMA ioctl argument type.
        /// </summary>
        /// <remarks>
        /// Indices here refer to the offset into the buffer list in drm_buf_get.
        /// </remarks>
        /// <seealso cref="drmDMA()."/>
        public partial struct drm_dma
        {
            /// <summary>
            /// Context handle
            /// </summary>
            public int context;
            
            /// <summary>
            /// Number of buffers to send
            /// </summary>
            public int send_count;
            
            /// <summary>
            /// List of handles to buffers
            /// </summary>
            public int* send_indices;
            
            /// <summary>
            /// Lengths of data to send
            /// </summary>
            public int* send_sizes;
            
            /// <summary>
            /// Flags
            /// </summary>
            public libdrm.drm_dma_flags flags;
            
            /// <summary>
            /// Number of buffers requested
            /// </summary>
            public int request_count;
            
            /// <summary>
            /// Desired size for buffers
            /// </summary>
            public int request_size;
            
            /// <summary>
            /// Buffer information
            /// </summary>
            public int* request_indices;
            
            public int* request_sizes;
            
            /// <summary>
            /// Number of buffers granted
            /// </summary>
            public int granted_count;
        }
        
        /// <summary>
        /// DRM_IOCTL_ADD_CTX ioctl argument type.
        /// </summary>
        /// <seealso cref="drmCreateContext() and drmDestroyContext()."/>
        public partial struct drm_ctx
        {
            public libdrm.drm_context_t handle;
            
            public libdrm.drm_ctx_flags flags;
        }
        
        public readonly partial struct drm_context_t : IEquatable<libdrm.drm_context_t>
        {
            public drm_context_t(uint value) => this.Value = value;
            
            public uint Value { get; }
            
            public override bool Equals(object obj) => obj is drm_context_t other && Equals(other);
            
            public bool Equals(drm_context_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint (libdrm.drm_context_t from) => from.Value;
            
            public static implicit operator libdrm.drm_context_t (uint from) => new libdrm.drm_context_t(from);
            
            public static bool operator ==(drm_context_t left, drm_context_t right) => left.Equals(right);
            
            public static bool operator !=(drm_context_t left, drm_context_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// DRM_IOCTL_RES_CTX ioctl argument type.
        /// </summary>
        public partial struct drm_ctx_res
        {
            public int count;
            
            public libdrm.drm_ctx* contexts;
        }
        
        /// <summary>
        /// DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
        /// </summary>
        public partial struct drm_draw
        {
            public libdrm.drm_drawable_t handle;
        }
        
        public readonly partial struct drm_drawable_t : IEquatable<libdrm.drm_drawable_t>
        {
            public drm_drawable_t(uint value) => this.Value = value;
            
            public uint Value { get; }
            
            public override bool Equals(object obj) => obj is drm_drawable_t other && Equals(other);
            
            public bool Equals(drm_drawable_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint (libdrm.drm_drawable_t from) => from.Value;
            
            public static implicit operator libdrm.drm_drawable_t (uint from) => new libdrm.drm_drawable_t(from);
            
            public static bool operator ==(drm_drawable_t left, drm_drawable_t right) => left.Equals(right);
            
            public static bool operator !=(drm_drawable_t left, drm_drawable_t right) => !left.Equals(right);
        }
        
        public partial struct drm_update_draw
        {
            public libdrm.drm_drawable_t handle;
            
            public uint type;
            
            public uint num;
            
            public ulong data;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
        /// </summary>
        public partial struct drm_auth
        {
            public libdrm.drm_magic_t magic;
        }
        
        public readonly partial struct drm_magic_t : IEquatable<libdrm.drm_magic_t>
        {
            public drm_magic_t(uint value) => this.Value = value;
            
            public uint Value { get; }
            
            public override bool Equals(object obj) => obj is drm_magic_t other && Equals(other);
            
            public bool Equals(drm_magic_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint (libdrm.drm_magic_t from) => from.Value;
            
            public static implicit operator libdrm.drm_magic_t (uint from) => new libdrm.drm_magic_t(from);
            
            public static bool operator ==(drm_magic_t left, drm_magic_t right) => left.Equals(right);
            
            public static bool operator !=(drm_magic_t left, drm_magic_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// DRM_IOCTL_IRQ_BUSID ioctl argument type.
        /// </summary>
        /// <seealso cref="drmGetInterruptFromBusID()."/>
        public partial struct drm_irq_busid
        {
            /// <summary>
            /// IRQ number
            /// </summary>
            public int irq;
            
            /// <summary>
            /// bus number
            /// </summary>
            public int busnum;
            
            /// <summary>
            /// device number
            /// </summary>
            public int devnum;
            
            /// <summary>
            /// function number
            /// </summary>
            public int funcnum;
        }
        
        public partial struct drm_wait_vblank_request
        {
            public libdrm.drm_vblank_seq_type type;
            
            public uint sequence;
            
            public nuint signal;
        }
        
        public partial struct drm_wait_vblank_reply
        {
            public libdrm.drm_vblank_seq_type type;
            
            public uint sequence;
            
            public nint tval_sec;
            
            public nint tval_usec;
        }
        
        /// <summary>
        /// DRM_IOCTL_WAIT_VBLANK ioctl argument type.
        /// </summary>
        /// <seealso cref="drmWaitVBlank()."/>
        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
        public partial struct drm_wait_vblank
        {
            [FieldOffset(0)]
            public libdrm.drm_wait_vblank_request request;
            
            [FieldOffset(0)]
            public libdrm.drm_wait_vblank_reply reply;
        }
        
        /// <summary>
        /// DRM_IOCTL_MODESET_CTL ioctl argument type
        /// </summary>
        /// <seealso cref="drmModesetCtl()."/>
        public partial struct drm_modeset_ctl
        {
            public uint crtc;
            
            public uint cmd;
        }
        
        /// <summary>
        /// DRM_IOCTL_AGP_ENABLE ioctl argument type.
        /// </summary>
        /// <seealso cref="drmAgpEnable()."/>
        public partial struct drm_agp_mode
        {
            /// <summary>
            /// AGP mode
            /// </summary>
            public nuint mode;
        }
        
        /// <summary>
        /// DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
        /// </summary>
        /// <seealso cref="drmAgpAlloc() and drmAgpFree()."/>
        public partial struct drm_agp_buffer
        {
            /// <summary>
            /// In bytes -- will round to page boundary
            /// </summary>
            public nuint size;
            
            /// <summary>
            /// Used for binding / unbinding
            /// </summary>
            public nuint handle;
            
            /// <summary>
            /// Type of memory to allocate
            /// </summary>
            public nuint type;
            
            /// <summary>
            /// Physical used by i810
            /// </summary>
            public nuint physical;
        }
        
        /// <summary>
        /// DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
        /// </summary>
        /// <seealso cref="drmAgpBind() and drmAgpUnbind()."/>
        public partial struct drm_agp_binding
        {
            /// <summary>
            /// From drm_agp_buffer
            /// </summary>
            public nuint handle;
            
            /// <summary>
            /// In bytes -- will round to page boundary
            /// </summary>
            public nuint offset;
        }
        
        /// <summary>
        /// DRM_IOCTL_AGP_INFO ioctl argument type.
        /// </summary>
        /// <seealso cref="drmAgpVendorId() and drmAgpDeviceId().drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),"/>
        public partial struct drm_agp_info
        {
            public int agp_version_major;
            
            public int agp_version_minor;
            
            public nuint mode;
            
            /// <summary>
            /// physical address
            /// </summary>
            public nuint aperture_base;
            
            /// <summary>
            /// bytes
            /// </summary>
            public nuint aperture_size;
            
            /// <summary>
            /// bytes
            /// </summary>
            public nuint memory_allowed;
            
            public nuint memory_used;
            
            /// <summary>
            /// PCI information
            /// </summary>
            public ushort id_vendor;
            
            public ushort id_device;
        }
        
        /// <summary>
        /// DRM_IOCTL_SG_ALLOC ioctl argument type.
        /// </summary>
        public partial struct drm_scatter_gather
        {
            /// <summary>
            /// In bytes -- will round to page boundary
            /// </summary>
            public nuint size;
            
            /// <summary>
            /// Used for mapping / unmapping
            /// </summary>
            public nuint handle;
        }
        
        /// <summary>
        /// DRM_IOCTL_SET_VERSION ioctl argument type.
        /// </summary>
        public partial struct drm_set_version
        {
            public int drm_di_major;
            
            public int drm_di_minor;
            
            public int drm_dd_major;
            
            public int drm_dd_minor;
        }
        
        /// <summary>
        /// DRM_IOCTL_GEM_CLOSE ioctl argument type
        /// </summary>
        public partial struct drm_gem_close
        {
            /// <summary>
            /// Handle of the object to be closed.
            /// </summary>
            public uint handle;
            
            public uint pad;
        }
        
        /// <summary>
        /// DRM_IOCTL_GEM_FLINK ioctl argument type
        /// </summary>
        public partial struct drm_gem_flink
        {
            /// <summary>
            /// Handle for the object being named
            /// </summary>
            public uint handle;
            
            /// <summary>
            /// Returned global name
            /// </summary>
            public uint name;
        }
        
        /// <summary>
        /// DRM_IOCTL_GEM_OPEN ioctl argument type
        /// </summary>
        public partial struct drm_gem_open
        {
            /// <summary>
            /// Name of object being opened
            /// </summary>
            public uint name;
            
            /// <summary>
            /// Returned handle for the object
            /// </summary>
            public uint handle;
            
            /// <summary>
            /// Returned size of the object
            /// </summary>
            public ulong size;
        }
        
        /// <summary>
        /// DRM_IOCTL_GET_CAP ioctl argument type
        /// </summary>
        public partial struct drm_get_cap
        {
            public ulong capability;
            
            public ulong value;
        }
        
        /// <summary>
        /// DRM_IOCTL_SET_CLIENT_CAP ioctl argument type
        /// </summary>
        public partial struct drm_set_client_cap
        {
            public ulong capability;
            
            public ulong value;
        }
        
        public partial struct drm_prime_handle
        {
            public uint handle;
            
            /// <summary>
            /// Flags.. only applicable for handle-&gt;fd
            /// </summary>
            public uint flags;
            
            /// <summary>
            /// Returned dmabuf file descriptor
            /// </summary>
            public int fd;
        }
        
        public partial struct drm_syncobj_create
        {
            public uint handle;
            
            public uint flags;
        }
        
        public partial struct drm_syncobj_destroy
        {
            public uint handle;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_handle
        {
            public uint handle;
            
            public uint flags;
            
            public int fd;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_transfer
        {
            public uint src_handle;
            
            public uint dst_handle;
            
            public ulong src_point;
            
            public ulong dst_point;
            
            public uint flags;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_wait
        {
            public ulong handles;
            
            /// <summary>
            /// absolute timeout
            /// </summary>
            public long timeout_nsec;
            
            public uint count_handles;
            
            public uint flags;
            
            /// <summary>
            /// only valid when not waiting all
            /// </summary>
            public uint first_signaled;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_timeline_wait
        {
            public ulong handles;
            
            /// <summary>
            /// wait on specific timeline point for every handles
            /// </summary>
            public ulong points;
            
            /// <summary>
            /// absolute timeout
            /// </summary>
            public long timeout_nsec;
            
            public uint count_handles;
            
            public uint flags;
            
            /// <summary>
            /// only valid when not waiting all
            /// </summary>
            public uint first_signaled;
            
            public uint pad;
        }
        
        /// <summary>
        /// struct drm_syncobj_eventfd
        /// @handle : syncobj handle.
        /// @flags : Zero to wait for the point to be signalled, or
        /// &amp;DRM
        /// _SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE to wait for a fence to be
        /// available for the point.
        /// @point : syncobj timeline point (set to zero for binary syncobjs).
        /// @fd : Existing eventfd to sent events to.
        /// </summary>
        /// <remarks>
        /// Register an eventfd to be signalled by a syncobj. The eventfd counter will
        /// be incremented by one.
        /// </remarks>
        /// <par>
        /// @par : Must be zero.
        /// </par>
        public partial struct drm_syncobj_eventfd
        {
            public uint handle;
            
            public uint flags;
            
            public ulong point;
            
            public int fd;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_array
        {
            public ulong handles;
            
            public uint count_handles;
            
            public uint pad;
        }
        
        public partial struct drm_syncobj_timeline_array
        {
            public ulong handles;
            
            public ulong points;
            
            public uint count_handles;
            
            public uint flags;
        }
        
        /// <summary>
        /// Query current scanout sequence number
        /// </summary>
        public partial struct drm_crtc_get_sequence
        {
            /// <summary>
            /// requested crtc_id
            /// </summary>
            public uint crtc_id;
            
            /// <summary>
            /// return: crtc output is active
            /// </summary>
            public uint active;
            
            /// <summary>
            /// return: most recent vblank sequence
            /// </summary>
            public ulong sequence;
            
            /// <summary>
            /// return: most recent time of first pixel out
            /// </summary>
            public long sequence_ns;
        }
        
        public partial struct drm_crtc_queue_sequence
        {
            public uint crtc_id;
            
            public uint flags;
            
            /// <summary>
            /// on input, target sequence. on output, actual sequence
            /// </summary>
            public ulong sequence;
            
            /// <summary>
            /// user data passed to event
            /// </summary>
            public ulong user_data;
        }
        
        /// <summary>
        /// struct drm_event - Header for DRM events
        /// @type : event type.
        /// @length : total number of payload bytes (including header).
        /// </summary>
        /// <remarks>
        /// This struct is a header for events written back to user-space on the DRM FD.
        /// A read on the DRM FD will always only return complete events: e.g. if the
        /// read buffer is 100 bytes large and there are two 64 byte events pending,
        /// only one will be returned.Event types 0 - 0x7fffffff are generic DRM events, 0x80000000 and
        /// up are chipset specific. Generic DRM events include 
        /// &amp;DRM
        /// _EVENT_VBLANK,
        /// &amp;DRM
        /// _EVENT_FLIP_COMPLETE and 
        /// &amp;DRM
        /// _EVENT_CRTC_SEQUENCE.
        /// </remarks>
        public partial struct drm_event
        {
            public uint type;
            
            public uint length;
        }
        
        public partial struct drm_event_vblank
        {
            public libdrm.drm_event @base;
            
            public ulong user_data;
            
            public uint tv_sec;
            
            public uint tv_usec;
            
            public uint sequence;
            
            /// <summary>
            /// 0 on older kernels that do not support this
            /// </summary>
            public uint crtc_id;
        }
        
        /// <summary>
        /// Event delivered at sequence. Time stamp marks when the first pixel
        /// of the refresh cycle leaves the display engine for the display
        /// </summary>
        public partial struct drm_event_crtc_sequence
        {
            public libdrm.drm_event @base;
            
            public ulong user_data;
            
            public long time_ns;
            
            public ulong sequence;
        }
        
        public readonly partial struct drm_handle_t : IEquatable<libdrm.drm_handle_t>
        {
            public drm_handle_t(uint value) => this.Value = value;
            
            public uint Value { get; }
            
            public override bool Equals(object obj) => obj is drm_handle_t other && Equals(other);
            
            public bool Equals(drm_handle_t other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint (libdrm.drm_handle_t from) => from.Value;
            
            public static implicit operator libdrm.drm_handle_t (uint from) => new libdrm.drm_handle_t(from);
            
            public static bool operator ==(drm_handle_t left, drm_handle_t right) => left.Equals(right);
            
            public static bool operator !=(drm_handle_t left, drm_handle_t right) => !left.Equals(right);
        }
    }
}
