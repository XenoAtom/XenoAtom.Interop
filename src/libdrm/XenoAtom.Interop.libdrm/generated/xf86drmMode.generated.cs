//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libdrm
    {
        /// <summary>
        /// Describes the connector status.
        /// </summary>
        /// <remarks>
        /// DRM_MODE_CONNECTED means that the connector has a sink plugged in.
        /// DRM_MODE_DISCONNECTED means the contrary. DRM_MODE_UNKNOWNCONNECTION is used
        /// when it could be either.User-space should first try to enable DRM_MODE_CONNECTED connectors and
        /// ignore other connectors. If there are no DRM_MODE_CONNECTED connectors,
        /// user-space should then try to probe and enable DRM_MODE_UNKNOWNCONNECTION
        /// connectors.
        /// </remarks>
        public enum drmModeConnection : uint
        {
            DRM_MODE_CONNECTED = unchecked((uint)1),
            
            DRM_MODE_DISCONNECTED = unchecked((uint)2),
            
            DRM_MODE_UNKNOWNCONNECTION = unchecked((uint)3),
        }
        
        public const libdrm.drmModeConnection DRM_MODE_CONNECTED = drmModeConnection.DRM_MODE_CONNECTED;
        
        public const libdrm.drmModeConnection DRM_MODE_DISCONNECTED = drmModeConnection.DRM_MODE_DISCONNECTED;
        
        public const libdrm.drmModeConnection DRM_MODE_UNKNOWNCONNECTION = drmModeConnection.DRM_MODE_UNKNOWNCONNECTION;
        
        public enum drmModeSubPixel : uint
        {
            DRM_MODE_SUBPIXEL_UNKNOWN = unchecked((uint)1),
            
            DRM_MODE_SUBPIXEL_HORIZONTAL_RGB = unchecked((uint)2),
            
            DRM_MODE_SUBPIXEL_HORIZONTAL_BGR = unchecked((uint)3),
            
            DRM_MODE_SUBPIXEL_VERTICAL_RGB = unchecked((uint)4),
            
            DRM_MODE_SUBPIXEL_VERTICAL_BGR = unchecked((uint)5),
            
            DRM_MODE_SUBPIXEL_NONE = unchecked((uint)6),
        }
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_UNKNOWN = drmModeSubPixel.DRM_MODE_SUBPIXEL_UNKNOWN;
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_HORIZONTAL_RGB = drmModeSubPixel.DRM_MODE_SUBPIXEL_HORIZONTAL_RGB;
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_HORIZONTAL_BGR = drmModeSubPixel.DRM_MODE_SUBPIXEL_HORIZONTAL_BGR;
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_VERTICAL_RGB = drmModeSubPixel.DRM_MODE_SUBPIXEL_VERTICAL_RGB;
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_VERTICAL_BGR = drmModeSubPixel.DRM_MODE_SUBPIXEL_VERTICAL_BGR;
        
        public const libdrm.drmModeSubPixel DRM_MODE_SUBPIXEL_NONE = drmModeSubPixel.DRM_MODE_SUBPIXEL_NONE;
        
        public partial struct drmModeRes
        {
            public int count_fbs;
            
            public uint* fbs;
            
            public int count_crtcs;
            
            public uint* crtcs;
            
            public int count_connectors;
            
            public uint* connectors;
            
            public int count_encoders;
            
            public uint* encoders;
            
            public uint min_width;
            
            public uint max_width;
            
            public uint min_height;
            
            public uint max_height;
        }
        
        public unsafe partial struct drmModeModeInfo
        {
            public uint clock;
            
            public ushort hdisplay;
            
            public ushort hsync_start;
            
            public ushort hsync_end;
            
            public ushort htotal;
            
            public ushort hskew;
            
            public ushort vdisplay;
            
            public ushort vsync_start;
            
            public ushort vsync_end;
            
            public ushort vtotal;
            
            public ushort vscan;
            
            public uint vrefresh;
            
            public uint flags;
            
            public uint type;
            
            public fixed byte name[32];
        }
        
        public partial struct drmModeFB
        {
            public uint fb_id;
            
            public uint width;
            
            public uint height;
            
            public uint pitch;
            
            public uint bpp;
            
            public uint depth;
            
            /// <summary>
            /// driver specific handle
            /// </summary>
            public uint handle;
        }
        
        public unsafe partial struct drmModeFB2
        {
            public uint fb_id;
            
            public uint width;
            
            public uint height;
            
            /// <summary>
            /// fourcc code from drm_fourcc.h
            /// </summary>
            public uint pixel_format;
            
            /// <summary>
            /// applies to all buffers
            /// </summary>
            public ulong modifier;
            
            public uint flags;
            
            /// <summary>
            /// per-plane GEM handle; may be duplicate entries for multiple planes
            /// </summary>
            public fixed uint handles[4];
            
            /// <summary>
            /// bytes
            /// </summary>
            public fixed uint pitches[4];
            
            /// <summary>
            /// bytes
            /// </summary>
            public fixed uint offsets[4];
        }
        
        public partial struct drmModePropertyBlobRes
        {
            public uint id;
            
            public uint length;
            
            public void* data;
        }
        
        public unsafe partial struct drmModePropertyRes
        {
            public uint prop_id;
            
            public uint flags;
            
            public fixed byte name[32];
            
            public int count_values;
            
            /// <summary>
            /// store the blob lengths
            /// </summary>
            public ulong* values;
            
            public int count_enums;
            
            public libdrm.drm_mode_property_enum* enums;
            
            public int count_blobs;
            
            /// <summary>
            /// store the blob IDs
            /// </summary>
            public uint* blob_ids;
        }
        
        public partial struct drmModeCrtc
        {
            public uint crtc_id;
            
            /// <summary>
            /// FB id to connect to 0 = disconnect
            /// </summary>
            public uint buffer_id;
            
            /// <summary>
            /// Position on the framebuffer
            /// </summary>
            public uint x;
            
            /// <summary>
            /// Position on the framebuffer
            /// </summary>
            public uint y;
            
            public uint width;
            
            public uint height;
            
            public int mode_valid;
            
            public libdrm.drmModeModeInfo mode;
            
            /// <summary>
            /// Number of gamma stops
            /// </summary>
            public int gamma_size;
        }
        
        public partial struct drmModeEncoder
        {
            public uint encoder_id;
            
            public uint encoder_type;
            
            public uint crtc_id;
            
            public uint possible_crtcs;
            
            public uint possible_clones;
        }
        
        public partial struct drmModeConnector
        {
            public uint connector_id;
            
            /// <summary>
            /// Encoder currently connected to
            /// </summary>
            public uint encoder_id;
            
            public uint connector_type;
            
            public uint connector_type_id;
            
            public libdrm.drmModeConnection connection;
            
            /// <summary>
            /// HxW in millimeters
            /// </summary>
            public uint mmWidth;
            
            /// <summary>
            /// HxW in millimeters
            /// </summary>
            public uint mmHeight;
            
            public libdrm.drmModeSubPixel subpixel;
            
            public int count_modes;
            
            public libdrm.drmModeModeInfo* modes;
            
            public int count_props;
            
            /// <summary>
            /// List of property ids
            /// </summary>
            public uint* props;
            
            /// <summary>
            /// List of property values
            /// </summary>
            public ulong* prop_values;
            
            public int count_encoders;
            
            /// <summary>
            /// List of encoder ids
            /// </summary>
            public uint* encoders;
        }
        
        public partial struct drmModeObjectProperties
        {
            public uint count_props;
            
            public uint* props;
            
            public ulong* prop_values;
        }
        
        public partial struct drmModeFormatModifierIterator
        {
            public uint fmt_idx;
            
            public uint mod_idx;
            
            public uint fmt;
            
            public ulong mod;
        }
        
        public partial struct drmModePlane
        {
            public uint count_formats;
            
            public uint* formats;
            
            public uint plane_id;
            
            public uint crtc_id;
            
            public uint fb_id;
            
            public uint crtc_x;
            
            public uint crtc_y;
            
            public uint x;
            
            public uint y;
            
            public uint possible_crtcs;
            
            public uint gamma_size;
        }
        
        public partial struct drmModePlaneRes
        {
            public uint count_planes;
            
            public uint* planes;
        }
        
        public unsafe partial struct drmModeLesseeList
        {
            public uint count;
            
            public fixed uint lessees[1];
        }
        
        public unsafe partial struct drmModeObjectList
        {
            public uint count;
            
            public fixed uint objects[1];
        }
        
        /// <summary>
        /// Cliprect.
        /// </summary>
        /// <note>
        /// @note KW: Actually it's illegal to change either for
        /// backwards-compatibility reasons.
        /// </note>
        /// <warning>
        /// @warning : If you change this structure, make sure you change
        /// XF86DRIClipRectRec in the server as well
        /// </warning>
        public readonly partial struct drmModeClip : IEquatable<libdrm.drmModeClip>
        {
            public drmModeClip(libdrm.drm_clip_rect value) => this.Value = value;
            
            public libdrm.drm_clip_rect Value { get; }
            
            public override bool Equals(object obj) => obj is drmModeClip other && Equals(other);
            
            public bool Equals(drmModeClip other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libdrm.drm_clip_rect (libdrm.drmModeClip from) => from.Value;
            
            public static implicit operator libdrm.drmModeClip (libdrm.drm_clip_rect from) => new libdrm.drmModeClip(from);
            
            public static bool operator ==(drmModeClip left, drmModeClip right) => left.Equals(right);
            
            public static bool operator !=(drmModeClip left, drmModeClip right) => !left.Equals(right);
        }
        
        public readonly partial struct drmModeAtomicReqPtr : IEquatable<libdrm.drmModeAtomicReqPtr>
        {
            public drmModeAtomicReqPtr(libdrm.drmModeAtomicReq value) => this.Value = value;
            
            public libdrm.drmModeAtomicReq Value { get; }
            
            public override bool Equals(object obj) => obj is drmModeAtomicReqPtr other && Equals(other);
            
            public bool Equals(drmModeAtomicReqPtr other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libdrm.drmModeAtomicReq (libdrm.drmModeAtomicReqPtr from) => from.Value;
            
            public static implicit operator libdrm.drmModeAtomicReqPtr (libdrm.drmModeAtomicReq from) => new libdrm.drmModeAtomicReqPtr(from);
            
            public static bool operator ==(drmModeAtomicReqPtr left, drmModeAtomicReqPtr right) => left.Equals(right);
            
            public static bool operator !=(drmModeAtomicReqPtr left, drmModeAtomicReqPtr right) => !left.Equals(right);
        }
        
        public readonly partial struct drmModeLesseeListRes : IEquatable<libdrm.drmModeLesseeListRes>
        {
            public drmModeLesseeListRes(libdrm.drmModeLesseeList value) => this.Value = value;
            
            public libdrm.drmModeLesseeList Value { get; }
            
            public override bool Equals(object obj) => obj is drmModeLesseeListRes other && Equals(other);
            
            public bool Equals(drmModeLesseeListRes other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libdrm.drmModeLesseeList (libdrm.drmModeLesseeListRes from) => from.Value;
            
            public static implicit operator libdrm.drmModeLesseeListRes (libdrm.drmModeLesseeList from) => new libdrm.drmModeLesseeListRes(from);
            
            public static bool operator ==(drmModeLesseeListRes left, drmModeLesseeListRes right) => left.Equals(right);
            
            public static bool operator !=(drmModeLesseeListRes left, drmModeLesseeListRes right) => !left.Equals(right);
        }
        
        public readonly partial struct drmModeObjectListRes : IEquatable<libdrm.drmModeObjectListRes>
        {
            public drmModeObjectListRes(libdrm.drmModeObjectList value) => this.Value = value;
            
            public libdrm.drmModeObjectList Value { get; }
            
            public override bool Equals(object obj) => obj is drmModeObjectListRes other && Equals(other);
            
            public bool Equals(drmModeObjectListRes other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator libdrm.drmModeObjectList (libdrm.drmModeObjectListRes from) => from.Value;
            
            public static implicit operator libdrm.drmModeObjectListRes (libdrm.drmModeObjectList from) => new libdrm.drmModeObjectListRes(from);
            
            public static bool operator ==(drmModeObjectListRes left, drmModeObjectListRes right) => left.Equals(right);
            
            public static bool operator !=(drmModeObjectListRes left, drmModeObjectListRes right) => !left.Equals(right);
        }
        
        public const int DRM_MODE_FEATURE_KMS = 1;
        
        public const int DRM_MODE_FEATURE_DIRTYFB = 1;
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeModeInfo")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeModeInfo(libdrm.drmModeModeInfo* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeResources")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeResources(libdrm.drmModeRes* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeFB(libdrm.drmModeFB* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeFB2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeFB2(libdrm.drmModeFB2* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeCrtc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeCrtc(libdrm.drmModeCrtc* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeConnector")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeConnector(libdrm.drmModeConnector* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeEncoder")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeEncoder(libdrm.drmModeEncoder* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreePlane")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreePlane(libdrm.drmModePlane* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreePlaneResources")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreePlaneResources(libdrm.drmModePlaneRes* ptr);
        
        /// <summary>
        /// Check whether the DRM node supports Kernel Mode-Setting.
        /// </summary>
        /// <remarks>
        /// Returns 1 if suitable for KMS, 0 otherwise.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmIsKMS")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmIsKMS(int fd);
        
        /// <summary>
        /// Retrieves all of the resources associated with a card.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetResources")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeRes* drmModeGetResources(int fd);
        
        /// <summary>
        /// Retrieve information about framebuffer bufferId
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeFB* drmModeGetFB(int fd, uint bufferId);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetFB2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeFB2* drmModeGetFB2(int fd, uint bufferId);
        
        /// <summary>
        /// Creates a new framebuffer with an buffer object as its scanout buffer.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAddFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAddFB(int fd, uint width, uint height, byte depth, byte bpp, uint pitch, uint bo_handle, uint* buf_id);
        
        /// <summary>
        /// ...with a specific pixel format
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAddFB2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAddFB2(int fd, uint width, uint height, uint pixel_format, FixedArray4<uint> bo_handles, FixedArray4<uint> pitches, FixedArray4<uint> offsets, uint* buf_id, uint flags);
        
        /// <summary>
        /// ...with format modifiers
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAddFB2WithModifiers")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAddFB2WithModifiers(int fd, uint width, uint height, uint pixel_format, FixedArray4<uint> bo_handles, FixedArray4<uint> pitches, FixedArray4<uint> offsets, FixedArray4<ulong> modifier, uint* buf_id, uint flags);
        
        /// <summary>
        /// Destroies the given framebuffer.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeRmFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeRmFB(int fd, uint bufferId);
        
        /// <summary>
        /// Close a framebuffer.
        /// </summary>
        /// <remarks>
        /// Same as drmModeRmFB(), except it doesn't implicitly disable planes and CRTCs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCloseFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCloseFB(int fd, uint buffer_id);
        
        /// <summary>
        /// Mark a region of a framebuffer as dirty.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeDirtyFB")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeDirtyFB(int fd, uint bufferId, libdrm.drm_clip_rect* clips, uint num_clips);
        
        /// <summary>
        /// Retrieve information about the ctrt crtcId
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetCrtc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeCrtc* drmModeGetCrtc(int fd, uint crtcId);
        
        /// <summary>
        /// Set the mode on a crtc crtcId with the given mode modeId.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeSetCrtc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeSetCrtc(int fd, uint crtcId, uint bufferId, uint x, uint y, uint* connectors, int count, libdrm.drmModeModeInfo* mode);
        
        /// <summary>
        /// Set the cursor on crtc
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeSetCursor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeSetCursor(int fd, uint crtcId, uint bo_handle, uint width, uint height);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeSetCursor2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeSetCursor2(int fd, uint crtcId, uint bo_handle, uint width, uint height, int hot_x, int hot_y);
        
        /// <summary>
        /// Move the cursor on crtc
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeMoveCursor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeMoveCursor(int fd, uint crtcId, int x, int y);
        
        /// <summary>
        /// Encoder functions
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetEncoder")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeEncoder* drmModeGetEncoder(int fd, uint encoder_id);
        
        /// <summary>
        /// Retrieve all information about the connector connectorId. This will do a
        /// forced probe on the connector to retrieve remote information such as EDIDs
        /// from the display device.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetConnector")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeConnector* drmModeGetConnector(int fd, uint connectorId);
        
        /// <summary>
        /// Retrieve current information, i.e the currently active mode and encoder,
        /// about the connector connectorId. This will not do any probing on the
        /// connector or remote device, and only reports what is currently known.
        /// For the complete set of modes and encoders associated with the connector
        /// use drmModeGetConnector() which will do a probe to determine any display
        /// link changes first.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetConnectorCurrent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeConnector* drmModeGetConnectorCurrent(int fd, uint connector_id);
        
        /// <summary>
        /// Get a bitmask of CRTCs a connector is compatible with.
        /// </summary>
        /// <remarks>
        /// The bits reference CRTC indices. If the n-th CRTC is compatible with the
        /// connector, the n-th bit will be set. The indices are taken from the array
        /// returned by drmModeGetResources(). The indices are different from the object
        /// IDs.Zero is returned on error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeConnectorGetPossibleCrtcs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint drmModeConnectorGetPossibleCrtcs(int fd, libdrm.drmModeConnector* connector);
        
        /// <summary>
        /// Attaches the given mode to an connector.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAttachMode")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAttachMode(int fd, uint connectorId, libdrm.drmModeModeInfo* mode_info);
        
        /// <summary>
        /// Detaches a mode from the connector
        /// must be unused, by the given mode.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeDetachMode")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeDetachMode(int fd, uint connectorId, libdrm.drmModeModeInfo* mode_info);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetProperty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModePropertyRes* drmModeGetProperty(int fd, uint propertyId);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeProperty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeProperty(libdrm.drmModePropertyRes* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetPropertyBlob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModePropertyBlobRes* drmModeGetPropertyBlob(int fd, uint blob_id);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFormatModifierBlobIterNext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte drmModeFormatModifierBlobIterNext(libdrm.drmModePropertyBlobRes* blob, libdrm.drmModeFormatModifierIterator* iter);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreePropertyBlob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreePropertyBlob(libdrm.drmModePropertyBlobRes* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeConnectorSetProperty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeConnectorSetProperty(int fd, uint connector_id, uint property_id, ulong value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCheckModesettingSupported")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCheckModesettingSupported(byte* busid);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCrtcSetGamma")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCrtcSetGamma(int fd, uint crtc_id, uint size, ushort* red, ushort* green, ushort* blue);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCrtcGetGamma")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCrtcGetGamma(int fd, uint crtc_id, uint size, ushort* red, ushort* green, ushort* blue);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModePageFlip")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModePageFlip(int fd, uint crtc_id, uint fb_id, uint flags, void* user_data);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModePageFlipTarget")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModePageFlipTarget(int fd, uint crtc_id, uint fb_id, uint flags, void* user_data, uint target_vblank);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetPlaneResources")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModePlaneRes* drmModeGetPlaneResources(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetPlane")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModePlane* drmModeGetPlane(int fd, uint plane_id);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeSetPlane")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeSetPlane(int fd, uint plane_id, uint crtc_id, uint fb_id, uint flags, int crtc_x, int crtc_y, uint crtc_w, uint crtc_h, uint src_x, uint src_y, uint src_w, uint src_h);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeObjectGetProperties")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeObjectProperties* drmModeObjectGetProperties(int fd, uint object_id, uint object_type);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeFreeObjectProperties")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeFreeObjectProperties(libdrm.drmModeObjectProperties* ptr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeObjectSetProperty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeObjectSetProperty(int fd, uint object_id, uint object_type, uint property_id, ulong value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicAlloc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeAtomicReqPtr drmModeAtomicAlloc();
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicDuplicate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeAtomicReqPtr drmModeAtomicDuplicate(libdrm.drmModeAtomicReqPtr req);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicMerge")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAtomicMerge(libdrm.drmModeAtomicReqPtr @base, libdrm.drmModeAtomicReqPtr augment);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicFree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeAtomicFree(libdrm.drmModeAtomicReqPtr req);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicGetCursor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAtomicGetCursor(libdrm.drmModeAtomicReqPtr req);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicSetCursor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmModeAtomicSetCursor(libdrm.drmModeAtomicReqPtr req, int cursor);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicAddProperty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAtomicAddProperty(libdrm.drmModeAtomicReqPtr req, uint object_id, uint property_id, ulong value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeAtomicCommit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeAtomicCommit(int fd, libdrm.drmModeAtomicReqPtr req, uint flags, void* user_data);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCreatePropertyBlob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCreatePropertyBlob(int fd, void* data, nuint size, uint* id);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeDestroyPropertyBlob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeDestroyPropertyBlob(int fd, uint id);
        
        /// <summary>
        /// DRM mode lease APIs. These create and manage new drm_masters with
        /// access to a subset of the available DRM resources
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCreateLease")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCreateLease(int fd, uint* objects, int num_objects, int flags, uint* lessee_id);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeListLessees")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeLesseeList* drmModeListLessees(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetLease")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmModeObjectList* drmModeGetLease(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeRevokeLease")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeRevokeLease(int fd, uint lessee_id);
        
        /// <summary>
        /// Get a string describing a connector type.
        /// </summary>
        /// <remarks>
        /// NULL is returned if the connector type is unsupported. Callers should handle
        /// this gracefully, e.g. by falling back to "Unknown" or printing the raw value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeGetConnectorTypeName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmModeGetConnectorTypeName(uint connector_type);
        
        /// <summary>
        /// Create a dumb buffer.
        /// </summary>
        /// <remarks>
        /// Given a width, height and bits-per-pixel, the kernel will return a buffer
        /// handle, pitch and size. The flags must be zero.Returns 0 on success, negative errno on error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeCreateDumbBuffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeCreateDumbBuffer(int fd, uint width, uint height, uint bpp, uint flags, uint* handle, uint* pitch, ulong* size);
        
        /// <summary>
        /// Destroy a dumb buffer.
        /// </summary>
        /// <remarks>
        /// Returns 0 on success, negative errno on error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeDestroyDumbBuffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeDestroyDumbBuffer(int fd, uint handle);
        
        /// <summary>
        /// Prepare a dumb buffer for mapping.
        /// </summary>
        /// <remarks>
        /// The kernel returns an offset which can be used as an argument to mmap(2) on
        /// the DRM FD.Returns 0 on success, negative errno on error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmModeMapDumbBuffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmModeMapDumbBuffer(int fd, uint handle, ulong* offset);
    }
}
