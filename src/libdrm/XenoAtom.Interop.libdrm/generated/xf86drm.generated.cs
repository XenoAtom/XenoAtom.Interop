//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libdrm
    {
        /// <summary>
        /// All of these enums *MUST* match with the
        /// kernel implementation -- so do *NOT*
        /// change them!  (The drmlib implementation
        /// will just copy the flags instead of
        /// translating them.)
        /// </summary>
        public enum drmMapType : uint
        {
            /// <summary>
            /// WC, no caching, no core dump
            /// </summary>
            DRM_FRAME_BUFFER = unchecked((uint)0),
            
            /// <summary>
            /// no caching, no core dump
            /// </summary>
            DRM_REGISTERS = unchecked((uint)1),
            
            /// <summary>
            /// shared, cached
            /// </summary>
            DRM_SHM = unchecked((uint)2),
            
            /// <summary>
            /// AGP/GART
            /// </summary>
            DRM_AGP = unchecked((uint)3),
            
            /// <summary>
            /// PCI scatter/gather
            /// </summary>
            DRM_SCATTER_GATHER = unchecked((uint)4),
            
            /// <summary>
            /// PCI consistent
            /// </summary>
            DRM_CONSISTENT = unchecked((uint)5),
        }
        
        /// <summary>
        /// WC, no caching, no core dump
        /// </summary>
        public const libdrm.drmMapType DRM_FRAME_BUFFER = drmMapType.DRM_FRAME_BUFFER;
        
        /// <summary>
        /// no caching, no core dump
        /// </summary>
        public const libdrm.drmMapType DRM_REGISTERS = drmMapType.DRM_REGISTERS;
        
        /// <summary>
        /// shared, cached
        /// </summary>
        public const libdrm.drmMapType DRM_SHM = drmMapType.DRM_SHM;
        
        /// <summary>
        /// AGP/GART
        /// </summary>
        public const libdrm.drmMapType DRM_AGP = drmMapType.DRM_AGP;
        
        /// <summary>
        /// PCI scatter/gather
        /// </summary>
        public const libdrm.drmMapType DRM_SCATTER_GATHER = drmMapType.DRM_SCATTER_GATHER;
        
        /// <summary>
        /// PCI consistent
        /// </summary>
        public const libdrm.drmMapType DRM_CONSISTENT = drmMapType.DRM_CONSISTENT;
        
        public enum drmMapFlags : uint
        {
            /// <summary>
            /// Cannot be mapped to client-virtual
            /// </summary>
            DRM_RESTRICTED = unchecked((uint)1),
            
            /// <summary>
            /// Read-only in client-virtual
            /// </summary>
            DRM_READ_ONLY = unchecked((uint)2),
            
            /// <summary>
            /// Physical pages locked
            /// </summary>
            DRM_LOCKED = unchecked((uint)4),
            
            /// <summary>
            /// Kernel requires access
            /// </summary>
            DRM_KERNEL = unchecked((uint)8),
            
            /// <summary>
            /// Use write-combining, if available
            /// </summary>
            DRM_WRITE_COMBINING = unchecked((uint)16),
            
            /// <summary>
            /// SHM page that contains lock
            /// </summary>
            DRM_CONTAINS_LOCK = unchecked((uint)32),
            
            /// <summary>
            /// Removable mapping
            /// </summary>
            DRM_REMOVABLE = unchecked((uint)64),
        }
        
        /// <summary>
        /// Cannot be mapped to client-virtual
        /// </summary>
        public const libdrm.drmMapFlags DRM_RESTRICTED = drmMapFlags.DRM_RESTRICTED;
        
        /// <summary>
        /// Read-only in client-virtual
        /// </summary>
        public const libdrm.drmMapFlags DRM_READ_ONLY = drmMapFlags.DRM_READ_ONLY;
        
        /// <summary>
        /// Physical pages locked
        /// </summary>
        public const libdrm.drmMapFlags DRM_LOCKED = drmMapFlags.DRM_LOCKED;
        
        /// <summary>
        /// Kernel requires access
        /// </summary>
        public const libdrm.drmMapFlags DRM_KERNEL = drmMapFlags.DRM_KERNEL;
        
        /// <summary>
        /// Use write-combining, if available
        /// </summary>
        public const libdrm.drmMapFlags DRM_WRITE_COMBINING = drmMapFlags.DRM_WRITE_COMBINING;
        
        /// <summary>
        /// SHM page that contains lock
        /// </summary>
        public const libdrm.drmMapFlags DRM_CONTAINS_LOCK = drmMapFlags.DRM_CONTAINS_LOCK;
        
        /// <summary>
        /// Removable mapping
        /// </summary>
        public const libdrm.drmMapFlags DRM_REMOVABLE = drmMapFlags.DRM_REMOVABLE;
        
        /// <warning>
        /// @warning These values *MUST* match drm.h
        /// </warning>
        public enum drmDMAFlags : uint
        {
            /// <summary>
            /// Block until buffer dispatched.
            /// </summary>
            /// <note>
            /// @note the buffer may not yet have been
            /// processed by the hardware -- getting a
            /// hardware lock with the hardware quiescent
            /// will ensure that the buffer has been
            /// processed.
            /// </note>
            DRM_DMA_BLOCK = unchecked((uint)1),
            
            /// <summary>
            /// Dispatch while lock held
            /// </summary>
            DRM_DMA_WHILE_LOCKED = unchecked((uint)2),
            
            /// <summary>
            /// High priority dispatch
            /// </summary>
            DRM_DMA_PRIORITY = unchecked((uint)4),
            
            /// <summary>
            /// Wait for free buffers
            /// </summary>
            DRM_DMA_WAIT = unchecked((uint)16),
            
            /// <summary>
            /// Smaller-than-requested buffers OK
            /// </summary>
            DRM_DMA_SMALLER_OK = unchecked((uint)32),
            
            /// <summary>
            /// Larger-than-requested buffers OK
            /// </summary>
            DRM_DMA_LARGER_OK = unchecked((uint)64),
        }
        
        /// <summary>
        /// Block until buffer dispatched.
        /// </summary>
        /// <note>
        /// @note the buffer may not yet have been
        /// processed by the hardware -- getting a
        /// hardware lock with the hardware quiescent
        /// will ensure that the buffer has been
        /// processed.
        /// </note>
        public const libdrm.drmDMAFlags DRM_DMA_BLOCK = drmDMAFlags.DRM_DMA_BLOCK;
        
        /// <summary>
        /// Dispatch while lock held
        /// </summary>
        public const libdrm.drmDMAFlags DRM_DMA_WHILE_LOCKED = drmDMAFlags.DRM_DMA_WHILE_LOCKED;
        
        /// <summary>
        /// High priority dispatch
        /// </summary>
        public const libdrm.drmDMAFlags DRM_DMA_PRIORITY = drmDMAFlags.DRM_DMA_PRIORITY;
        
        /// <summary>
        /// Wait for free buffers
        /// </summary>
        public const libdrm.drmDMAFlags DRM_DMA_WAIT = drmDMAFlags.DRM_DMA_WAIT;
        
        /// <summary>
        /// Smaller-than-requested buffers OK
        /// </summary>
        public const libdrm.drmDMAFlags DRM_DMA_SMALLER_OK = drmDMAFlags.DRM_DMA_SMALLER_OK;
        
        /// <summary>
        /// Larger-than-requested buffers OK
        /// </summary>
        public const libdrm.drmDMAFlags DRM_DMA_LARGER_OK = drmDMAFlags.DRM_DMA_LARGER_OK;
        
        public enum drmBufDescFlags : uint
        {
            DRM_PAGE_ALIGN = unchecked((uint)1),
            
            DRM_AGP_BUFFER = unchecked((uint)2),
            
            DRM_SG_BUFFER = unchecked((uint)4),
            
            DRM_FB_BUFFER = unchecked((uint)8),
            
            DRM_PCI_BUFFER_RO = unchecked((uint)16),
        }
        
        public const libdrm.drmBufDescFlags DRM_PAGE_ALIGN = drmBufDescFlags.DRM_PAGE_ALIGN;
        
        public const libdrm.drmBufDescFlags DRM_AGP_BUFFER = drmBufDescFlags.DRM_AGP_BUFFER;
        
        public const libdrm.drmBufDescFlags DRM_SG_BUFFER = drmBufDescFlags.DRM_SG_BUFFER;
        
        public const libdrm.drmBufDescFlags DRM_FB_BUFFER = drmBufDescFlags.DRM_FB_BUFFER;
        
        public const libdrm.drmBufDescFlags DRM_PCI_BUFFER_RO = drmBufDescFlags.DRM_PCI_BUFFER_RO;
        
        public enum drmLockFlags : uint
        {
            /// <summary>
            /// Wait until hardware is ready for DMA
            /// </summary>
            DRM_LOCK_READY = unchecked((uint)1),
            
            /// <summary>
            /// Wait until hardware quiescent
            /// </summary>
            DRM_LOCK_QUIESCENT = unchecked((uint)2),
            
            /// <summary>
            /// Flush this context's DMA queue first
            /// </summary>
            DRM_LOCK_FLUSH = unchecked((uint)4),
            
            /// <summary>
            /// Flush all DMA queues first
            /// </summary>
            DRM_LOCK_FLUSH_ALL = unchecked((uint)8),
            
            /// <summary>
            /// Halt all current and future queues
            /// </summary>
            DRM_HALT_ALL_QUEUES = unchecked((uint)16),
            
            /// <summary>
            /// Halt all current queues
            /// </summary>
            DRM_HALT_CUR_QUEUES = unchecked((uint)32),
        }
        
        /// <summary>
        /// Wait until hardware is ready for DMA
        /// </summary>
        public const libdrm.drmLockFlags DRM_LOCK_READY = drmLockFlags.DRM_LOCK_READY;
        
        /// <summary>
        /// Wait until hardware quiescent
        /// </summary>
        public const libdrm.drmLockFlags DRM_LOCK_QUIESCENT = drmLockFlags.DRM_LOCK_QUIESCENT;
        
        /// <summary>
        /// Flush this context's DMA queue first
        /// </summary>
        public const libdrm.drmLockFlags DRM_LOCK_FLUSH = drmLockFlags.DRM_LOCK_FLUSH;
        
        /// <summary>
        /// Flush all DMA queues first
        /// </summary>
        public const libdrm.drmLockFlags DRM_LOCK_FLUSH_ALL = drmLockFlags.DRM_LOCK_FLUSH_ALL;
        
        /// <summary>
        /// Halt all current and future queues
        /// </summary>
        public const libdrm.drmLockFlags DRM_HALT_ALL_QUEUES = drmLockFlags.DRM_HALT_ALL_QUEUES;
        
        /// <summary>
        /// Halt all current queues
        /// </summary>
        public const libdrm.drmLockFlags DRM_HALT_CUR_QUEUES = drmLockFlags.DRM_HALT_CUR_QUEUES;
        
        public enum drm_context_tFlags : uint
        {
            /// <summary>
            /// This context is preserved and
            /// never swapped.
            /// </summary>
            DRM_CONTEXT_PRESERVED = unchecked((uint)1),
            
            /// <summary>
            /// This context is for 2D rendering only.
            /// </summary>
            DRM_CONTEXT_2DONLY = unchecked((uint)2),
        }
        
        /// <summary>
        /// This context is preserved and
        /// never swapped.
        /// </summary>
        public const libdrm.drm_context_tFlags DRM_CONTEXT_PRESERVED = drm_context_tFlags.DRM_CONTEXT_PRESERVED;
        
        /// <summary>
        /// This context is for 2D rendering only.
        /// </summary>
        public const libdrm.drm_context_tFlags DRM_CONTEXT_2DONLY = drm_context_tFlags.DRM_CONTEXT_2DONLY;
        
        public enum drmVBlankSeqType : uint
        {
            /// <summary>
            /// Wait for specific vblank sequence number
            /// </summary>
            DRM_VBLANK_ABSOLUTE = unchecked((uint)0),
            
            /// <summary>
            /// Wait for given number of vblanks
            /// </summary>
            DRM_VBLANK_RELATIVE = unchecked((uint)1),
            
            /// <summary>
            /// bits 1-6 are reserved for high crtcs
            /// </summary>
            DRM_VBLANK_HIGH_CRTC_MASK = unchecked((uint)62),
            
            /// <summary>
            /// Send event instead of blocking
            /// </summary>
            DRM_VBLANK_EVENT = unchecked((uint)67108864),
            
            /// <summary>
            /// Scheduled buffer swap should flip
            /// </summary>
            DRM_VBLANK_FLIP = unchecked((uint)134217728),
            
            /// <summary>
            /// If missed, wait for next vblank
            /// </summary>
            DRM_VBLANK_NEXTONMISS = unchecked((uint)268435456),
            
            /// <summary>
            /// Secondary display controller
            /// </summary>
            DRM_VBLANK_SECONDARY = unchecked((uint)536870912),
            
            /// <summary>
            /// Send signal instead of blocking
            /// </summary>
            DRM_VBLANK_SIGNAL = unchecked((uint)1073741824),
        }
        
        /// <summary>
        /// Wait for specific vblank sequence number
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_ABSOLUTE = drmVBlankSeqType.DRM_VBLANK_ABSOLUTE;
        
        /// <summary>
        /// Wait for given number of vblanks
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_RELATIVE = drmVBlankSeqType.DRM_VBLANK_RELATIVE;
        
        /// <summary>
        /// bits 1-6 are reserved for high crtcs
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_HIGH_CRTC_MASK = drmVBlankSeqType.DRM_VBLANK_HIGH_CRTC_MASK;
        
        /// <summary>
        /// Send event instead of blocking
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_EVENT = drmVBlankSeqType.DRM_VBLANK_EVENT;
        
        /// <summary>
        /// Scheduled buffer swap should flip
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_FLIP = drmVBlankSeqType.DRM_VBLANK_FLIP;
        
        /// <summary>
        /// If missed, wait for next vblank
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_NEXTONMISS = drmVBlankSeqType.DRM_VBLANK_NEXTONMISS;
        
        /// <summary>
        /// Secondary display controller
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_SECONDARY = drmVBlankSeqType.DRM_VBLANK_SECONDARY;
        
        /// <summary>
        /// Send signal instead of blocking
        /// </summary>
        public const libdrm.drmVBlankSeqType DRM_VBLANK_SIGNAL = drmVBlankSeqType.DRM_VBLANK_SIGNAL;
        
        public partial struct drmHashEntry
        {
            public int fd;
            
            public delegate*unmanaged[Cdecl]<int, void*, void*, void> f;
            
            public void* tagTable;
        }
        
        /// <summary>
        /// Driver version information.
        /// </summary>
        /// <seealso cref="drmGetVersion() and drmSetVersion()."/>
        public partial struct drmVersion
        {
            /// <summary>
            /// Major version
            /// </summary>
            public int version_major;
            
            /// <summary>
            /// Minor version
            /// </summary>
            public int version_minor;
            
            /// <summary>
            /// Patch level
            /// </summary>
            public int version_patchlevel;
            
            /// <summary>
            /// Length of name buffer
            /// </summary>
            public int name_len;
            
            /// <summary>
            /// Name of driver
            /// </summary>
            public byte* name;
            
            /// <summary>
            /// Length of date buffer
            /// </summary>
            public int date_len;
            
            /// <summary>
            /// User-space buffer to hold date
            /// </summary>
            public byte* date;
            
            /// <summary>
            /// Length of desc buffer
            /// </summary>
            public int desc_len;
            
            /// <summary>
            /// User-space buffer to hold desc
            /// </summary>
            public byte* desc;
        }
        
        public partial struct drmStatsT
        {
            public partial struct _drmStats__struct_0
            {
                /// <summary>
                /// Value from kernel
                /// </summary>
                public nuint value;
                
                /// <summary>
                /// Suggested format for long_name
                /// </summary>
                public byte* long_format;
                
                /// <summary>
                /// Long name for value
                /// </summary>
                public byte* long_name;
                
                /// <summary>
                /// Suggested format for rate_name
                /// </summary>
                public byte* rate_format;
                
                /// <summary>
                /// Short name for value per second
                /// </summary>
                public byte* rate_name;
                
                /// <summary>
                /// True if value (vs. counter)
                /// </summary>
                public int isvalue;
                
                /// <summary>
                /// Multiplier names (e.g., "KGM")
                /// </summary>
                public byte* mult_names;
                
                /// <summary>
                /// Multiplier value (e.g., 1024)
                /// </summary>
                public int mult;
                
                /// <summary>
                /// Suggest only in verbose output
                /// </summary>
                public int verbose;
            }
            
            /// <summary>
            /// Number of data
            /// </summary>
            public nuint count;
            
            public FixedArray15<libdrm.drmStatsT._drmStats__struct_0> data;
        }
        
        public partial struct drmBufDesc
        {
            /// <summary>
            /// Number of buffers of this size
            /// </summary>
            public int count;
            
            /// <summary>
            /// Size in bytes
            /// </summary>
            public int size;
            
            /// <summary>
            /// Low water mark
            /// </summary>
            public int low_mark;
            
            /// <summary>
            /// High water mark
            /// </summary>
            public int high_mark;
        }
        
        public partial struct drmBufInfo
        {
            /// <summary>
            /// Number of buffers described in list
            /// </summary>
            public int count;
            
            /// <summary>
            /// List of buffer descriptions
            /// </summary>
            public libdrm.drmBufDesc* list;
        }
        
        public partial struct drmBuf
        {
            /// <summary>
            /// Index into the master buffer list
            /// </summary>
            public int idx;
            
            /// <summary>
            /// Buffer size
            /// </summary>
            public int total;
            
            /// <summary>
            /// Amount of buffer in use (for DMA)
            /// </summary>
            public int used;
            
            /// <summary>
            /// Address
            /// </summary>
            public libdrm.drmAddress address;
        }
        
        public readonly partial struct drmAddress : IEquatable<libdrm.drmAddress>
        {
            public drmAddress(void* value) => this.Value = value;
            
            public void* Value { get; }
            
            public override bool Equals(object obj) => obj is drmAddress other && Equals(other);
            
            public bool Equals(drmAddress other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator void* (libdrm.drmAddress from) => from.Value;
            
            public static implicit operator libdrm.drmAddress (void* from) => new libdrm.drmAddress(from);
            
            public static bool operator ==(drmAddress left, drmAddress right) => left.Equals(right);
            
            public static bool operator !=(drmAddress left, drmAddress right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Buffer mapping information.
        /// </summary>
        /// <remarks>
        /// Used by drmMapBufs() and drmUnmapBufs() to store information about the
        /// mapped buffers.
        /// </remarks>
        public partial struct drmBufMap
        {
            /// <summary>
            /// Number of buffers mapped
            /// </summary>
            public int count;
            
            /// <summary>
            /// Buffers
            /// </summary>
            public libdrm.drmBuf* list;
        }
        
        public unsafe partial struct drmLock
        {
            public uint @lock;
            
            public fixed byte padding[60];
        }
        
        /// <summary>
        /// Indices here refer to the offset into
        /// list in drmBufInfo
        /// </summary>
        public partial struct drmDMAReq
        {
            /// <summary>
            /// Context handle
            /// </summary>
            public libdrm.drm_context_t context;
            
            /// <summary>
            /// Number of buffers to send
            /// </summary>
            public int send_count;
            
            /// <summary>
            /// List of handles to buffers
            /// </summary>
            public int* send_list;
            
            /// <summary>
            /// Lengths of data to send, in bytes
            /// </summary>
            public int* send_sizes;
            
            /// <summary>
            /// Flags
            /// </summary>
            public libdrm.drmDMAFlags flags;
            
            /// <summary>
            /// Number of buffers requested
            /// </summary>
            public int request_count;
            
            /// <summary>
            /// Desired size of buffers requested
            /// </summary>
            public int request_size;
            
            /// <summary>
            /// Buffer information
            /// </summary>
            public int* request_list;
            
            /// <summary>
            /// Minimum acceptable sizes
            /// </summary>
            public int* request_sizes;
            
            /// <summary>
            /// Number of buffers granted at this size
            /// </summary>
            public int granted_count;
        }
        
        public partial struct drmRegion
        {
            public libdrm.drm_handle_t handle;
            
            public uint offset;
            
            public libdrm.drmSize size;
            
            public libdrm.drmAddress map;
        }
        
        public readonly partial struct drmSize : IEquatable<libdrm.drmSize>
        {
            public drmSize(uint value) => this.Value = value;
            
            public uint Value { get; }
            
            public override bool Equals(object obj) => obj is drmSize other && Equals(other);
            
            public bool Equals(drmSize other) => Value.Equals(other.Value);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint (libdrm.drmSize from) => from.Value;
            
            public static implicit operator libdrm.drmSize (uint from) => new libdrm.drmSize(from);
            
            public static bool operator ==(drmSize left, drmSize right) => left.Equals(right);
            
            public static bool operator !=(drmSize left, drmSize right) => !left.Equals(right);
        }
        
        public partial struct drmTextureRegion
        {
            public byte next;
            
            public byte prev;
            
            public byte in_use;
            
            /// <summary>
            /// Explicitly pad this out
            /// </summary>
            public byte padding;
            
            public uint age;
        }
        
        public partial struct drmVBlankReq
        {
            public libdrm.drmVBlankSeqType type;
            
            public uint sequence;
            
            public nuint signal;
        }
        
        public partial struct drmVBlankReply
        {
            public libdrm.drmVBlankSeqType type;
            
            public uint sequence;
            
            public nint tval_sec;
            
            public nint tval_usec;
        }
        
        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
        public partial struct drmVBlank
        {
            [FieldOffset(0)]
            public libdrm.drmVBlankReq request;
            
            [FieldOffset(0)]
            public libdrm.drmVBlankReply reply;
        }
        
        public partial struct drmSetVersion
        {
            public int drm_di_major;
            
            public int drm_di_minor;
            
            public int drm_dd_major;
            
            public int drm_dd_minor;
        }
        
        public partial struct drmEventContext
        {
            /// <summary>
            /// This struct is versioned so we can add more pointers if we
            /// add more events.
            /// </summary>
            public int version;
            
            public delegate*unmanaged[Cdecl]<int, uint, uint, uint, void*, void> vblank_handler;
            
            public delegate*unmanaged[Cdecl]<int, uint, uint, uint, void*, void> page_flip_handler;
            
            public delegate*unmanaged[Cdecl]<int, uint, uint, uint, uint, void*, void> page_flip_handler2;
            
            public delegate*unmanaged[Cdecl]<int, ulong, ulong, ulong, void> sequence_handler;
        }
        
        public partial struct drmPciBusInfo
        {
            public ushort domain;
            
            public byte bus;
            
            public byte dev;
            
            public byte func;
        }
        
        public partial struct drmPciDeviceInfo
        {
            public ushort vendor_id;
            
            public ushort device_id;
            
            public ushort subvendor_id;
            
            public ushort subdevice_id;
            
            public byte revision_id;
        }
        
        public partial struct drmUsbBusInfo
        {
            public byte bus;
            
            public byte dev;
        }
        
        public partial struct drmUsbDeviceInfo
        {
            public ushort vendor;
            
            public ushort product;
        }
        
        public unsafe partial struct drmPlatformBusInfo
        {
            public fixed byte fullname[512];
        }
        
        public partial struct drmPlatformDeviceInfo
        {
            /// <summary>
            /// NULL terminated list of compatible strings
            /// </summary>
            public byte** compatible;
        }
        
        public unsafe partial struct drmHost1xBusInfo
        {
            public fixed byte fullname[512];
        }
        
        public partial struct drmHost1xDeviceInfo
        {
            /// <summary>
            /// NULL terminated list of compatible strings
            /// </summary>
            public byte** compatible;
        }
        
        public partial struct drmDevice
        {
            [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
            public partial struct _drmDevice__union_0
            {
                [FieldOffset(0)]
                public libdrm.drmPciBusInfo* pci;
                
                [FieldOffset(0)]
                public libdrm.drmUsbBusInfo* usb;
                
                [FieldOffset(0)]
                public libdrm.drmPlatformBusInfo* platform;
                
                [FieldOffset(0)]
                public libdrm.drmHost1xBusInfo* host1x;
            }
            
            [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
            public partial struct _drmDevice__union_1
            {
                [FieldOffset(0)]
                public libdrm.drmPciDeviceInfo* pci;
                
                [FieldOffset(0)]
                public libdrm.drmUsbDeviceInfo* usb;
                
                [FieldOffset(0)]
                public libdrm.drmPlatformDeviceInfo* platform;
                
                [FieldOffset(0)]
                public libdrm.drmHost1xDeviceInfo* host1x;
            }
            
            /// <summary>
            /// DRM_NODE_MAX sized array
            /// </summary>
            public byte** nodes;
            
            /// <summary>
            /// DRM_NODE_* bitmask
            /// </summary>
            public int available_nodes;
            
            public int bustype;
            
            public libdrm.drmDevice._drmDevice__union_0 businfo;
            
            public libdrm.drmDevice._drmDevice__union_1 deviceinfo;
        }
        
        public const int DRM_DEV_DIRMODE = 493;
        
        public const string DRM_DIR_NAME = "/dev/dri";
        
        public const string DRM_PRIMARY_MINOR_NAME = "card";
        
        public const int DRM_ERR_NO_DEVICE = -1001;
        
        public const int DRM_ERR_NO_ACCESS = -1002;
        
        public const int DRM_ERR_NOT_ROOT = -1003;
        
        public const int DRM_ERR_INVALID = -1004;
        
        public const int DRM_ERR_NO_FD = -1005;
        
        public const uint DRM_LOCK_HELD = 2147483648;
        
        public const uint DRM_LOCK_CONT = 1073741824;
        
        public const int DRM_EVENT_CONTEXT_VERSION = 4;
        
        public const int DRM_BUS_PCI = 0;
        
        public const int DRM_BUS_USB = 1;
        
        public const int DRM_BUS_PLATFORM = 2;
        
        public const int DRM_BUS_HOST1X = 3;
        
        public const int DRM_DEVICE_GET_PCI_REVISION = 1;
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmIoctl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmIoctl(int fd, nuint request, void* arg);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetHashTable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmGetHashTable();
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetEntry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmHashEntry* drmGetEntry(int fd);
        
        /// <summary>
        /// General user-level programmer's API: unprivileged
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAvailable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAvailable();
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpen")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpen(byte* name, byte* busid);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpenWithType")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpenWithType(byte* name, byte* busid, int type);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpenControl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpenControl(int minor);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpenRender")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpenRender(int minor);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmClose")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmClose(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetVersion")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmVersion* drmGetVersion(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetLibVersion")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmVersion* drmGetLibVersion(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetCap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetCap(int fd, ulong capability, ulong* value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeVersion")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFreeVersion(libdrm.drmVersion* arg0);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetMagic")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetMagic(int fd, libdrm.drm_magic_t* magic);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetBusid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetBusid(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetInterruptFromBusID")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetInterruptFromBusID(int fd, int busnum, int devnum, int funcnum);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetMap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetMap(int fd, int idx, libdrm.drm_handle_t* offset, libdrm.drmSize* size, libdrm.drmMapType* type, libdrm.drmMapFlags* flags, libdrm.drm_handle_t* handle, int* mtrr);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetClient")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetClient(int fd, int idx, int* auth, int* pid, int* uid, nuint* magic, nuint* iocs);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetStats")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetStats(int fd, libdrm.drmStatsT* stats);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSetInterfaceVersion")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSetInterfaceVersion(int fd, libdrm.drmSetVersion* version);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCommandNone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCommandNone(int fd, nuint drmCommandIndex);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCommandRead")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCommandRead(int fd, nuint drmCommandIndex, void* data, nuint size);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCommandWrite")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCommandWrite(int fd, nuint drmCommandIndex, void* data, nuint size);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCommandWriteRead")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCommandWriteRead(int fd, nuint drmCommandIndex, void* data, nuint size);
        
        /// <summary>
        /// General user-level programmer's API: X server (root) only
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeBusid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFreeBusid(byte* busid);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSetBusid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSetBusid(int fd, byte* busid);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAuthMagic")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAuthMagic(int fd, libdrm.drm_magic_t magic);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAddMap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAddMap(int fd, libdrm.drm_handle_t offset, libdrm.drmSize size, libdrm.drmMapType type, libdrm.drmMapFlags flags, libdrm.drm_handle_t* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmRmMap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmRmMap(int fd, libdrm.drm_handle_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAddContextPrivateMapping")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAddContextPrivateMapping(int fd, libdrm.drm_context_t ctx_id, libdrm.drm_handle_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAddBufs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAddBufs(int fd, int count, int size, libdrm.drmBufDescFlags flags, int agp_offset);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmMarkBufs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmMarkBufs(int fd, double low, double high);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCreateContext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCreateContext(int fd, libdrm.drm_context_t* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSetContextFlags")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSetContextFlags(int fd, libdrm.drm_context_t context, libdrm.drm_context_tFlags flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetContextFlags")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetContextFlags(int fd, libdrm.drm_context_t context, libdrm.drm_context_tFlags* flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAddContextTag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAddContextTag(int fd, libdrm.drm_context_t context, void* tag);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDelContextTag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDelContextTag(int fd, libdrm.drm_context_t context);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetContextTag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmGetContextTag(int fd, libdrm.drm_context_t context);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetReservedContextList")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drm_context_t* drmGetReservedContextList(int fd, int* count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeReservedContextList")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFreeReservedContextList(libdrm.drm_context_t* arg0);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSwitchToContext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSwitchToContext(int fd, libdrm.drm_context_t context);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDestroyContext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDestroyContext(int fd, libdrm.drm_context_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCreateDrawable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCreateDrawable(int fd, libdrm.drm_drawable_t* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDestroyDrawable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDestroyDrawable(int fd, libdrm.drm_drawable_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmUpdateDrawableInfo")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmUpdateDrawableInfo(int fd, libdrm.drm_drawable_t handle, libdrm.drm_drawable_info_type_t type, uint num, void* data);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCtlInstHandler")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCtlInstHandler(int fd, int irq);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCtlUninstHandler")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCtlUninstHandler(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSetClientCap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSetClientCap(int fd, ulong capability, ulong value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCrtcGetSequence")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCrtcGetSequence(int fd, uint crtcId, ulong* sequence, ulong* ns);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCrtcQueueSequence")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCrtcQueueSequence(int fd, uint crtcId, uint flags, ulong sequence, ulong* sequence_queued, ulong user_data);
        
        /// <summary>
        /// General user-level programmer's API: authenticated client and/or X
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmMap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmMap(int fd, libdrm.drm_handle_t handle, libdrm.drmSize size, void** address);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmUnmap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmUnmap(libdrm.drmAddress address, libdrm.drmSize size);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetBufInfo")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmBufInfo* drmGetBufInfo(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmMapBufs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libdrm.drmBufMap* drmMapBufs(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmUnmapBufs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmUnmapBufs(libdrm.drmBufMap* bufs);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDMA")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDMA(int fd, libdrm.drmDMAReq* request);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeBufs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmFreeBufs(int fd, int count, int* list);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetLock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetLock(int fd, libdrm.drm_context_t context, libdrm.drmLockFlags flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmUnlock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmUnlock(int fd, libdrm.drm_context_t context);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFinish")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmFinish(int fd, int context, libdrm.drmLockFlags flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetContextPrivateMapping")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetContextPrivateMapping(int fd, libdrm.drm_context_t ctx_id, libdrm.drm_handle_t* handle);
        
        /// <summary>
        /// AGP/GART support: X server (root) only
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpAcquire")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpAcquire(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpRelease")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpRelease(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpEnable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpEnable(int fd, nuint mode);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpAlloc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpAlloc(int fd, nuint size, nuint type, nuint* address, libdrm.drm_handle_t* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpFree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpFree(int fd, libdrm.drm_handle_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpBind")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpBind(int fd, libdrm.drm_handle_t handle, nuint offset);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpUnbind")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpUnbind(int fd, libdrm.drm_handle_t handle);
        
        /// <summary>
        /// AGP/GART info: authenticated client and/or X
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpVersionMajor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpVersionMajor(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpVersionMinor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmAgpVersionMinor(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpGetMode")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmAgpGetMode(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpBase")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmAgpBase(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpSize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmAgpSize(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpMemoryUsed")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmAgpMemoryUsed(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpMemoryAvail")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmAgpMemoryAvail(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpVendorId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint drmAgpVendorId(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmAgpDeviceId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint drmAgpDeviceId(int fd);
        
        /// <summary>
        /// PCI scatter/gather support: X server (root) only
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmScatterGatherAlloc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmScatterGatherAlloc(int fd, nuint size, libdrm.drm_handle_t* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmScatterGatherFree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmScatterGatherFree(int fd, libdrm.drm_handle_t handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmWaitVBlank")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmWaitVBlank(int fd, libdrm.drmVBlank* vbl);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmError")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmError(int err, byte* label);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmMalloc")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmMalloc(int size);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFree(void* pt);
        
        /// <summary>
        /// Hash table routines
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashCreate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmHashCreate();
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashDestroy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashDestroy(void* t);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashLookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashLookup(void* t, nuint key, void** value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashInsert")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashInsert(void* t, nuint key, void* value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashDelete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashDelete(void* t, nuint key);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashFirst")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashFirst(void* t, nuint* key, void** value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHashNext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHashNext(void* t, nuint* key, void** value);
        
        /// <summary>
        /// PRNG routines
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmRandomCreate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmRandomCreate(nuint seed);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmRandomDestroy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmRandomDestroy(void* state);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmRandom")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint drmRandom(void* state);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmRandomDouble")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial double drmRandomDouble(void* state);
        
        /// <summary>
        /// Skip list routines
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLCreate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* drmSLCreate();
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLDestroy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLDestroy(void* l);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLLookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLLookup(void* l, nuint key, void** value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLInsert")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLInsert(void* l, nuint key, void* value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLDelete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLDelete(void* l, nuint key);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLNext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLNext(void* l, nuint* key, void** value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLFirst")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLFirst(void* l, nuint* key, void** value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLDump")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmSLDump(void* l);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSLLookupNeighbors")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSLLookupNeighbors(void* l, nuint key, nuint* prev_key, void** prev_value, nuint* next_key, void** next_value);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpenOnce")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpenOnce(void* unused, byte* BusID, int* newlyopened);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmOpenOnceWithType")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmOpenOnceWithType(byte* BusID, int* newlyopened, int type);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCloseOnce")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmCloseOnce(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmMsg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmMsg(byte* format);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSetMaster")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSetMaster(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDropMaster")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDropMaster(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmIsMaster")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmIsMaster(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmHandleEvent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmHandleEvent(int fd, libdrm.drmEventContext* evctx);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDeviceNameFromFd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetDeviceNameFromFd(int fd);
        
        /// <summary>
        /// Improved version of drmGetDeviceNameFromFd which attributes for any type of
        /// device/node - card or renderD.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDeviceNameFromFd2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetDeviceNameFromFd2(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetNodeTypeFromFd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetNodeTypeFromFd(int fd);
        
        /// <summary>
        /// Convert between GEM handles and DMA-BUF file descriptors.
        /// </summary>
        /// <remarks>
        /// Warning: since GEM handles are not reference-counted and are unique per
        /// DRM file description, the caller is expected to perform its own reference
        /// counting. drmPrimeFDToHandle is guaranteed to return the same handle for
        /// different FDs if they reference the same underlying buffer object. This
        /// could even be a buffer object originally created on the same DRM FD.When sharing a DRM FD with an API such as EGL or GBM, the caller must not
        /// use drmPrimeHandleToFD nor drmPrimeFDToHandle. A single user-space
        /// reference-counting implementation is necessary to avoid double-closing GEM
        /// handles.Two processes can't share the same DRM FD and both use it to create or
        /// import GEM handles, even when using a single user-space reference-counting
        /// implementation like GBM, because GBM doesn't share its state between
        /// processes.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmPrimeHandleToFD")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmPrimeHandleToFD(int fd, uint handle, uint flags, int* prime_fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmPrimeFDToHandle")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmPrimeFDToHandle(int fd, int prime_fd, uint* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmCloseBufferHandle")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmCloseBufferHandle(int fd, uint handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetPrimaryDeviceNameFromFd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetPrimaryDeviceNameFromFd(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetRenderDeviceNameFromFd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetRenderDeviceNameFromFd(int fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDevice")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetDevice(int fd, libdrm.drmDevice** device);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeDevice")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFreeDevice(libdrm.drmDevice** device);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDevices")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetDevices(libdrm.drmDevice** devices, int max_devices);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmFreeDevices")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void drmFreeDevices(libdrm.drmDevice** devices, int count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDevice2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetDevice2(int fd, uint flags, libdrm.drmDevice** device);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDevices2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetDevices2(uint flags, libdrm.drmDevice** devices, int max_devices);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetDeviceFromDevId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetDeviceFromDevId(nuint dev_id, uint flags, libdrm.drmDevice** device);
        
        /// <summary>
        /// Get the node type (DRM_NODE_PRIMARY or DRM_NODE_RENDER) from a device ID.
        /// </summary>
        /// <remarks>
        /// Returns negative errno on error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetNodeTypeFromDevId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmGetNodeTypeFromDevId(nuint devid);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmDevicesEqual")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmDevicesEqual(libdrm.drmDevice* a, libdrm.drmDevice* b);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjCreate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjCreate(int fd, uint flags, uint* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjDestroy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjDestroy(int fd, uint handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjHandleToFD")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjHandleToFD(int fd, uint handle, int* obj_fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjFDToHandle")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjFDToHandle(int fd, int obj_fd, uint* handle);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjImportSyncFile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjImportSyncFile(int fd, uint handle, int sync_file_fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjExportSyncFile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjExportSyncFile(int fd, uint handle, int* sync_file_fd);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjWait")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjWait(int fd, uint* handles, uint num_handles, long timeout_nsec, uint flags, uint* first_signaled);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjReset")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjReset(int fd, uint* handles, uint handle_count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjSignal")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjSignal(int fd, uint* handles, uint handle_count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjTimelineSignal")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjTimelineSignal(int fd, uint* handles, ulong* points, uint handle_count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjTimelineWait")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjTimelineWait(int fd, uint* handles, ulong* points, uint num_handles, long timeout_nsec, uint flags, uint* first_signaled);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjQuery")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjQuery(int fd, uint* handles, ulong* points, uint handle_count);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjQuery2")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjQuery2(int fd, uint* handles, ulong* points, uint handle_count, uint flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjTransfer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjTransfer(int fd, uint dst_handle, ulong dst_point, uint src_handle, ulong src_point, uint flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmSyncobjEventfd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int drmSyncobjEventfd(int fd, uint handle, ulong point, int ev_fd, uint flags);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetFormatModifierVendor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetFormatModifierVendor(ulong modifier);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetFormatModifierName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetFormatModifierName_(ulong modifier);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "drmGetFormatName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* drmGetFormatName_(uint format);
    }
}
