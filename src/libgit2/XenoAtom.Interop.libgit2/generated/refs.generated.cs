//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Normalization options for reference lookup
        /// </summary>
        [Flags]
        public enum git_reference_format_t : int
        {
            /// <summary>
            /// No particular normalization.
            /// </summary>
            GIT_REFERENCE_FORMAT_NORMAL = unchecked((int)0u),
            
            /// <summary>
            /// Control whether one-level refnames are accepted
            /// (i.e., refnames that do not contain multiple /-separated
            /// components). Those are expected to be written only using
            /// uppercase letters and underscore (FETCH_HEAD, ...)
            /// </summary>
            GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = unchecked((int)(1u << (int)0)),
            
            /// <summary>
            /// Interpret the provided name as a reference pattern for a
            /// refspec (as used with remote repositories). If this option
            /// is enabled, the name is allowed to contain a single * (
            /// &lt;star
            /// &gt;)
            /// in place of a one full pathname component
            /// (e.g., foo/
            /// &lt;star
            /// &gt;/bar but not foo/bar
            /// &lt;star
            /// &gt;).
            /// </summary>
            GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = unchecked((int)(1u << (int)1)),
            
            /// <summary>
            /// Interpret the name as part of a refspec in shorthand form
            /// so the `ONELEVEL` naming rules aren't enforced and 'master'
            /// becomes a valid name.
            /// </summary>
            GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = unchecked((int)(1u << (int)2)),
        }
        
        /// <summary>
        /// No particular normalization.
        /// </summary>
        public const libgit2.git_reference_format_t GIT_REFERENCE_FORMAT_NORMAL = git_reference_format_t.GIT_REFERENCE_FORMAT_NORMAL;
        
        /// <summary>
        /// Control whether one-level refnames are accepted
        /// (i.e., refnames that do not contain multiple /-separated
        /// components). Those are expected to be written only using
        /// uppercase letters and underscore (FETCH_HEAD, ...)
        /// </summary>
        public const libgit2.git_reference_format_t GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = git_reference_format_t.GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL;
        
        /// <summary>
        /// Interpret the provided name as a reference pattern for a
        /// refspec (as used with remote repositories). If this option
        /// is enabled, the name is allowed to contain a single * (
        /// &lt;star
        /// &gt;)
        /// in place of a one full pathname component
        /// (e.g., foo/
        /// &lt;star
        /// &gt;/bar but not foo/bar
        /// &lt;star
        /// &gt;).
        /// </summary>
        public const libgit2.git_reference_format_t GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = git_reference_format_t.GIT_REFERENCE_FORMAT_REFSPEC_PATTERN;
        
        /// <summary>
        /// Interpret the name as part of a refspec in shorthand form
        /// so the `ONELEVEL` naming rules aren't enforced and 'master'
        /// becomes a valid name.
        /// </summary>
        public const libgit2.git_reference_format_t GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = git_reference_format_t.GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND;
        
        /// <summary>
        /// Callback used to iterate over references
        /// </summary>
        /// <param name="reference">The reference object</param>
        /// <param name="payload">Payload passed to git_reference_foreach</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_reference_foreach"/>
        public readonly partial struct git_reference_foreach_cb : IEquatable<git_reference_foreach_cb>
        {
            public git_reference_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_reference, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.git_reference, void*, int>* Value;
            
            public bool Equals(git_reference_foreach_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_reference_foreach_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_reference, void*, int>*(git_reference_foreach_cb from) => from.Value;
            
            public static implicit operator git_reference_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_reference, void*, int>* from) => new git_reference_foreach_cb(from);
            
            public static bool operator ==(git_reference_foreach_cb left, git_reference_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_reference_foreach_cb left, git_reference_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Callback used to iterate over reference names
        /// </summary>
        /// <param name="name">The reference name</param>
        /// <param name="payload">Payload passed to git_reference_foreach_name</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_reference_foreach_name"/>
        public readonly partial struct git_reference_foreach_name_cb : IEquatable<git_reference_foreach_name_cb>
        {
            public git_reference_foreach_name_cb(delegate*unmanaged[Cdecl]<byte*, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<byte*, void*, int>* Value;
            
            public bool Equals(git_reference_foreach_name_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_reference_foreach_name_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, void*, int>*(git_reference_foreach_name_cb from) => from.Value;
            
            public static implicit operator git_reference_foreach_name_cb(delegate*unmanaged[Cdecl]<byte*, void*, int>* from) => new git_reference_foreach_name_cb(from);
            
            public static bool operator ==(git_reference_foreach_name_cb left, git_reference_foreach_name_cb right) => left.Equals(right);
            
            public static bool operator !=(git_reference_foreach_name_cb left, git_reference_foreach_name_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Lookup a reference by name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up reference</param>
        /// <param name="repo">the repository to look up the reference</param>
        /// <param name="name">the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The returned reference must be freed by the user.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_lookup(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Lookup a reference by name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up reference</param>
        /// <param name="repo">the repository to look up the reference</param>
        /// <param name="name">the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The returned reference must be freed by the user.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_lookup(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name);
        
        /// <summary>
        /// Lookup a reference by name and resolve immediately to OID.
        /// </summary>
        /// <param name="out">Pointer to oid to be filled in</param>
        /// <param name="repo">The repository in which to look up the reference</param>
        /// <param name="name">The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// This function provides a quick way to resolve a reference name straight
        /// through to the object id that it refers to.  This avoids having to
        /// allocate or free any `git_reference` objects for simple situations.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name_to_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_name_to_id(out libgit2.git_oid @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Lookup a reference by name and resolve immediately to OID.
        /// </summary>
        /// <param name="out">Pointer to oid to be filled in</param>
        /// <param name="repo">The repository in which to look up the reference</param>
        /// <param name="name">The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// This function provides a quick way to resolve a reference name straight
        /// through to the object id that it refers to.  This avoids having to
        /// allocate or free any `git_reference` objects for simple situations.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name_to_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_name_to_id(out libgit2.git_oid @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name);
        
        /// <summary>
        /// Lookup a reference by DWIMing its short name
        /// </summary>
        /// <param name="out">pointer in which to store the reference</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="shorthand">the short name for the reference</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Apply the git precedence rules to the given shorthand to determine
        /// which reference the user is referring to.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_dwim")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_dwim(out libgit2.git_reference @out, libgit2.git_repository repo, byte* shorthand);
        
        /// <summary>
        /// Lookup a reference by DWIMing its short name
        /// </summary>
        /// <param name="out">pointer in which to store the reference</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="shorthand">the short name for the reference</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Apply the git precedence rules to the given shorthand to determine
        /// which reference the user is referring to.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_dwim")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_dwim(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string shorthand);
        
        /// <summary>
        /// Conditionally create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_value">The expected value of the reference when updating</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_value`
        /// (i.e. if the ref has changed since the user read it).If `current_value` is all zeros, this function will return GIT_EMODIFIED
        /// if the ref already exists.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_create_matching")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_create_matching(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name, byte* target, int force, byte* current_value, byte* log_message);
        
        /// <summary>
        /// Conditionally create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_value">The expected value of the reference when updating</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_value`
        /// (i.e. if the ref has changed since the user read it).If `current_value` is all zeros, this function will return GIT_EMODIFIED
        /// if the ref already exists.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_create_matching")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_create_matching(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string target, int force, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string current_value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_create(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name, byte* target, int force, byte* log_message);
        
        /// <summary>
        /// Create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_create(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string target, int force, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Create a new direct reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_create(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name, in libgit2.git_oid id, int force, byte* log_message);
        
        /// <summary>
        /// Create a new direct reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_create(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name, in libgit2.git_oid id, int force, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Conditionally create new direct reference
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_id">The expected value of the reference at the time of update</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_id`
        /// (i.e. if the ref has changed since the user read it).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_create_matching")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_create_matching(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name, in libgit2.git_oid id, int force, in libgit2.git_oid current_id, byte* log_message);
        
        /// <summary>
        /// Conditionally create new direct reference
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_id">The expected value of the reference at the time of update</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_id`
        /// (i.e. if the ref has changed since the user read it).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_create_matching")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_create_matching(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name, in libgit2.git_oid id, int force, in libgit2.git_oid current_id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Get the OID pointed to by a direct reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return a pointer to the oid if available, NULL otherwise</returns>
        /// <remarks>
        /// Only available if the reference is direct (i.e. an object id reference,
        /// not a symbolic one).To find the OID of a symbolic ref, call `git_reference_resolve()` and
        /// then this function (or maybe use `git_reference_name_to_id()` to
        /// directly resolve a reference name all the way through to an OID).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_reference_target(libgit2.git_reference @ref);
        
        /// <summary>
        /// Return the peeled OID target of this reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return a pointer to the oid if available, NULL otherwise</returns>
        /// <remarks>
        /// This peeled OID only applies to direct references that point to
        /// a hard Tag object: it is the result of peeling such Tag.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_target_peel")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_reference_target_peel(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get full name to the reference pointed to by a symbolic reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return a pointer to the name if available, NULL otherwise</returns>
        /// <remarks>
        /// Only available if the reference is symbolic.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_reference_symbolic_target(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get full name to the reference pointed to by a symbolic reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return a pointer to the name if available, NULL otherwise</returns>
        /// <remarks>
        /// Only available if the reference is symbolic.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static partial string git_reference_symbolic_target_string(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the type of a reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return the type</returns>
        /// <remarks>
        /// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_reference_t git_reference_type(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the full name of a reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return the full name for the ref</returns>
        /// <remarks>
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_reference_name(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the full name of a reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return the full name for the ref</returns>
        /// <remarks>
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static partial string git_reference_name_string(libgit2.git_reference @ref);
        
        /// <summary>
        /// Resolve a symbolic reference to a direct reference.
        /// </summary>
        /// <param name="out">Pointer to the peeled reference</param>
        /// <param name="ref">The reference</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This method iteratively peels a symbolic reference until it resolves to
        /// a direct reference to an OID.The peeled reference is returned in the `resolved_ref` argument, and
        /// must be freed manually once it's no longer needed.If a direct reference is passed as an argument, a copy of that
        /// reference is returned. This copy must be manually freed too.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_resolve")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_resolve(out libgit2.git_reference @out, libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the repository where a reference resides.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>@return a pointer to the repo</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_reference_owner(libgit2.git_reference @ref);
        
        /// <summary>
        /// Create a new reference with the same name as the given reference but a
        /// different symbolic target. The reference must be a symbolic reference,
        /// otherwise this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="target">The new target for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.The target name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_set_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_set_target(out libgit2.git_reference @out, libgit2.git_reference @ref, byte* target, byte* log_message);
        
        /// <summary>
        /// Create a new reference with the same name as the given reference but a
        /// different symbolic target. The reference must be a symbolic reference,
        /// otherwise this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="target">The new target for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.The target name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_symbolic_set_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_symbolic_set_target(out libgit2.git_reference @out, libgit2.git_reference @ref, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string target, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Conditionally create a new reference with the same name as the given reference but a
        /// different OID target. The reference must be a direct reference, otherwise
        /// this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="id">The new target OID for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed since it was read, or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_set_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_set_target(out libgit2.git_reference @out, libgit2.git_reference @ref, in libgit2.git_oid id, byte* log_message);
        
        /// <summary>
        /// Conditionally create a new reference with the same name as the given reference but a
        /// different OID target. The reference must be a direct reference, otherwise
        /// this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="id">The new target OID for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed since it was read, or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_set_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_set_target(out libgit2.git_reference @out, libgit2.git_reference @ref, in libgit2.git_oid id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Rename an existing reference.
        /// </summary>
        /// <param name="ref">The reference to rename</param>
        /// <param name="new_name">The new name for the reference</param>
        /// <param name="force">Overwrite an existing reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This method works for both direct and symbolic references.The new name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.If the `force` flag is not enabled, and there's already
        /// a reference with the given name, the renaming will fail.IMPORTANT:
        /// The user needs to write a proper reflog entry if the
        /// reflog is enabled for the repository. We only rename
        /// the reflog if it exists.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_rename(ref libgit2.git_reference new_ref, libgit2.git_reference @ref, byte* new_name, int force, byte* log_message);
        
        /// <summary>
        /// Rename an existing reference.
        /// </summary>
        /// <param name="ref">The reference to rename</param>
        /// <param name="new_name">The new name for the reference</param>
        /// <param name="force">Overwrite an existing reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This method works for both direct and symbolic references.The new name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.If the `force` flag is not enabled, and there's already
        /// a reference with the given name, the renaming will fail.IMPORTANT:
        /// The user needs to write a proper reflog entry if the
        /// reflog is enabled for the repository. We only rename
        /// the reflog if it exists.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_rename(ref libgit2.git_reference new_ref, libgit2.git_reference @ref, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string new_name, int force, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string log_message);
        
        /// <summary>
        /// Delete an existing reference.
        /// </summary>
        /// <param name="ref">The reference to remove</param>
        /// <returns>@return 0, GIT_EMODIFIED or an error code</returns>
        /// <remarks>
        /// This method works for both direct and symbolic references.  The reference
        /// will be immediately removed on disk but the memory will not be freed.
        /// Callers must call `git_reference_free`.This function will return an error if the reference has changed
        /// from the time it was looked up.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_delete(libgit2.git_reference @ref);
        
        /// <summary>
        /// Delete an existing reference by name
        /// </summary>
        /// <param name="name">The reference to remove</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This method removes the named reference from the repository without
        /// looking at its old value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_remove(libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Delete an existing reference by name
        /// </summary>
        /// <param name="name">The reference to remove</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This method removes the named reference from the repository without
        /// looking at its old value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_remove(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name);
        
        /// <summary>
        /// Fill a list with all the references that can be found in a repository.
        /// </summary>
        /// <param name="array">Pointer to a git_strarray structure where
        /// the reference names will be stored</param>
        /// <param name="repo">Repository where to find the refs</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The string array will be filled with the names of all references; these
        /// values are owned by the user and should be free'd manually when no
        /// longer needed, using `git_strarray_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_list")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_list(ref libgit2.git_strarray array, libgit2.git_repository repo);
        
        /// <summary>
        /// Perform a callback on each reference in the repository.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="callback">Function which will be called for every listed ref</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The `callback` function will be called for each reference in the
        /// repository, receiving the reference object and the `payload` value
        /// passed to this method.  Returning a non-zero value from the callback
        /// will terminate the iteration.Note that the callback function is responsible to call `git_reference_free`
        /// on each reference passed to it.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_foreach(libgit2.git_repository repo, libgit2.git_reference_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Perform a callback on the fully-qualified name of each reference.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="callback">Function which will be called for every listed ref name</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The `callback` function will be called for each reference in the
        /// repository, receiving the name of the reference and the `payload` value
        /// passed to this method.  Returning a non-zero value from the callback
        /// will terminate the iteration.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_foreach_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_foreach_name(libgit2.git_repository repo, libgit2.git_reference_foreach_name_cb callback, void* payload);
        
        /// <summary>
        /// Create a copy of an existing reference.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="source">object to copy</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_reference_free` to free the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_dup(ref libgit2.git_reference dest, libgit2.git_reference source);
        
        /// <summary>
        /// Free the given reference.
        /// </summary>
        /// <param name="ref">git_reference</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_reference_free(libgit2.git_reference @ref);
        
        /// <summary>
        /// Compare two references.
        /// </summary>
        /// <param name="ref1">The first git_reference</param>
        /// <param name="ref2">The second git_reference</param>
        /// <returns>@return 0 if the same, else a stable but meaningless ordering.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_cmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_reference_cmp(libgit2.git_reference ref1, libgit2.git_reference ref2);
        
        /// <summary>
        /// Create an iterator for the repo's references
        /// </summary>
        /// <param name="out">pointer in which to store the iterator</param>
        /// <param name="repo">the repository</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_iterator_new(out libgit2.git_reference_iterator @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Create an iterator for the repo's references that match the
        /// specified glob
        /// </summary>
        /// <param name="out">pointer in which to store the iterator</param>
        /// <param name="repo">the repository</param>
        /// <param name="glob">the glob to match against the reference names</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_iterator_glob_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_iterator_glob_new(out libgit2.git_reference_iterator @out, libgit2.git_repository repo, byte* glob);
        
        /// <summary>
        /// Create an iterator for the repo's references that match the
        /// specified glob
        /// </summary>
        /// <param name="out">pointer in which to store the iterator</param>
        /// <param name="repo">the repository</param>
        /// <param name="glob">the glob to match against the reference names</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_iterator_glob_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_iterator_glob_new(out libgit2.git_reference_iterator @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string glob);
        
        /// <summary>
        /// Get the next reference
        /// </summary>
        /// <param name="out">pointer in which to store the reference</param>
        /// <param name="iter">the iterator</param>
        /// <returns>@return 0, GIT_ITEROVER if there are no more; or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_next(out libgit2.git_reference @out, libgit2.git_reference_iterator iter);
        
        /// <summary>
        /// Get the next reference's name
        /// </summary>
        /// <param name="out">pointer in which to store the string</param>
        /// <param name="iter">the iterator</param>
        /// <returns>@return 0, GIT_ITEROVER if there are no more; or an error code</returns>
        /// <remarks>
        /// This function is provided for convenience in case only the names
        /// are interesting as it avoids the allocation of the `git_reference`
        /// object which `git_reference_next()` needs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_next_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_next_name(out byte* @out, libgit2.git_reference_iterator iter);
        
        /// <summary>
        /// Free the iterator and its associated resources
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_reference_iterator_free(libgit2.git_reference_iterator iter);
        
        /// <summary>
        /// Perform a callback on each reference in the repository whose name
        /// matches the given pattern.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="glob">Pattern to match (fnmatch-style) against reference name.</param>
        /// <param name="callback">Function which will be called for every listed ref</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>@return 0 on success, GIT_EUSER on non-zero callback, or error code</returns>
        /// <remarks>
        /// This function acts like `git_reference_foreach()` with an additional
        /// pattern match being applied to the reference name before issuing the
        /// callback function.  See that function for more information.The pattern is matched using fnmatch or "glob" style where a '*' matches
        /// any sequence of letters, a '?' matches any letter, and square brackets
        /// can be used to define character ranges (such as "[0-9]" for digits).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_foreach_glob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_foreach_glob(libgit2.git_repository repo, byte* glob, libgit2.git_reference_foreach_name_cb callback, void* payload);
        
        /// <summary>
        /// Perform a callback on each reference in the repository whose name
        /// matches the given pattern.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="glob">Pattern to match (fnmatch-style) against reference name.</param>
        /// <param name="callback">Function which will be called for every listed ref</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>@return 0 on success, GIT_EUSER on non-zero callback, or error code</returns>
        /// <remarks>
        /// This function acts like `git_reference_foreach()` with an additional
        /// pattern match being applied to the reference name before issuing the
        /// callback function.  See that function for more information.The pattern is matched using fnmatch or "glob" style where a '*' matches
        /// any sequence of letters, a '?' matches any letter, and square brackets
        /// can be used to define character ranges (such as "[0-9]" for digits).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_foreach_glob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_foreach_glob(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string glob, libgit2.git_reference_foreach_name_cb callback, void* payload);
        
        /// <summary>
        /// Check if a reflog exists for the specified reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>@return 0 when no reflog can be found, 1 when it exists;
        /// otherwise an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_has_log")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_has_log(libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Check if a reflog exists for the specified reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>@return 0 when no reflog can be found, 1 when it exists;
        /// otherwise an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_has_log")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_has_log(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string refname);
        
        /// <summary>
        /// Ensure there is a reflog for a particular reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Make sure that successive updates to the reference will append to
        /// its log.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_ensure_log")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_ensure_log(libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Ensure there is a reflog for a particular reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Make sure that successive updates to the reference will append to
        /// its log.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_ensure_log")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_ensure_log(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string refname);
        
        /// <summary>
        /// Check if a reference is a local branch.
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>@return 1 when the reference lives in the refs/heads
        /// namespace; 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_is_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_reference_is_branch(libgit2.git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a remote tracking branch
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>@return 1 when the reference lives in the refs/remotes
        /// namespace; 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_is_remote")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_reference_is_remote(libgit2.git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a tag
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>@return 1 when the reference lives in the refs/tags
        /// namespace; 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_is_tag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_reference_is_tag(libgit2.git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a note
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>@return 1 when the reference lives in the refs/notes
        /// namespace; 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_is_note")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_reference_is_note(libgit2.git_reference @ref);
        
        /// <summary>
        /// Normalize reference name and check validity.
        /// </summary>
        /// <param name="buffer_out">User allocated buffer to store normalized name</param>
        /// <param name="buffer_size">Size of buffer_out</param>
        /// <param name="name">Reference name to be checked.</param>
        /// <param name="flags">Flags to constrain name validation rules - see the
        /// GIT_REFERENCE_FORMAT constants above.</param>
        /// <returns>@return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
        /// or an error code.</returns>
        /// <remarks>
        /// This will normalize the reference name by removing any leading slash
        /// '/' characters and collapsing runs of adjacent slashes between name
        /// components into a single slash.Once normalized, if the reference name is valid, it will be returned in
        /// the user allocated buffer.See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_normalize_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_normalize_name(byte* buffer_out, libgit2.size_t buffer_size, byte* name, uint flags);
        
        /// <summary>
        /// Normalize reference name and check validity.
        /// </summary>
        /// <param name="buffer_out">User allocated buffer to store normalized name</param>
        /// <param name="buffer_size">Size of buffer_out</param>
        /// <param name="name">Reference name to be checked.</param>
        /// <param name="flags">Flags to constrain name validation rules - see the
        /// GIT_REFERENCE_FORMAT constants above.</param>
        /// <returns>@return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
        /// or an error code.</returns>
        /// <remarks>
        /// This will normalize the reference name by removing any leading slash
        /// '/' characters and collapsing runs of adjacent slashes between name
        /// components into a single slash.Once normalized, if the reference name is valid, it will be returned in
        /// the user allocated buffer.See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_normalize_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_normalize_name(byte* buffer_out, libgit2.size_t buffer_size, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string name, uint flags);
        
        /// <summary>
        /// Recursively peel reference until object of the specified type is found.
        /// </summary>
        /// <param name="out">Pointer to the peeled git_object</param>
        /// <param name="ref">The reference to be processed</param>
        /// <param name="type">The type of the requested object (GIT_OBJECT_COMMIT,
        /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).</param>
        /// <returns>@return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code</returns>
        /// <remarks>
        /// The retrieved `peeled` object is owned by the repository
        /// and should be closed with the `git_object_free` method.If you pass `GIT_OBJECT_ANY` as the target type, then the object
        /// will be peeled until a non-tag object is met.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_peel")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_peel(out libgit2.git_object @out, libgit2.git_reference @ref, libgit2.git_object_t type);
        
        /// <summary>
        /// Ensure the reference name is well-formed.
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given reference name</param>
        /// <param name="refname">name to be checked.</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_name_is_valid(ref int valid, byte* refname);
        
        /// <summary>
        /// Ensure the reference name is well-formed.
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given reference name</param>
        /// <param name="refname">name to be checked.</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reference_name_is_valid(ref int valid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string refname);
        
        /// <summary>
        /// Get the reference's short name
        /// </summary>
        /// <param name="ref">a reference</param>
        /// <returns>@return the human-readable version of the name</returns>
        /// <remarks>
        /// This will transform the reference name into a name "human-readable"
        /// version. If no shortname is appropriate, it will return the full
        /// name.The memory is owned by the reference and must not be freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_shorthand")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_reference_shorthand(libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the reference's short name
        /// </summary>
        /// <param name="ref">a reference</param>
        /// <returns>@return the human-readable version of the name</returns>
        /// <remarks>
        /// This will transform the reference name into a name "human-readable"
        /// version. If no shortname is appropriate, it will return the full
        /// name.The memory is owned by the reference and must not be freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reference_shorthand")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static partial string git_reference_shorthand_string(libgit2.git_reference @ref);
    }
}
