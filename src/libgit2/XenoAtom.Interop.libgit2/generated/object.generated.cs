//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Lookup a reference to one of the objects in a repository.
        /// </summary>
        /// <param name="object">pointer to the looked-up object</param>
        /// <param name="repo">the repository to look up the object</param>
        /// <param name="id">the unique identifier for the object</param>
        /// <param name="type">the type of the object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The generated reference is owned by the repository and
        /// should be closed with the `git_object_free` method
        /// instead of free'd manually.The 'type' parameter must match the type of the object
        /// in the odb; the method will fail otherwise.
        /// The special value 'GIT_OBJECT_ANY' may be passed to let
        /// the method guess the object's type.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_lookup(out libgit2.git_object @object, libgit2.git_repository repo, in libgit2.git_oid id, libgit2.git_object_t type);
        
        /// <summary>
        /// Lookup a reference to one of the objects in a repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <param name="object_out">pointer where to store the looked-up object</param>
        /// <param name="repo">the repository to look up the object</param>
        /// <param name="id">a short identifier for the object</param>
        /// <param name="len">the length of the short identifier</param>
        /// <param name="type">the type of the object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The object obtained will be so that its identifier
        /// matches the first 'len' hexadecimal characters
        /// (packets of 4 bits) of the given 'id'.
        /// 'len' must be at least GIT_OID_MINPREFIXLEN, and
        /// long enough to identify a unique object matching
        /// the prefix; otherwise the method will fail.The generated reference is owned by the repository and
        /// should be closed with the `git_object_free` method
        /// instead of free'd manually.The 'type' parameter must match the type of the object
        /// in the odb; the method will fail otherwise.
        /// The special value 'GIT_OBJECT_ANY' may be passed to let
        /// the method guess the object's type.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_lookup_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_lookup_prefix(out libgit2.git_object object_out, libgit2.git_repository repo, in libgit2.git_oid id, libgit2.size_t len, libgit2.git_object_t type);
        
        /// <summary>
        /// Lookup an object that represents a tree entry.
        /// </summary>
        /// <param name="out">buffer that receives a pointer to the object (which must be freed
        /// by the caller)</param>
        /// <param name="treeish">root object that can be peeled to a tree</param>
        /// <param name="path">relative path from the root object to the desired object</param>
        /// <param name="type">type of object desired</param>
        /// <returns>@return 0 on success, or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_lookup_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_lookup_bypath(out libgit2.git_object @out, libgit2.git_object treeish, byte* path, libgit2.git_object_t type);
        
        /// <summary>
        /// Lookup an object that represents a tree entry.
        /// </summary>
        /// <param name="out">buffer that receives a pointer to the object (which must be freed
        /// by the caller)</param>
        /// <param name="treeish">root object that can be peeled to a tree</param>
        /// <param name="path">relative path from the root object to the desired object</param>
        /// <param name="type">type of object desired</param>
        /// <returns>@return 0 on success, or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_lookup_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_lookup_bypath(out libgit2.git_object @out, libgit2.git_object treeish, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string path, libgit2.git_object_t type);
        
        /// <summary>
        /// Get the id (SHA1) of a repository object
        /// </summary>
        /// <param name="obj">the repository object</param>
        /// <returns>@return the SHA1 id</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_object_id(libgit2.git_object obj);
        
        /// <summary>
        /// Get a short abbreviated OID string for the object
        /// </summary>
        /// <param name="out">Buffer to write string into</param>
        /// <param name="obj">The object to get an ID for</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 for error</returns>
        /// <remarks>
        /// This starts at the "core.abbrev" length (default 7 characters) and
        /// iteratively extends to a longer string if that length is ambiguous.
        /// The result will be unambiguous (at least until new objects are added to
        /// the repository).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_short_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_short_id(out libgit2.git_buf @out, libgit2.git_object obj);
        
        /// <summary>
        /// Get the object type of an object
        /// </summary>
        /// <param name="obj">the repository object</param>
        /// <returns>@return the object's type</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_object_t git_object_type(libgit2.git_object obj);
        
        /// <summary>
        /// Get the repository that owns this object
        /// </summary>
        /// <param name="obj">the object</param>
        /// <returns>@return the repository who owns this object</returns>
        /// <remarks>
        /// Freeing or calling `git_repository_close` on the
        /// returned pointer will invalidate the actual object.Any other operation may be run on the repository without
        /// affecting the object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_object_owner(libgit2.git_object obj);
        
        /// <summary>
        /// Close an open object
        /// </summary>
        /// <param name="object">the object to close</param>
        /// <remarks>
        /// This method instructs the library to close an existing
        /// object; note that git_objects are owned and cached by the repository
        /// so the object may or may not be freed after this library call,
        /// depending on how aggressive is the caching mechanism used
        /// by the repository.IMPORTANT:
        /// It *is* necessary to call this method when you stop using
        /// an object. Failure to do so will cause a memory leak.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_object_free(libgit2.git_object @object);
        
        /// <summary>
        /// Convert an object type to its string representation.
        /// </summary>
        /// <param name="type">object type to convert.</param>
        /// <returns>@return the corresponding string representation.</returns>
        /// <remarks>
        /// The result is a pointer to a string in static memory and
        /// should not be free()'ed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_type2string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_object_type2string(libgit2.git_object_t type);
        
        /// <summary>
        /// Convert an object type to its string representation.
        /// </summary>
        /// <param name="type">object type to convert.</param>
        /// <returns>@return the corresponding string representation.</returns>
        /// <remarks>
        /// The result is a pointer to a string in static memory and
        /// should not be free()'ed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_type2string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static partial string git_object_type2string_string(libgit2.git_object_t type);
        
        /// <summary>
        /// Convert a string object type representation to it's git_object_t.
        /// </summary>
        /// <param name="str">the string to convert.</param>
        /// <returns>@return the corresponding git_object_t.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_string2type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_object_t git_object_string2type(byte* str);
        
        /// <summary>
        /// Convert a string object type representation to it's git_object_t.
        /// </summary>
        /// <param name="str">the string to convert.</param>
        /// <returns>@return the corresponding git_object_t.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_string2type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_object_t git_object_string2type([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string str);
        
        /// <summary>
        /// Determine if the given git_object_t is a valid loose object type.
        /// </summary>
        /// <param name="type">object type to test.</param>
        /// <returns>@return true if the type represents a valid loose object type,
        /// false otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_typeisloose")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_object_typeisloose(libgit2.git_object_t type);
        
        /// <summary>
        /// Recursively peel an object until an object of the specified type is met.
        /// </summary>
        /// <param name="peeled">Pointer to the peeled git_object</param>
        /// <param name="object">The object to be processed</param>
        /// <param name="target_type">The type of the requested object (a GIT_OBJECT_ value)</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code</returns>
        /// <remarks>
        /// If the query cannot be satisfied due to the object model,
        /// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
        /// tree).If you pass `GIT_OBJECT_ANY` as the target type, then the object will
        /// be peeled until the type changes. A tag will be peeled until the
        /// referenced object is no longer a tag, and a commit will be peeled
        /// to a tree. Any other object type will return GIT_EINVALIDSPEC.If peeling a tag we discover an object which cannot be peeled to
        /// the target type due to the object model, GIT_EPEEL will be
        /// returned.You must free the returned object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_peel")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_peel(out libgit2.git_object peeled, libgit2.git_object @object, libgit2.git_object_t target_type);
        
        /// <summary>
        /// Create an in-memory copy of a Git object. The copy must be
        /// explicitly free'd or it will leak.
        /// </summary>
        /// <param name="dest">Pointer to store the copy of the object</param>
        /// <param name="source">Original object to copy</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_dup(out libgit2.git_object dest, libgit2.git_object source);
        
        /// <summary>
        /// Analyzes a buffer of raw object content and determines its validity.
        /// Tree, commit, and tag objects will be parsed and ensured that they
        /// are valid, parseable content.  (Blobs are always valid by definition.)
        /// An error message will be set with an informative message if the object
        /// is not valid.
        /// </summary>
        /// <param name="valid">Output pointer to set with validity of the object content</param>
        /// <param name="buf">The contents to validate</param>
        /// <param name="len">The length of the buffer</param>
        /// <param name="object_type">The type of the object in the buffer</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <warning>
        /// @warning This function is experimental and its signature may change in
        /// the future.
        /// </warning>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_object_rawcontent_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_object_rawcontent_is_valid(out int valid, byte* buf, libgit2.size_t len, libgit2.git_object_t object_type);
    }
}
