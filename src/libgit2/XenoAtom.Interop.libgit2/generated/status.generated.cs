//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Status flags for a single file.
        /// </summary>
        /// <remarks>
        /// A combination of these values will be returned to indicate the status of
        /// a file.  Status compares the working directory, the index, and the
        /// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
        /// represents the status of file in the index relative to the HEAD, and the
        /// `GIT_STATUS_WT` set of flags represent the status of the file in the
        /// working directory relative to the index.
        /// </remarks>
        [Flags]
        public enum git_status_t : uint
        {
            GIT_STATUS_CURRENT = unchecked((uint)0),
            
            GIT_STATUS_INDEX_NEW = unchecked((uint)(1u << 0)),
            
            GIT_STATUS_INDEX_MODIFIED = unchecked((uint)(1u << 1)),
            
            GIT_STATUS_INDEX_DELETED = unchecked((uint)(1u << 2)),
            
            GIT_STATUS_INDEX_RENAMED = unchecked((uint)(1u << 3)),
            
            GIT_STATUS_INDEX_TYPECHANGE = unchecked((uint)(1u << 4)),
            
            GIT_STATUS_WT_NEW = unchecked((uint)(1u << 7)),
            
            GIT_STATUS_WT_MODIFIED = unchecked((uint)(1u << 8)),
            
            GIT_STATUS_WT_DELETED = unchecked((uint)(1u << 9)),
            
            GIT_STATUS_WT_TYPECHANGE = unchecked((uint)(1u << 10)),
            
            GIT_STATUS_WT_RENAMED = unchecked((uint)(1u << 11)),
            
            GIT_STATUS_WT_UNREADABLE = unchecked((uint)(1u << 12)),
            
            GIT_STATUS_IGNORED = unchecked((uint)(1u << 14)),
            
            GIT_STATUS_CONFLICTED = unchecked((uint)(1u << 15)),
        }
        
        public const libgit2.git_status_t GIT_STATUS_CURRENT = git_status_t.GIT_STATUS_CURRENT;
        
        public const libgit2.git_status_t GIT_STATUS_INDEX_NEW = git_status_t.GIT_STATUS_INDEX_NEW;
        
        public const libgit2.git_status_t GIT_STATUS_INDEX_MODIFIED = git_status_t.GIT_STATUS_INDEX_MODIFIED;
        
        public const libgit2.git_status_t GIT_STATUS_INDEX_DELETED = git_status_t.GIT_STATUS_INDEX_DELETED;
        
        public const libgit2.git_status_t GIT_STATUS_INDEX_RENAMED = git_status_t.GIT_STATUS_INDEX_RENAMED;
        
        public const libgit2.git_status_t GIT_STATUS_INDEX_TYPECHANGE = git_status_t.GIT_STATUS_INDEX_TYPECHANGE;
        
        public const libgit2.git_status_t GIT_STATUS_WT_NEW = git_status_t.GIT_STATUS_WT_NEW;
        
        public const libgit2.git_status_t GIT_STATUS_WT_MODIFIED = git_status_t.GIT_STATUS_WT_MODIFIED;
        
        public const libgit2.git_status_t GIT_STATUS_WT_DELETED = git_status_t.GIT_STATUS_WT_DELETED;
        
        public const libgit2.git_status_t GIT_STATUS_WT_TYPECHANGE = git_status_t.GIT_STATUS_WT_TYPECHANGE;
        
        public const libgit2.git_status_t GIT_STATUS_WT_RENAMED = git_status_t.GIT_STATUS_WT_RENAMED;
        
        public const libgit2.git_status_t GIT_STATUS_WT_UNREADABLE = git_status_t.GIT_STATUS_WT_UNREADABLE;
        
        public const libgit2.git_status_t GIT_STATUS_IGNORED = git_status_t.GIT_STATUS_IGNORED;
        
        public const libgit2.git_status_t GIT_STATUS_CONFLICTED = git_status_t.GIT_STATUS_CONFLICTED;
        
        /// <summary>
        /// Select the files on which to report status.
        /// </summary>
        /// <remarks>
        /// With `git_status_foreach_ext`, this will control which changes get
        /// callbacks.  With `git_status_list_new`, these will control which
        /// changes are included in the list.
        /// </remarks>
        public enum git_status_show_t : uint
        {
            /// <summary>
            /// The default. This roughly matches `git status --porcelain` regarding
            /// which files are included and in what order.
            /// </summary>
            GIT_STATUS_SHOW_INDEX_AND_WORKDIR = unchecked((uint)0),
            
            /// <summary>
            /// Only gives status based on HEAD to index comparison, not looking at
            /// working directory changes.
            /// </summary>
            GIT_STATUS_SHOW_INDEX_ONLY = unchecked((uint)1),
            
            /// <summary>
            /// Only gives status based on index to working directory comparison,
            /// not comparing the index to the HEAD.
            /// </summary>
            GIT_STATUS_SHOW_WORKDIR_ONLY = unchecked((uint)2),
        }
        
        /// <summary>
        /// The default. This roughly matches `git status --porcelain` regarding
        /// which files are included and in what order.
        /// </summary>
        public const libgit2.git_status_show_t GIT_STATUS_SHOW_INDEX_AND_WORKDIR = git_status_show_t.GIT_STATUS_SHOW_INDEX_AND_WORKDIR;
        
        /// <summary>
        /// Only gives status based on HEAD to index comparison, not looking at
        /// working directory changes.
        /// </summary>
        public const libgit2.git_status_show_t GIT_STATUS_SHOW_INDEX_ONLY = git_status_show_t.GIT_STATUS_SHOW_INDEX_ONLY;
        
        /// <summary>
        /// Only gives status based on index to working directory comparison,
        /// not comparing the index to the HEAD.
        /// </summary>
        public const libgit2.git_status_show_t GIT_STATUS_SHOW_WORKDIR_ONLY = git_status_show_t.GIT_STATUS_SHOW_WORKDIR_ONLY;
        
        /// <summary>
        /// Flags to control status callbacks
        /// </summary>
        /// <remarks>
        /// Calling `git_status_foreach()` is like calling the extended version
        /// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
        /// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
        /// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
        /// </remarks>
        [Flags]
        public enum git_status_opt_t : uint
        {
            /// <summary>
            /// Says that callbacks should be made on untracked files.
            /// These will only be made if the workdir files are included in the status
            /// "show" option.
            /// </summary>
            GIT_STATUS_OPT_INCLUDE_UNTRACKED = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// Says that ignored files get callbacks.
            /// Again, these callbacks will only be made if the workdir files are
            /// included in the status "show" option.
            /// </summary>
            GIT_STATUS_OPT_INCLUDE_IGNORED = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// Indicates that callback should be made even on unmodified files.
            /// </summary>
            GIT_STATUS_OPT_INCLUDE_UNMODIFIED = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// Indicates that submodules should be skipped.
            /// This only applies if there are no pending typechanges to the submodule
            /// (either from or to another type).
            /// </summary>
            GIT_STATUS_OPT_EXCLUDE_SUBMODULES = unchecked((uint)(1u << 3)),
            
            /// <summary>
            /// Indicates that all files in untracked directories should be included.
            /// Normally if an entire directory is new, then just the top-level
            /// directory is included (with a trailing slash on the entry name).
            /// This flag says to include all of the individual files in the directory
            /// instead.
            /// </summary>
            GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = unchecked((uint)(1u << 4)),
            
            /// <summary>
            /// Indicates that the given path should be treated as a literal path,
            /// and not as a pathspec pattern.
            /// </summary>
            GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = unchecked((uint)(1u << 5)),
            
            /// <summary>
            /// Indicates that the contents of ignored directories should be included
            /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
            /// with core git.
            /// </summary>
            GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = unchecked((uint)(1u << 6)),
            
            /// <summary>
            /// Indicates that rename detection should be processed between the head and
            /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
            /// flag.
            /// </summary>
            GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = unchecked((uint)(1u << 7)),
            
            /// <summary>
            /// Indicates that rename detection should be run between the index and the
            /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
            /// flag.
            /// </summary>
            GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = unchecked((uint)(1u << 8)),
            
            /// <summary>
            /// Overrides the native case sensitivity for the file system and forces
            /// the output to be in case-sensitive order.
            /// </summary>
            GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = unchecked((uint)(1u << 9)),
            
            /// <summary>
            /// Overrides the native case sensitivity for the file system and forces
            /// the output to be in case-insensitive order.
            /// </summary>
            GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = unchecked((uint)(1u << 10)),
            
            /// <summary>
            /// Iindicates that rename detection should include rewritten files.
            /// </summary>
            GIT_STATUS_OPT_RENAMES_FROM_REWRITES = unchecked((uint)(1u << 11)),
            
            /// <summary>
            /// Bypasses the default status behavior of doing a "soft" index reload
            /// (i.e. reloading the index data if the file on disk has been modified
            /// outside libgit2).
            /// </summary>
            GIT_STATUS_OPT_NO_REFRESH = unchecked((uint)(1u << 12)),
            
            /// <summary>
            /// Tells libgit2 to refresh the stat cache in the index for files that are
            /// unchanged but have out of date stat einformation in the index.
            /// It will result in less work being done on subsequent calls to get status.
            /// This is mutually exclusive with the NO_REFRESH option.
            /// </summary>
            GIT_STATUS_OPT_UPDATE_INDEX = unchecked((uint)(1u << 13)),
            
            /// <summary>
            /// Normally files that cannot be opened or read are ignored as
            /// these are often transient files; this option will return
            /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
            /// </summary>
            GIT_STATUS_OPT_INCLUDE_UNREADABLE = unchecked((uint)(1u << 14)),
            
            /// <summary>
            /// Unreadable files will be detected and given the status
            /// untracked instead of unreadable.
            /// </summary>
            GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = unchecked((uint)(1u << 15)),
        }
        
        /// <summary>
        /// Says that callbacks should be made on untracked files.
        /// These will only be made if the workdir files are included in the status
        /// "show" option.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_INCLUDE_UNTRACKED = git_status_opt_t.GIT_STATUS_OPT_INCLUDE_UNTRACKED;
        
        /// <summary>
        /// Says that ignored files get callbacks.
        /// Again, these callbacks will only be made if the workdir files are
        /// included in the status "show" option.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_INCLUDE_IGNORED = git_status_opt_t.GIT_STATUS_OPT_INCLUDE_IGNORED;
        
        /// <summary>
        /// Indicates that callback should be made even on unmodified files.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_INCLUDE_UNMODIFIED = git_status_opt_t.GIT_STATUS_OPT_INCLUDE_UNMODIFIED;
        
        /// <summary>
        /// Indicates that submodules should be skipped.
        /// This only applies if there are no pending typechanges to the submodule
        /// (either from or to another type).
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_EXCLUDE_SUBMODULES = git_status_opt_t.GIT_STATUS_OPT_EXCLUDE_SUBMODULES;
        
        /// <summary>
        /// Indicates that all files in untracked directories should be included.
        /// Normally if an entire directory is new, then just the top-level
        /// directory is included (with a trailing slash on the entry name).
        /// This flag says to include all of the individual files in the directory
        /// instead.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = git_status_opt_t.GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;
        
        /// <summary>
        /// Indicates that the given path should be treated as a literal path,
        /// and not as a pathspec pattern.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = git_status_opt_t.GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH;
        
        /// <summary>
        /// Indicates that the contents of ignored directories should be included
        /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
        /// with core git.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = git_status_opt_t.GIT_STATUS_OPT_RECURSE_IGNORED_DIRS;
        
        /// <summary>
        /// Indicates that rename detection should be processed between the head and
        /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
        /// flag.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = git_status_opt_t.GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX;
        
        /// <summary>
        /// Indicates that rename detection should be run between the index and the
        /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
        /// flag.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = git_status_opt_t.GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR;
        
        /// <summary>
        /// Overrides the native case sensitivity for the file system and forces
        /// the output to be in case-sensitive order.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = git_status_opt_t.GIT_STATUS_OPT_SORT_CASE_SENSITIVELY;
        
        /// <summary>
        /// Overrides the native case sensitivity for the file system and forces
        /// the output to be in case-insensitive order.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = git_status_opt_t.GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY;
        
        /// <summary>
        /// Iindicates that rename detection should include rewritten files.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_RENAMES_FROM_REWRITES = git_status_opt_t.GIT_STATUS_OPT_RENAMES_FROM_REWRITES;
        
        /// <summary>
        /// Bypasses the default status behavior of doing a "soft" index reload
        /// (i.e. reloading the index data if the file on disk has been modified
        /// outside libgit2).
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_NO_REFRESH = git_status_opt_t.GIT_STATUS_OPT_NO_REFRESH;
        
        /// <summary>
        /// Tells libgit2 to refresh the stat cache in the index for files that are
        /// unchanged but have out of date stat einformation in the index.
        /// It will result in less work being done on subsequent calls to get status.
        /// This is mutually exclusive with the NO_REFRESH option.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_UPDATE_INDEX = git_status_opt_t.GIT_STATUS_OPT_UPDATE_INDEX;
        
        /// <summary>
        /// Normally files that cannot be opened or read are ignored as
        /// these are often transient files; this option will return
        /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_INCLUDE_UNREADABLE = git_status_opt_t.GIT_STATUS_OPT_INCLUDE_UNREADABLE;
        
        /// <summary>
        /// Unreadable files will be detected and given the status
        /// untracked instead of unreadable.
        /// </summary>
        public const libgit2.git_status_opt_t GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = git_status_opt_t.GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED;
        
        /// <summary>
        /// Options to control how `git_status_foreach_ext()` will issue callbacks.
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
        /// use `git_status_options_init`.
        /// </remarks>
        public partial struct git_status_options
        {
            /// <summary>
            /// The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
            /// </summary>
            public uint version;
            
            /// <summary>
            /// The `show` value is one of the `git_status_show_t` constants that
            /// control which files to scan and in what order. The default is
            /// `GIT_STATUS_SHOW_INDEX_AND_WORKDIR`.
            /// </summary>
            public libgit2.git_status_show_t show;
            
            /// <summary>
            /// The `flags` value is an OR'ed combination of the
            /// `git_status_opt_t` values above. The default is
            /// `GIT_STATUS_OPT_DEFAULTS`, which matches git's default
            /// behavior.
            /// </summary>
            public libgit2.git_status_opt_t flags;
            
            /// <summary>
            /// The `pathspec` is an array of path patterns to match (using
            /// fnmatch-style matching), or just an array of paths to match
            /// exactly if `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified
            /// in the flags.
            /// </summary>
            public libgit2.git_strarray pathspec;
            
            /// <summary>
            /// The `baseline` is the tree to be used for comparison to the
            /// working directory and index; defaults to HEAD.
            /// </summary>
            public libgit2.git_tree baseline;
            
            /// <summary>
            /// Threshold above which similar files will be considered renames.
            /// This is equivalent to the -M option. Defaults to 50.
            /// </summary>
            public ushort rename_threshold;
        }
        
        /// <summary>
        /// A status entry, providing the differences between the file as it exists
        /// in HEAD and the index, and providing the differences between the index
        /// and the working directory.
        /// </summary>
        /// <remarks>
        /// The `status` value provides the status flags for this file.The `head_to_index` value provides detailed information about the
        /// differences between the file in HEAD and the file in the index.The `index_to_workdir` value provides detailed information about the
        /// differences between the file in the index and the file in the
        /// working directory.
        /// </remarks>
        public partial struct git_status_entry
        {
            public libgit2.git_status_t status;
            
            public libgit2.git_diff_delta* head_to_index;
            
            public libgit2.git_diff_delta* index_to_workdir;
        }
        
        /// <summary>
        /// Function pointer to receive status on individual files
        /// </summary>
        /// <remarks>
        /// `path` is the relative path to the file from the root of the repository.`status_flags` is a combination of `git_status_t` values that apply.`payload` is the value you passed to the foreach function as payload.
        /// </remarks>
        public readonly partial struct git_status_cb : IEquatable<git_status_cb>
        {
            public git_status_cb(delegate*unmanaged[Cdecl]<byte*, uint, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, uint, void*, int> Value { get; }
            
            public bool Equals(git_status_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_status_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, uint, void*, int>(git_status_cb from) => from.Value;
            
            public static implicit operator git_status_cb(delegate*unmanaged[Cdecl]<byte*, uint, void*, int> from) => new git_status_cb(from);
            
            public static bool operator ==(git_status_cb left, git_status_cb right) => left.Equals(right);
            
            public static bool operator !=(git_status_cb left, git_status_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Initialize git_status_options structure
        /// </summary>
        /// <param name="opts">The `git_status_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_status_options` with default values. Equivalent to
        /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_options_init(out libgit2.git_status_options opts, uint version);
        
        /// <summary>
        /// Gather file statuses and run a callback for each one.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="callback">The function to call on each file</param>
        /// <param name="payload">Pointer to pass through to callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The callback is passed the path of the file, the status (a combination of
        /// the `git_status_t` values above) and the `payload` data pointer passed
        /// into this function.If the callback returns a non-zero value, this function will stop looping
        /// and return that value to caller.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_foreach(libgit2.git_repository repo, libgit2.git_status_cb callback, void* payload);
        
        /// <summary>
        /// Gather file status information and run callbacks as requested.
        /// </summary>
        /// <param name="repo">Repository object</param>
        /// <param name="opts">Status options structure</param>
        /// <param name="callback">The function to call on each file</param>
        /// <param name="payload">Pointer to pass through to callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// This is an extended version of the `git_status_foreach()` API that
        /// allows for more granular control over which paths will be processed and
        /// in what order.  See the `git_status_options` structure for details
        /// about the additional controls that this makes available.Note that if a `pathspec` is given in the `git_status_options` to filter
        /// the status, then the results from rename detection (if you enable it) may
        /// not be accurate.  To do rename detection properly, this must be called
        /// with no `pathspec` so that all files can be considered.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_foreach_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_foreach_ext(libgit2.git_repository repo, in libgit2.git_status_options opts, libgit2.git_status_cb callback, void* payload);
        
        /// <summary>
        /// Get file status for a single file.
        /// </summary>
        /// <param name="status_flags">Output combination of git_status_t values for file</param>
        /// <param name="repo">A repository object</param>
        /// <param name="path">The exact path to retrieve status for relative to the
        /// repository working directory</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
        /// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
        /// or if it refers to a folder, and -1 on other errors.</returns>
        /// <remarks>
        /// This tries to get status for the filename that you give.  If no files
        /// match that name (in either the HEAD, index, or working directory), this
        /// returns GIT_ENOTFOUND.If the name matches multiple files (for example, if the `path` names a
        /// directory or if running on a case- insensitive filesystem and yet the
        /// HEAD has two entries that both match the path), then this returns
        /// GIT_EAMBIGUOUS because it cannot give correct results.This does not do any sort of rename detection.  Renames require a set of
        /// targets and because of the path filtering, there is not enough
        /// information to check renames correctly.  To check file status with rename
        /// detection, there is no choice but to do a full `git_status_list_new` and
        /// scan through looking for the path that you are interested in.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_file(out libgit2.git_status_t status_flags, libgit2.git_repository repo, byte* path);
        
        /// <summary>
        /// Get file status for a single file.
        /// </summary>
        /// <param name="status_flags">Output combination of git_status_t values for file</param>
        /// <param name="repo">A repository object</param>
        /// <param name="path">The exact path to retrieve status for relative to the
        /// repository working directory</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
        /// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
        /// or if it refers to a folder, and -1 on other errors.</returns>
        /// <remarks>
        /// This tries to get status for the filename that you give.  If no files
        /// match that name (in either the HEAD, index, or working directory), this
        /// returns GIT_ENOTFOUND.If the name matches multiple files (for example, if the `path` names a
        /// directory or if running on a case- insensitive filesystem and yet the
        /// HEAD has two entries that both match the path), then this returns
        /// GIT_EAMBIGUOUS because it cannot give correct results.This does not do any sort of rename detection.  Renames require a set of
        /// targets and because of the path filtering, there is not enough
        /// information to check renames correctly.  To check file status with rename
        /// detection, there is no choice but to do a full `git_status_list_new` and
        /// scan through looking for the path that you are interested in.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_file(out libgit2.git_status_t status_flags, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Gather file status information and populate the `git_status_list`.
        /// </summary>
        /// <param name="out">Pointer to store the status results in</param>
        /// <param name="repo">Repository object</param>
        /// <param name="opts">Status options structure</param>
        /// <returns>@return 0 on success or error code</returns>
        /// <remarks>
        /// Note that if a `pathspec` is given in the `git_status_options` to filter
        /// the status, then the results from rename detection (if you enable it) may
        /// not be accurate.  To do rename detection properly, this must be called
        /// with no `pathspec` so that all files can be considered.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_list_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_list_new(out libgit2.git_status_list @out, libgit2.git_repository repo, in libgit2.git_status_options opts);
        
        /// <summary>
        /// Gets the count of status entries in this list.
        /// </summary>
        /// <param name="statuslist">Existing status list object</param>
        /// <returns>@return the number of status entries</returns>
        /// <remarks>
        /// If there are no changes in status (at least according the options given
        /// when the status list was created), this can return 0.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_list_entrycount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_status_list_entrycount(libgit2.git_status_list statuslist);
        
        /// <summary>
        /// Get a pointer to one of the entries in the status list.
        /// </summary>
        /// <param name="statuslist">Existing status list object</param>
        /// <param name="idx">Position of the entry</param>
        /// <returns>@return Pointer to the entry; NULL if out of bounds</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_byindex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_status_entry* git_status_byindex(libgit2.git_status_list statuslist, libgit2.size_t idx);
        
        /// <summary>
        /// Free an existing status list
        /// </summary>
        /// <param name="statuslist">Existing status list object</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_list_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_status_list_free(libgit2.git_status_list statuslist);
        
        /// <summary>
        /// Test if the ignore rules apply to a given file.
        /// </summary>
        /// <param name="ignored">Boolean returning 0 if the file is not ignored, 1 if it is</param>
        /// <param name="repo">A repository object</param>
        /// <param name="path">The file to check ignores for, rooted at the repo's workdir.</param>
        /// <returns>@return 0 if ignore rules could be processed for the file (regardless
        /// of whether it exists or not), or an error 
        /// &lt;
        /// 0 if they could not.</returns>
        /// <remarks>
        /// This function checks the ignore rules to see if they would apply to the
        /// given file.  This indicates if the file would be ignored regardless of
        /// whether the file is already in the index or committed to the repository.One way to think of this is if you were to do "git add ." on the
        /// directory containing the file, would it be added or not?
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_should_ignore")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_should_ignore(out int ignored, libgit2.git_repository repo, byte* path);
        
        /// <summary>
        /// Test if the ignore rules apply to a given file.
        /// </summary>
        /// <param name="ignored">Boolean returning 0 if the file is not ignored, 1 if it is</param>
        /// <param name="repo">A repository object</param>
        /// <param name="path">The file to check ignores for, rooted at the repo's workdir.</param>
        /// <returns>@return 0 if ignore rules could be processed for the file (regardless
        /// of whether it exists or not), or an error 
        /// &lt;
        /// 0 if they could not.</returns>
        /// <remarks>
        /// This function checks the ignore rules to see if they would apply to the
        /// given file.  This indicates if the file would be ignored regardless of
        /// whether the file is already in the index or committed to the repository.One way to think of this is if you were to do "git add ." on the
        /// directory containing the file, would it be added or not?
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_status_should_ignore")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_status_should_ignore(out int ignored, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
    }
}
