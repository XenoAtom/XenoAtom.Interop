//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Stages that are reported by the packbuilder progress callback.
        /// </summary>
        public enum git_packbuilder_stage_t : int
        {
            GIT_PACKBUILDER_ADDING_OBJECTS = unchecked((int)0),
            
            GIT_PACKBUILDER_DELTAFICATION = unchecked((int)1),
        }
        
        public const libgit2.git_packbuilder_stage_t GIT_PACKBUILDER_ADDING_OBJECTS = git_packbuilder_stage_t.GIT_PACKBUILDER_ADDING_OBJECTS;
        
        public const libgit2.git_packbuilder_stage_t GIT_PACKBUILDER_DELTAFICATION = git_packbuilder_stage_t.GIT_PACKBUILDER_DELTAFICATION;
        
        /// <summary>
        /// Callback used to iterate over packed objects
        /// </summary>
        /// <param name="buf">A pointer to the object's data</param>
        /// <param name="size">The size of the underlying object</param>
        /// <param name="payload">Payload passed to git_packbuilder_foreach</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_packbuilder_foreach"/>
        public readonly partial struct git_packbuilder_foreach_cb : IEquatable<git_packbuilder_foreach_cb>
        {
            public git_packbuilder_foreach_cb(delegate*unmanaged[Cdecl]<void*, libgit2.size_t, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<void*, libgit2.size_t, void*, int>* Value;
            
            public bool Equals(git_packbuilder_foreach_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_packbuilder_foreach_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<void*, libgit2.size_t, void*, int>*(git_packbuilder_foreach_cb from) => from.Value;
            
            public static implicit operator git_packbuilder_foreach_cb(delegate*unmanaged[Cdecl]<void*, libgit2.size_t, void*, int>* from) => new git_packbuilder_foreach_cb(from);
            
            public static bool operator ==(git_packbuilder_foreach_cb left, git_packbuilder_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_packbuilder_foreach_cb left, git_packbuilder_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Packbuilder progress notification function
        /// </summary>
        public readonly partial struct git_packbuilder_progress : IEquatable<git_packbuilder_progress>
        {
            public git_packbuilder_progress(delegate*unmanaged[Cdecl]<int, uint, uint, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<int, uint, uint, void*, int>* Value;
            
            public bool Equals(git_packbuilder_progress other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_packbuilder_progress other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<int, uint, uint, void*, int>*(git_packbuilder_progress from) => from.Value;
            
            public static implicit operator git_packbuilder_progress(delegate*unmanaged[Cdecl]<int, uint, uint, void*, int>* from) => new git_packbuilder_progress(from);
            
            public static bool operator ==(git_packbuilder_progress left, git_packbuilder_progress right) => left.Equals(right);
            
            public static bool operator !=(git_packbuilder_progress left, git_packbuilder_progress right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Initialize a new packbuilder
        /// </summary>
        /// <param name="out">The new packbuilder object</param>
        /// <param name="repo">The repository</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_new(out libgit2.git_packbuilder @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Set number of threads to spawn
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="n">Number of threads to spawn</param>
        /// <returns>@return number of actual threads to be used</returns>
        /// <remarks>
        /// By default, libgit2 won't spawn any threads at all;
        /// when set to 0, libgit2 will autodetect the number of
        /// CPUs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_set_threads")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint git_packbuilder_set_threads(libgit2.git_packbuilder pb, uint n);
        
        /// <summary>
        /// Insert a single object
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="id">The oid of the commit</param>
        /// <param name="name">The name; might be NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// For an optimal pack it's mandatory to insert objects in recency order,
        /// commits followed by trees and blobs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert(libgit2.git_packbuilder pb, in libgit2.git_oid id, byte* name);
        
        /// <summary>
        /// Insert a single object
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="id">The oid of the commit</param>
        /// <param name="name">The name; might be NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// For an optimal pack it's mandatory to insert objects in recency order,
        /// commits followed by trees and blobs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert(libgit2.git_packbuilder pb, in libgit2.git_oid id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Insert a root tree object
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="id">The oid of the root tree</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will add the tree as well as all referenced trees and blobs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert_tree(libgit2.git_packbuilder pb, in libgit2.git_oid id);
        
        /// <summary>
        /// Insert a commit object
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="id">The oid of the commit</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will add a commit as well as the completed referenced tree.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert_commit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert_commit(libgit2.git_packbuilder pb, in libgit2.git_oid id);
        
        /// <summary>
        /// Insert objects as given by the walk
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <param name="walk">the revwalk to use to fill the packbuilder</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Those commits and all objects they reference will be inserted into
        /// the packbuilder.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert_walk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert_walk(libgit2.git_packbuilder pb, libgit2.git_revwalk walk);
        
        /// <summary>
        /// Recursively insert an object and its referenced objects
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <param name="id">the id of the root object to insert</param>
        /// <param name="name">optional name for the object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Insert the object as well as any object it references.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert_recur")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert_recur(libgit2.git_packbuilder pb, in libgit2.git_oid id, byte* name);
        
        /// <summary>
        /// Recursively insert an object and its referenced objects
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <param name="id">the id of the root object to insert</param>
        /// <param name="name">optional name for the object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Insert the object as well as any object it references.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_insert_recur")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_insert_recur(libgit2.git_packbuilder pb, in libgit2.git_oid id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Write the contents of the packfile to an in-memory buffer
        /// </summary>
        /// <param name="buf">Buffer where to write the packfile</param>
        /// <param name="pb">The packbuilder</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The contents of the buffer will become a valid packfile, even though there
        /// will be no attached index
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_write_buf")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_write_buf(ref libgit2.git_buf buf, libgit2.git_packbuilder pb);
        
        /// <summary>
        /// Write the new pack and corresponding index file to path.
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="path">Path to the directory where the packfile and index should be stored, or NULL for default location</param>
        /// <param name="mode">permissions to use creating a packfile or 0 for defaults</param>
        /// <param name="progress_cb">function to call with progress information from the indexer (optional)</param>
        /// <param name="progress_cb_payload">payload for the progress callback (optional)</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_write")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_write(libgit2.git_packbuilder pb, byte* path, uint mode, libgit2.git_indexer_progress_cb progress_cb, void* progress_cb_payload);
        
        /// <summary>
        /// Write the new pack and corresponding index file to path.
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        /// <param name="path">Path to the directory where the packfile and index should be stored, or NULL for default location</param>
        /// <param name="mode">permissions to use creating a packfile or 0 for defaults</param>
        /// <param name="progress_cb">function to call with progress information from the indexer (optional)</param>
        /// <param name="progress_cb_payload">payload for the progress callback (optional)</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_write")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_write(libgit2.git_packbuilder pb, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> path, uint mode, libgit2.git_indexer_progress_cb progress_cb, void* progress_cb_payload);
        
        /// <summary>
        /// Get the unique name for the resulting packfile.
        /// </summary>
        /// <param name="pb">the packbuilder instance</param>
        /// <returns>@return a NUL terminated string for the packfile name</returns>
        /// <remarks>
        /// The packfile's name is derived from the packfile's content.
        /// This is only correct after the packfile has been written.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_packbuilder_name(libgit2.git_packbuilder pb);
        
        /// <summary>
        /// Get the unique name for the resulting packfile.
        /// </summary>
        /// <param name="pb">the packbuilder instance</param>
        /// <returns>@return a NUL terminated string for the packfile name</returns>
        /// <remarks>
        /// The packfile's name is derived from the packfile's content.
        /// This is only correct after the packfile has been written.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))]
        public static partial string git_packbuilder_name_string(libgit2.git_packbuilder pb);
        
        /// <summary>
        /// Create the new pack and pass each object to the callback
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <param name="cb">the callback to call with each packed object's buffer</param>
        /// <param name="payload">the callback's data</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_foreach(libgit2.git_packbuilder pb, libgit2.git_packbuilder_foreach_cb cb, void* payload);
        
        /// <summary>
        /// Get the total number of objects the packbuilder will write out
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <returns>@return the number of objects in the packfile</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_object_count")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_packbuilder_object_count(libgit2.git_packbuilder pb);
        
        /// <summary>
        /// Get the number of objects the packbuilder has already written out
        /// </summary>
        /// <param name="pb">the packbuilder</param>
        /// <returns>@return the number of objects which have already been written</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_written")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_packbuilder_written(libgit2.git_packbuilder pb);
        
        /// <summary>
        /// Set the callbacks for a packbuilder
        /// </summary>
        /// <param name="pb">The packbuilder object</param>
        /// <param name="progress_cb">Function to call with progress information during
        /// pack building. Be aware that this is called inline with pack building
        /// operations, so performance may be affected.</param>
        /// <param name="progress_cb_payload">Payload for progress callback.</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_set_callbacks")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_packbuilder_set_callbacks(libgit2.git_packbuilder pb, libgit2.git_packbuilder_progress progress_cb, void* progress_cb_payload);
        
        /// <summary>
        /// Free the packbuilder and all associated data
        /// </summary>
        /// <param name="pb">The packbuilder</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_packbuilder_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_packbuilder_free(libgit2.git_packbuilder pb);
    }
}
