//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Filters are applied in one of two directions: smudging - which is
        /// exporting a file from the Git object database to the working directory,
        /// and cleaning - which is importing a file from the working directory to
        /// the Git object database.  These values control which direction of
        /// change is being applied.
        /// </summary>
        public enum git_filter_mode_t : uint
        {
            GIT_FILTER_TO_WORKTREE = unchecked((uint)0),
            
            GIT_FILTER_SMUDGE = unchecked((uint)GIT_FILTER_TO_WORKTREE),
            
            GIT_FILTER_TO_ODB = unchecked((uint)1),
            
            GIT_FILTER_CLEAN = unchecked((uint)GIT_FILTER_TO_ODB),
        }
        
        public const libgit2.git_filter_mode_t GIT_FILTER_TO_WORKTREE = git_filter_mode_t.GIT_FILTER_TO_WORKTREE;
        
        public const libgit2.git_filter_mode_t GIT_FILTER_SMUDGE = git_filter_mode_t.GIT_FILTER_SMUDGE;
        
        public const libgit2.git_filter_mode_t GIT_FILTER_TO_ODB = git_filter_mode_t.GIT_FILTER_TO_ODB;
        
        public const libgit2.git_filter_mode_t GIT_FILTER_CLEAN = git_filter_mode_t.GIT_FILTER_CLEAN;
        
        /// <summary>
        /// Filter option flags.
        /// </summary>
        [Flags]
        public enum git_filter_flag_t : uint
        {
            GIT_FILTER_DEFAULT = unchecked((uint)0u),
            
            /// <summary>
            /// Don't error for `safecrlf` violations, allow them to continue.
            /// </summary>
            GIT_FILTER_ALLOW_UNSAFE = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// Don't load `/etc/gitattributes` (or the system equivalent)
            /// </summary>
            GIT_FILTER_NO_SYSTEM_ATTRIBUTES = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// Load attributes from `.gitattributes` in the root of HEAD
            /// </summary>
            GIT_FILTER_ATTRIBUTES_FROM_HEAD = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// Load attributes from `.gitattributes` in a given commit.
            /// This can only be specified in a `git_filter_options`.
            /// </summary>
            GIT_FILTER_ATTRIBUTES_FROM_COMMIT = unchecked((uint)(1u << 3)),
        }
        
        public const libgit2.git_filter_flag_t GIT_FILTER_DEFAULT = git_filter_flag_t.GIT_FILTER_DEFAULT;
        
        /// <summary>
        /// Don't error for `safecrlf` violations, allow them to continue.
        /// </summary>
        public const libgit2.git_filter_flag_t GIT_FILTER_ALLOW_UNSAFE = git_filter_flag_t.GIT_FILTER_ALLOW_UNSAFE;
        
        /// <summary>
        /// Don't load `/etc/gitattributes` (or the system equivalent)
        /// </summary>
        public const libgit2.git_filter_flag_t GIT_FILTER_NO_SYSTEM_ATTRIBUTES = git_filter_flag_t.GIT_FILTER_NO_SYSTEM_ATTRIBUTES;
        
        /// <summary>
        /// Load attributes from `.gitattributes` in the root of HEAD
        /// </summary>
        public const libgit2.git_filter_flag_t GIT_FILTER_ATTRIBUTES_FROM_HEAD = git_filter_flag_t.GIT_FILTER_ATTRIBUTES_FROM_HEAD;
        
        /// <summary>
        /// Load attributes from `.gitattributes` in a given commit.
        /// This can only be specified in a `git_filter_options`.
        /// </summary>
        public const libgit2.git_filter_flag_t GIT_FILTER_ATTRIBUTES_FROM_COMMIT = git_filter_flag_t.GIT_FILTER_ATTRIBUTES_FROM_COMMIT;
        
        /// <summary>
        /// Filtering options
        /// </summary>
        public partial struct git_filter_options
        {
            public uint version;
            
            /// <summary>
            /// See `git_filter_flag_t` above
            /// </summary>
            public libgit2.git_filter_flag_t flags;
            
            public void* reserved;
            
            /// <summary>
            /// The commit to load attributes from, when
            /// `GIT_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
            /// </summary>
            public libgit2.git_oid attr_commit_id;
        }
        
        /// <summary>
        /// A filter that can transform file data
        /// </summary>
        /// <remarks>
        /// This represents a filter that can be used to transform or even replace
        /// file data.  Libgit2 includes one built in filter and it is possible to
        /// write your own (see git2/sys/filter.h for information on that).The two builtin filters are:* "crlf" which uses the complex rules with the "text", "eol", and
        /// "crlf" file attributes to decide how to convert between LF and CRLF
        /// line endings
        /// * "ident" which replaces "$Id$" in a blob with "$Id: &lt;blob OID&gt;$" upon
        /// checkout and replaced "$Id: &lt;anything&gt;$" with "$Id$" on checkin.
        /// </remarks>
        public readonly partial struct git_filter : IEquatable<git_filter>
        {
            public git_filter(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_filter other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_filter other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_filter left, git_filter right) => left.Equals(right);
            
            public static bool operator !=(git_filter left, git_filter right) => !left.Equals(right);
        }
        
        /// <summary>
        /// List of filters to be applied
        /// </summary>
        /// <remarks>
        /// This represents a list of filters to be applied to a file / blob.  You
        /// can build the list with one call, apply it with another, and dispose it
        /// with a third.  In typical usage, there are not many occasions where a
        /// git_filter_list is needed directly since the library will generally
        /// handle conversions for you, but it can be convenient to be able to
        /// build and apply the list sometimes.
        /// </remarks>
        public readonly partial struct git_filter_list : IEquatable<git_filter_list>
        {
            public git_filter_list(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_filter_list other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_filter_list other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_filter_list left, git_filter_list right) => left.Equals(right);
            
            public static bool operator !=(git_filter_list left, git_filter_list right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Load the filter list for a given path.
        /// </summary>
        /// <param name="filters">Output newly created git_filter_list (or NULL)</param>
        /// <param name="repo">Repository object that contains `path`</param>
        /// <param name="blob">The blob to which the filter will be applied (if known)</param>
        /// <param name="path">Relative path of the file to be filtered</param>
        /// <param name="mode">Filtering direction (WT-&gt;ODB or ODB-&gt;WT)</param>
        /// <param name="flags">Combination of `git_filter_flag_t` flags</param>
        /// <returns>@return 0 on success (which could still return NULL if no filters are
        /// needed for the requested file), 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This will return 0 (success) but set the output git_filter_list to NULL
        /// if no filters are requested for the given file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_load")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_load(out libgit2.git_filter_list filters, libgit2.git_repository repo, libgit2.git_blob blob, byte* path, libgit2.git_filter_mode_t mode, libgit2.git_filter_flag_t flags);
        
        /// <summary>
        /// Load the filter list for a given path.
        /// </summary>
        /// <param name="filters">Output newly created git_filter_list (or NULL)</param>
        /// <param name="repo">Repository object that contains `path`</param>
        /// <param name="blob">The blob to which the filter will be applied (if known)</param>
        /// <param name="path">Relative path of the file to be filtered</param>
        /// <param name="mode">Filtering direction (WT-&gt;ODB or ODB-&gt;WT)</param>
        /// <param name="flags">Combination of `git_filter_flag_t` flags</param>
        /// <returns>@return 0 on success (which could still return NULL if no filters are
        /// needed for the requested file), 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This will return 0 (success) but set the output git_filter_list to NULL
        /// if no filters are requested for the given file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_load")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_load(out libgit2.git_filter_list filters, libgit2.git_repository repo, libgit2.git_blob blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_filter_mode_t mode, libgit2.git_filter_flag_t flags);
        
        /// <summary>
        /// Load the filter list for a given path.
        /// </summary>
        /// <param name="filters">Output newly created git_filter_list (or NULL)</param>
        /// <param name="repo">Repository object that contains `path`</param>
        /// <param name="blob">The blob to which the filter will be applied (if known)</param>
        /// <param name="path">Relative path of the file to be filtered</param>
        /// <param name="mode">Filtering direction (WT-&gt;ODB or ODB-&gt;WT)</param>
        /// <param name="opts">The `git_filter_options` to use when loading filters</param>
        /// <returns>@return 0 on success (which could still return NULL if no filters are
        /// needed for the requested file), 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This will return 0 (success) but set the output git_filter_list to NULL
        /// if no filters are requested for the given file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_load_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_load_ext(out libgit2.git_filter_list filters, libgit2.git_repository repo, libgit2.git_blob blob, byte* path, libgit2.git_filter_mode_t mode, ref libgit2.git_filter_options opts);
        
        /// <summary>
        /// Load the filter list for a given path.
        /// </summary>
        /// <param name="filters">Output newly created git_filter_list (or NULL)</param>
        /// <param name="repo">Repository object that contains `path`</param>
        /// <param name="blob">The blob to which the filter will be applied (if known)</param>
        /// <param name="path">Relative path of the file to be filtered</param>
        /// <param name="mode">Filtering direction (WT-&gt;ODB or ODB-&gt;WT)</param>
        /// <param name="opts">The `git_filter_options` to use when loading filters</param>
        /// <returns>@return 0 on success (which could still return NULL if no filters are
        /// needed for the requested file), 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This will return 0 (success) but set the output git_filter_list to NULL
        /// if no filters are requested for the given file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_load_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_load_ext(out libgit2.git_filter_list filters, libgit2.git_repository repo, libgit2.git_blob blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_filter_mode_t mode, ref libgit2.git_filter_options opts);
        
        /// <summary>
        /// Query the filter list to see if a given filter (by name) will run.
        /// The built-in filters "crlf" and "ident" can be queried, otherwise this
        /// is the name of the filter specified by the filter attribute.
        /// </summary>
        /// <param name="filters">A loaded git_filter_list (or NULL)</param>
        /// <param name="name">The name of the filter to query</param>
        /// <returns>@return 1 if the filter is in the list, 0 otherwise</returns>
        /// <remarks>
        /// This will return 0 if the given filter is not in the list, or 1 if
        /// the filter will be applied.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_contains")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_contains(libgit2.git_filter_list filters, byte* name);
        
        /// <summary>
        /// Query the filter list to see if a given filter (by name) will run.
        /// The built-in filters "crlf" and "ident" can be queried, otherwise this
        /// is the name of the filter specified by the filter attribute.
        /// </summary>
        /// <param name="filters">A loaded git_filter_list (or NULL)</param>
        /// <param name="name">The name of the filter to query</param>
        /// <returns>@return 1 if the filter is in the list, 0 otherwise</returns>
        /// <remarks>
        /// This will return 0 if the given filter is not in the list, or 1 if
        /// the filter will be applied.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_contains")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_contains(libgit2.git_filter_list filters, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Apply filter list to a data buffer.
        /// </summary>
        /// <param name="out">Buffer to store the result of the filtering</param>
        /// <param name="filters">A loaded git_filter_list (or NULL)</param>
        /// <param name="in">Buffer containing the data to filter</param>
        /// <param name="in_len">The length of the input buffer</param>
        /// <returns>@return 0 on success, an error code otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_apply_to_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_apply_to_buffer(out libgit2.git_buf @out, libgit2.git_filter_list filters, byte* @in, libgit2.size_t in_len);
        
        /// <summary>
        /// Apply a filter list to the contents of a file on disk
        /// </summary>
        /// <param name="out">buffer into which to store the filtered file</param>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="repo">the repository in which to perform the filtering</param>
        /// <param name="path">the path of the file to filter, a relative path will be
        /// taken as relative to the workdir</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_apply_to_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_apply_to_file(out libgit2.git_buf @out, libgit2.git_filter_list filters, libgit2.git_repository repo, byte* path);
        
        /// <summary>
        /// Apply a filter list to the contents of a file on disk
        /// </summary>
        /// <param name="out">buffer into which to store the filtered file</param>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="repo">the repository in which to perform the filtering</param>
        /// <param name="path">the path of the file to filter, a relative path will be
        /// taken as relative to the workdir</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_apply_to_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_apply_to_file(out libgit2.git_buf @out, libgit2.git_filter_list filters, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Apply a filter list to the contents of a blob
        /// </summary>
        /// <param name="out">buffer into which to store the filtered file</param>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="blob">the blob to filter</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_apply_to_blob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_apply_to_blob(out libgit2.git_buf @out, libgit2.git_filter_list filters, libgit2.git_blob blob);
        
        /// <summary>
        /// Apply a filter list to an arbitrary buffer as a stream
        /// </summary>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="buffer">the buffer to filter</param>
        /// <param name="len">the size of the buffer</param>
        /// <param name="target">the stream into which the data will be written</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_stream_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_stream_buffer(libgit2.git_filter_list filters, byte* buffer, libgit2.size_t len, ref libgit2.git_writestream target);
        
        /// <summary>
        /// Apply a filter list to a file as a stream
        /// </summary>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="repo">the repository in which to perform the filtering</param>
        /// <param name="path">the path of the file to filter, a relative path will be
        /// taken as relative to the workdir</param>
        /// <param name="target">the stream into which the data will be written</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_stream_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_stream_file(libgit2.git_filter_list filters, libgit2.git_repository repo, byte* path, ref libgit2.git_writestream target);
        
        /// <summary>
        /// Apply a filter list to a file as a stream
        /// </summary>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="repo">the repository in which to perform the filtering</param>
        /// <param name="path">the path of the file to filter, a relative path will be
        /// taken as relative to the workdir</param>
        /// <param name="target">the stream into which the data will be written</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_stream_file")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_stream_file(libgit2.git_filter_list filters, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, ref libgit2.git_writestream target);
        
        /// <summary>
        /// Apply a filter list to a blob as a stream
        /// </summary>
        /// <param name="filters">the list of filters to apply</param>
        /// <param name="blob">the blob to filter</param>
        /// <param name="target">the stream into which the data will be written</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_stream_blob")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_filter_list_stream_blob(libgit2.git_filter_list filters, libgit2.git_blob blob, ref libgit2.git_writestream target);
        
        /// <summary>
        /// Free a git_filter_list
        /// </summary>
        /// <param name="filters">A git_filter_list created by `git_filter_list_load`</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_filter_list_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_filter_list_free(libgit2.git_filter_list filters);
    }
}
