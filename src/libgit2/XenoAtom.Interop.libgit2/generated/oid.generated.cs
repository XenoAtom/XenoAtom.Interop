//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// The type of object id.
        /// </summary>
        public enum git_oid_t : int
        {
            /// <summary>
            /// SHA1
            /// </summary>
            GIT_OID_SHA1 = unchecked((int)1),
        }
        
        /// <summary>
        /// SHA1
        /// </summary>
        public const libgit2.git_oid_t GIT_OID_SHA1 = git_oid_t.GIT_OID_SHA1;
        
        /// <summary>
        /// Unique identity of any object (commit, tree, blob, tag).
        /// </summary>
        public unsafe partial struct git_oid
        {
            /// <summary>
            /// raw binary formatted id
            /// </summary>
            public fixed byte id[20];
        }
        
        /// <summary>
        /// OID Shortener object
        /// </summary>
        public readonly partial struct git_oid_shorten : IEquatable<git_oid_shorten>
        {
            public git_oid_shorten(nint handle) => Handle = handle;
            
            public readonly nint Handle;
            
            public bool Equals(git_oid_shorten other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_oid_shorten other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_oid_shorten left, git_oid_shorten right) => left.Equals(right);
            
            public static bool operator !=(git_oid_shorten left, git_oid_shorten right) => !left.Equals(right);
        }
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstr(out libgit2.git_oid @out, byte* str);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstr(out libgit2.git_oid @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> str);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstrp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstrp(out libgit2.git_oid @out, byte* str);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstrp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstrp(out libgit2.git_oid @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> str);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstrn")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstrn(out libgit2.git_oid @out, byte* str, libgit2.size_t length);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromstrn")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromstrn(out libgit2.git_oid @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> str, libgit2.size_t length);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fromraw")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_fromraw(out libgit2.git_oid @out, byte* raw);
        
        /// <summary>
        /// Format a git_oid into a hex string.
        /// </summary>
        /// <param name="out">output hex string; must be pointing at the start of
        /// the hex sequence and have at least the number of bytes
        /// needed for an oid encoded in hex (40 bytes for SHA1,
        /// 64 bytes for SHA256). Only the oid digits are written;
        /// a '
        /// \
        /// 0' terminator must be added by the caller if it is
        /// required.</param>
        /// <param name="id">oid structure to format.</param>
        /// <returns>@return 0 on success or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_fmt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_oid_fmt(byte* @out, in libgit2.git_oid id);
        
        /// <summary>
        /// Format a git_oid into a partial hex string.
        /// </summary>
        /// <param name="out">output hex string; you say how many bytes to write.
        /// If the number of bytes is &gt; GIT_OID_SHA1_HEXSIZE, extra bytes
        /// will be zeroed; if not, a '
        /// \
        /// 0' terminator is NOT added.</param>
        /// <param name="n">number of characters to write into out string</param>
        /// <param name="id">oid structure to format.</param>
        /// <returns>@return 0 on success or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_nfmt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_oid_nfmt(byte* @out, libgit2.size_t n, in libgit2.git_oid id);
        
        /// <summary>
        /// Format a git_oid into a loose-object path string.
        /// </summary>
        /// <param name="out">output hex string; must be pointing at the start of
        /// the hex sequence and have at least the number of bytes
        /// needed for an oid encoded in hex (41 bytes for SHA1,
        /// 65 bytes for SHA256). Only the oid digits are written;
        /// a '
        /// \
        /// 0' terminator must be added by the caller if it
        /// is required.</param>
        /// <param name="id">oid structure to format.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The resulting string is "aa/...", where "aa" is the first two
        /// hex digits of the oid and "..." is the remaining 38 digits.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_pathfmt")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_oid_pathfmt(byte* @out, in libgit2.git_oid id);
        
        /// <summary>
        /// Format a git_oid into a statically allocated c-string.
        /// </summary>
        /// <param name="oid">The oid structure to format</param>
        /// <returns>@return the c-string or NULL on failure</returns>
        /// <remarks>
        /// The c-string is owned by the library and should not be freed
        /// by the user. If libgit2 is built with thread support, the string
        /// will be stored in TLS (i.e. one buffer per thread) to allow for
        /// concurrent calls of the function.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_tostr_s")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_oid_tostr_s(in libgit2.git_oid oid);
        
        /// <summary>
        /// Format a git_oid into a buffer as a hex format c-string.
        /// </summary>
        /// <param name="out">the buffer into which the oid string is output.</param>
        /// <param name="n">the size of the out buffer.</param>
        /// <param name="id">the oid structure to format.</param>
        /// <returns>@return the out buffer pointer, assuming no input parameter
        /// errors, otherwise a pointer to an empty string.</returns>
        /// <remarks>
        /// If the buffer is smaller than the size of a hex-formatted oid string
        /// plus an additional byte (GIT_OID_SHA_HEXSIZE + 1 for SHA1 or
        /// GIT_OID_SHA256_HEXSIZE + 1 for SHA256), then the resulting
        /// oid c-string will be truncated to n-1 characters (but will still be
        /// NUL-byte terminated).If there are any input parameter errors (out == NULL, n == 0, oid ==
        /// NULL), then a pointer to an empty string is returned, so that the
        /// return value can always be printed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_tostr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_oid_tostr(byte* @out, libgit2.size_t n, in libgit2.git_oid id);
        
        /// <summary>
        /// Copy an oid from one structure to another.
        /// </summary>
        /// <param name="out">oid structure the result is written into.</param>
        /// <param name="src">oid structure to copy from.</param>
        /// <returns>@return 0 on success or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_cpy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_oid_cpy(out libgit2.git_oid @out, in libgit2.git_oid src);
        
        /// <summary>
        /// Compare two oid structures.
        /// </summary>
        /// <param name="a">first oid structure.</param>
        /// <param name="b">second oid structure.</param>
        /// <returns>@return &lt;
        /// 0, 0, &gt;0 if a 
        /// &lt;
        /// b, a == b, a &gt; b.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_cmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_cmp(in libgit2.git_oid a, in libgit2.git_oid b);
        
        /// <summary>
        /// Compare two oid structures for equality
        /// </summary>
        /// <param name="a">first oid structure.</param>
        /// <param name="b">second oid structure.</param>
        /// <returns>@return true if equal, false otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_equal")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_equal(in libgit2.git_oid a, in libgit2.git_oid b);
        
        /// <summary>
        /// Compare the first 'len' hexadecimal characters (packets of 4 bits)
        /// of two oid structures.
        /// </summary>
        /// <param name="a">first oid structure.</param>
        /// <param name="b">second oid structure.</param>
        /// <param name="len">the number of hex chars to compare</param>
        /// <returns>@return 0 in case of a match</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_ncmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_ncmp(in libgit2.git_oid a, in libgit2.git_oid b, libgit2.size_t len);
        
        /// <summary>
        /// Check if an oid equals an hex formatted object id.
        /// </summary>
        /// <param name="id">oid structure.</param>
        /// <param name="str">input hex string of an object id.</param>
        /// <returns>@return 0 in case of a match, -1 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_streq")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_streq(in libgit2.git_oid id, byte* str);
        
        /// <summary>
        /// Check if an oid equals an hex formatted object id.
        /// </summary>
        /// <param name="id">oid structure.</param>
        /// <param name="str">input hex string of an object id.</param>
        /// <returns>@return 0 in case of a match, -1 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_streq")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_streq(in libgit2.git_oid id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> str);
        
        /// <summary>
        /// Compare an oid to an hex formatted object id.
        /// </summary>
        /// <param name="id">oid structure.</param>
        /// <param name="str">input hex string of an object id.</param>
        /// <returns>@return -1 if str is not valid, 
        /// &lt;
        /// 0 if id sorts before str,
        /// 0 if id matches str, &gt;0 if id sorts after str.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_strcmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_strcmp(in libgit2.git_oid id, byte* str);
        
        /// <summary>
        /// Compare an oid to an hex formatted object id.
        /// </summary>
        /// <param name="id">oid structure.</param>
        /// <param name="str">input hex string of an object id.</param>
        /// <returns>@return -1 if str is not valid, 
        /// &lt;
        /// 0 if id sorts before str,
        /// 0 if id matches str, &gt;0 if id sorts after str.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_strcmp")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_strcmp(in libgit2.git_oid id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> str);
        
        /// <summary>
        /// Check is an oid is all zeros.
        /// </summary>
        /// <returns>@return 1 if all zeros, 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_is_zero")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_is_zero(in libgit2.git_oid id);
        
        /// <summary>
        /// Create a new OID shortener.
        /// </summary>
        /// <param name="min_length">The minimal length for all identifiers,
        /// which will be used even if shorter OIDs would still
        /// be unique.</param>
        /// <returns>@return a `git_oid_shorten` instance, NULL if OOM</returns>
        /// <remarks>
        /// The OID shortener is used to process a list of OIDs
        /// in text form and return the shortest length that would
        /// uniquely identify all of them.E.g. look at the result of `git log --abbrev`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_shorten_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid_shorten git_oid_shorten_new(libgit2.size_t min_length);
        
        /// <summary>
        /// Add a new OID to set of shortened OIDs and calculate
        /// the minimal length to uniquely identify all the OIDs in
        /// the set.
        /// </summary>
        /// <param name="os">a `git_oid_shorten` instance</param>
        /// <param name="text_id">an OID in text form</param>
        /// <returns>@return the minimal length to uniquely identify all OIDs
        /// added so far to the set; or an error code (
        /// &lt;
        /// 0) if an
        /// error occurs.</returns>
        /// <remarks>
        /// The OID is expected to be a 40-char hexadecimal string.
        /// The OID is owned by the user and will not be modified
        /// or freed.For performance reasons, there is a hard-limit of how many
        /// OIDs can be added to a single set (around ~32000, assuming
        /// a mostly randomized distribution), which should be enough
        /// for any kind of program, and keeps the algorithm fast and
        /// memory-efficient.Attempting to add more than those OIDs will result in a
        /// GIT_ERROR_INVALID error
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_shorten_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_shorten_add(libgit2.git_oid_shorten os, byte* text_id);
        
        /// <summary>
        /// Add a new OID to set of shortened OIDs and calculate
        /// the minimal length to uniquely identify all the OIDs in
        /// the set.
        /// </summary>
        /// <param name="os">a `git_oid_shorten` instance</param>
        /// <param name="text_id">an OID in text form</param>
        /// <returns>@return the minimal length to uniquely identify all OIDs
        /// added so far to the set; or an error code (
        /// &lt;
        /// 0) if an
        /// error occurs.</returns>
        /// <remarks>
        /// The OID is expected to be a 40-char hexadecimal string.
        /// The OID is owned by the user and will not be modified
        /// or freed.For performance reasons, there is a hard-limit of how many
        /// OIDs can be added to a single set (around ~32000, assuming
        /// a mostly randomized distribution), which should be enough
        /// for any kind of program, and keeps the algorithm fast and
        /// memory-efficient.Attempting to add more than those OIDs will result in a
        /// GIT_ERROR_INVALID error
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_shorten_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_oid_shorten_add(libgit2.git_oid_shorten os, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> text_id);
        
        /// <summary>
        /// Free an OID shortener instance
        /// </summary>
        /// <param name="os">a `git_oid_shorten` instance</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_oid_shorten_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_oid_shorten_free(libgit2.git_oid_shorten os);
    }
}
