//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Stash flags
        /// </summary>
        [Flags]
        public enum git_stash_flags : int
        {
            /// <summary>
            /// No option, default
            /// </summary>
            GIT_STASH_DEFAULT = unchecked((int)0),
            
            /// <summary>
            /// All changes already added to the index are left intact in
            /// the working directory
            /// </summary>
            GIT_STASH_KEEP_INDEX = unchecked((int)(1  << (int) 0)),
            
            /// <summary>
            /// All untracked files are also stashed and then cleaned up
            /// from the working directory
            /// </summary>
            GIT_STASH_INCLUDE_UNTRACKED = unchecked((int)(1  << (int) 1)),
            
            /// <summary>
            /// All ignored files are also stashed and then cleaned up from
            /// the working directory
            /// </summary>
            GIT_STASH_INCLUDE_IGNORED = unchecked((int)(1  << (int) 2)),
            
            /// <summary>
            /// All changes in the index and working directory are left intact
            /// </summary>
            GIT_STASH_KEEP_ALL = unchecked((int)(1  << (int) 3)),
        }
        
        /// <summary>
        /// No option, default
        /// </summary>
        public const libgit2.git_stash_flags GIT_STASH_DEFAULT = git_stash_flags.GIT_STASH_DEFAULT;
        
        /// <summary>
        /// All changes already added to the index are left intact in
        /// the working directory
        /// </summary>
        public const libgit2.git_stash_flags GIT_STASH_KEEP_INDEX = git_stash_flags.GIT_STASH_KEEP_INDEX;
        
        /// <summary>
        /// All untracked files are also stashed and then cleaned up
        /// from the working directory
        /// </summary>
        public const libgit2.git_stash_flags GIT_STASH_INCLUDE_UNTRACKED = git_stash_flags.GIT_STASH_INCLUDE_UNTRACKED;
        
        /// <summary>
        /// All ignored files are also stashed and then cleaned up from
        /// the working directory
        /// </summary>
        public const libgit2.git_stash_flags GIT_STASH_INCLUDE_IGNORED = git_stash_flags.GIT_STASH_INCLUDE_IGNORED;
        
        /// <summary>
        /// All changes in the index and working directory are left intact
        /// </summary>
        public const libgit2.git_stash_flags GIT_STASH_KEEP_ALL = git_stash_flags.GIT_STASH_KEEP_ALL;
        
        /// <summary>
        /// Stash application flags.
        /// </summary>
        [Flags]
        public enum git_stash_apply_flags : int
        {
            GIT_STASH_APPLY_DEFAULT = unchecked((int)0),
            
            /// <summary>
            /// Try to reinstate not only the working tree's changes,
            /// but also the index's changes.
            /// </summary>
            GIT_STASH_APPLY_REINSTATE_INDEX = unchecked((int)(1  << (int) 0)),
        }
        
        public const libgit2.git_stash_apply_flags GIT_STASH_APPLY_DEFAULT = git_stash_apply_flags.GIT_STASH_APPLY_DEFAULT;
        
        /// <summary>
        /// Try to reinstate not only the working tree's changes,
        /// but also the index's changes.
        /// </summary>
        public const libgit2.git_stash_apply_flags GIT_STASH_APPLY_REINSTATE_INDEX = git_stash_apply_flags.GIT_STASH_APPLY_REINSTATE_INDEX;
        
        /// <summary>
        /// Stash apply progression states
        /// </summary>
        public enum git_stash_apply_progress_t : int
        {
            GIT_STASH_APPLY_PROGRESS_NONE = unchecked((int)0),
            
            /// <summary>
            /// Loading the stashed data from the object database.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
            
            /// <summary>
            /// The stored index is being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
            
            /// <summary>
            /// The modified files are being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
            
            /// <summary>
            /// The untracked and ignored files are being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
            
            /// <summary>
            /// The untracked files are being written to disk.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
            
            /// <summary>
            /// The modified files are being written to disk.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
            
            /// <summary>
            /// The stash was applied successfully.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_DONE,
        }
        
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_NONE = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_NONE;
        
        /// <summary>
        /// Loading the stashed data from the object database.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_LOADING_STASH = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_LOADING_STASH;
        
        /// <summary>
        /// The stored index is being analyzed.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX;
        
        /// <summary>
        /// The modified files are being analyzed.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED;
        
        /// <summary>
        /// The untracked and ignored files are being analyzed.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED;
        
        /// <summary>
        /// The untracked files are being written to disk.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED;
        
        /// <summary>
        /// The modified files are being written to disk.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED;
        
        /// <summary>
        /// The stash was applied successfully.
        /// </summary>
        public const libgit2.git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_DONE = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_DONE;
        
        /// <summary>
        /// Stash save options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_STASH_SAVE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_stash_save_options_init`.
        /// </remarks>
        public partial struct git_stash_save_options
        {
            public uint version;
            
            /// <summary>
            /// Flags to control the stashing process. (see GIT_STASH_* above)
            /// </summary>
            public libgit2.git_stash_flags flags;
            
            /// <summary>
            /// The identity of the person performing the stashing.
            /// </summary>
            public readonly libgit2.git_signature* stasher;
            
            /// <summary>
            /// Optional description along with the stashed state.
            /// </summary>
            public readonly byte* message;
            
            /// <summary>
            /// Optional paths that control which files are stashed.
            /// </summary>
            public libgit2.git_strarray paths;
        }
        
        /// <summary>
        /// Stash application options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
        /// use `git_stash_apply_options_init`.
        /// </remarks>
        public partial struct git_stash_apply_options
        {
            public uint version;
            
            /// <summary>
            /// See `git_stash_apply_flags`, above.
            /// </summary>
            public libgit2.git_stash_apply_flags flags;
            
            /// <summary>
            /// Options to use when writing files to the working directory.
            /// </summary>
            public libgit2.git_checkout_options checkout_options;
            
            /// <summary>
            /// Optional callback to notify the consumer of application progress.
            /// </summary>
            public libgit2.git_stash_apply_progress_cb progress_cb;
            
            public void* progress_payload;
        }
        
        /// <summary>
        /// Stash application progress notification function.
        /// Return 0 to continue processing, or a negative value to
        /// abort the stash application.
        /// </summary>
        public readonly partial struct git_stash_apply_progress_cb : IEquatable<git_stash_apply_progress_cb>
        {
            public git_stash_apply_progress_cb(delegate*unmanaged[Cdecl]<libgit2.git_stash_apply_progress_t, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.git_stash_apply_progress_t, void*, int>* Value;
            
            public bool Equals(git_stash_apply_progress_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_stash_apply_progress_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_stash_apply_progress_t, void*, int>*(git_stash_apply_progress_cb from) => from.Value;
            
            public static implicit operator git_stash_apply_progress_cb(delegate*unmanaged[Cdecl]<libgit2.git_stash_apply_progress_t, void*, int>* from) => new git_stash_apply_progress_cb(from);
            
            public static bool operator ==(git_stash_apply_progress_cb left, git_stash_apply_progress_cb right) => left.Equals(right);
            
            public static bool operator !=(git_stash_apply_progress_cb left, git_stash_apply_progress_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// This is a callback function you can provide to iterate over all the
        /// stashed states that will be invoked per entry.
        /// </summary>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <param name="message">The stash message.</param>
        /// <param name="stash_id">The commit oid of the stashed state.</param>
        /// <param name="payload">Extra parameter to callback function.</param>
        /// <returns>@return 0 to continue iterating or non-zero to stop.</returns>
        public readonly partial struct git_stash_cb : IEquatable<git_stash_cb>
        {
            public git_stash_cb(delegate*unmanaged[Cdecl]<libgit2.size_t, byte*, libgit2.git_oid*, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.size_t, byte*, libgit2.git_oid*, void*, int>* Value;
            
            public bool Equals(git_stash_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_stash_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.size_t, byte*, libgit2.git_oid*, void*, int>*(git_stash_cb from) => from.Value;
            
            public static implicit operator git_stash_cb(delegate*unmanaged[Cdecl]<libgit2.size_t, byte*, libgit2.git_oid*, void*, int>* from) => new git_stash_cb(from);
            
            public static bool operator ==(git_stash_cb left, git_stash_cb right) => left.Equals(right);
            
            public static bool operator !=(git_stash_cb left, git_stash_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Save the local modifications to a new stash.
        /// </summary>
        /// <param name="out">Object id of the commit containing the stashed state.
        /// This commit is also the target of the direct reference refs/stash.</param>
        /// <param name="repo">The owning repository.</param>
        /// <param name="stasher">The identity of the person performing the stashing.</param>
        /// <param name="message">Optional description along with the stashed state.</param>
        /// <param name="flags">Flags to control the stashing process. (see GIT_STASH_* above)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
        /// or error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_save")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_save(out libgit2.git_oid @out, libgit2.git_repository repo, in libgit2.git_signature stasher, byte* message, libgit2.git_stash_flags flags);
        
        /// <summary>
        /// Save the local modifications to a new stash.
        /// </summary>
        /// <param name="out">Object id of the commit containing the stashed state.
        /// This commit is also the target of the direct reference refs/stash.</param>
        /// <param name="repo">The owning repository.</param>
        /// <param name="stasher">The identity of the person performing the stashing.</param>
        /// <param name="message">Optional description along with the stashed state.</param>
        /// <param name="flags">Flags to control the stashing process. (see GIT_STASH_* above)</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
        /// or error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_save")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_save(out libgit2.git_oid @out, libgit2.git_repository repo, in libgit2.git_signature stasher, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> message, libgit2.git_stash_flags flags);
        
        /// <summary>
        /// Initialize git_stash_save_options structure
        /// </summary>
        /// <param name="opts">The `git_stash_save_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_STASH_SAVE_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_stash_save_options` with default values. Equivalent to
        /// creating an instance with `GIT_STASH_SAVE_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_save_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_save_options_init(out libgit2.git_stash_save_options opts, uint version);
        
        /// <summary>
        /// Save the local modifications to a new stash, with options.
        /// </summary>
        /// <param name="out">Object id of the commit containing the stashed state.
        /// This commit is also the target of the direct reference refs/stash.</param>
        /// <param name="repo">The owning repository.</param>
        /// <param name="opts">The stash options.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
        /// or error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_save_with_opts")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_save_with_opts(out libgit2.git_oid @out, libgit2.git_repository repo, in libgit2.git_stash_save_options opts);
        
        /// <summary>
        /// Initialize git_stash_apply_options structure
        /// </summary>
        /// <param name="opts">The `git_stash_apply_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_stash_apply_options` with default values. Equivalent to
        /// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_apply_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_apply_options_init(out libgit2.git_stash_apply_options opts, uint version);
        
        /// <summary>
        /// Apply a single stashed state from the stash list.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <param name="options">Optional options to control how stashes are applied.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if there's no stashed state for the
        /// given index, GIT_EMERGECONFLICT if changes exist in the working
        /// directory, or an error code</returns>
        /// <remarks>
        /// If local changes in the working directory conflict with changes in the
        /// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
        /// will always remain unmodified and all files in the working directory will
        /// remain unmodified.  However, if you are restoring untracked files or
        /// ignored files and there is a conflict when applying the modified files,
        /// then those files will remain in the working directory.If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
        /// conflicts when reinstating the index, the function will return
        /// GIT_EMERGECONFLICT and both the working directory and index will be left
        /// unmodified.Note that a minimum checkout strategy of `GIT_CHECKOUT_SAFE` is implied.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_apply")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_apply(libgit2.git_repository repo, libgit2.size_t index, in libgit2.git_stash_apply_options options);
        
        /// <summary>
        /// Loop over all the stashed states and issue a callback for each one.
        /// </summary>
        /// <param name="repo">Repository where to find the stash.</param>
        /// <param name="callback">Callback to invoke per found stashed state. The most
        /// recent stash state will be enumerated first.</param>
        /// <param name="payload">Extra parameter to callback function.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code.</returns>
        /// <remarks>
        /// If the callback returns a non-zero value, this will stop looping.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_foreach(libgit2.git_repository repo, libgit2.git_stash_cb callback, void* payload);
        
        /// <summary>
        /// Remove a single stashed state from the stash list.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
        /// index, or error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_drop")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_drop(libgit2.git_repository repo, libgit2.size_t index);
        
        /// <summary>
        /// Apply a single stashed state from the stash list and remove it from the list
        /// if successful.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <param name="options">Optional options to control how stashes are applied.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
        /// index, or error code. (see git_stash_apply() above for details)</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_stash_pop")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_stash_pop(libgit2.git_repository repo, libgit2.size_t index, in libgit2.git_stash_apply_options options);
    }
}
