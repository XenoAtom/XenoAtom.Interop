//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Argument to the completion callback which tells it which operation
        /// finished.
        /// </summary>
        public enum git_remote_completion_t : int
        {
            GIT_REMOTE_COMPLETION_DOWNLOAD,
            
            GIT_REMOTE_COMPLETION_INDEXING,
            
            GIT_REMOTE_COMPLETION_ERROR,
        }
        
        public const libgit2.git_remote_completion_t GIT_REMOTE_COMPLETION_DOWNLOAD = git_remote_completion_t.GIT_REMOTE_COMPLETION_DOWNLOAD;
        
        public const libgit2.git_remote_completion_t GIT_REMOTE_COMPLETION_INDEXING = git_remote_completion_t.GIT_REMOTE_COMPLETION_INDEXING;
        
        public const libgit2.git_remote_completion_t GIT_REMOTE_COMPLETION_ERROR = git_remote_completion_t.GIT_REMOTE_COMPLETION_ERROR;
        
        /// <summary>
        /// Remote redirection settings; whether redirects to another host
        /// are permitted.  By default, git will follow a redirect on the
        /// initial request (`/info/refs`), but not subsequent requests.
        /// </summary>
        [Flags]
        public enum git_remote_redirect_t : int
        {
            /// <summary>
            /// Do not follow any off-site redirects at any stage of
            /// the fetch or push.
            /// </summary>
            GIT_REMOTE_REDIRECT_NONE = unchecked((int)(1  << (int) 0)),
            
            /// <summary>
            /// Allow off-site redirects only upon the initial request.
            /// This is the default.
            /// </summary>
            GIT_REMOTE_REDIRECT_INITIAL = unchecked((int)(1  << (int) 1)),
            
            /// <summary>
            /// Allow redirects at any stage in the fetch or push.
            /// </summary>
            GIT_REMOTE_REDIRECT_ALL = unchecked((int)(1  << (int) 2)),
        }
        
        /// <summary>
        /// Do not follow any off-site redirects at any stage of
        /// the fetch or push.
        /// </summary>
        public const libgit2.git_remote_redirect_t GIT_REMOTE_REDIRECT_NONE = git_remote_redirect_t.GIT_REMOTE_REDIRECT_NONE;
        
        /// <summary>
        /// Allow off-site redirects only upon the initial request.
        /// This is the default.
        /// </summary>
        public const libgit2.git_remote_redirect_t GIT_REMOTE_REDIRECT_INITIAL = git_remote_redirect_t.GIT_REMOTE_REDIRECT_INITIAL;
        
        /// <summary>
        /// Allow redirects at any stage in the fetch or push.
        /// </summary>
        public const libgit2.git_remote_redirect_t GIT_REMOTE_REDIRECT_ALL = git_remote_redirect_t.GIT_REMOTE_REDIRECT_ALL;
        
        /// <summary>
        /// Remote creation options flags
        /// </summary>
        [Flags]
        public enum git_remote_create_flags : int
        {
            /// <summary>
            /// Ignore the repository apply.insteadOf configuration
            /// </summary>
            GIT_REMOTE_CREATE_SKIP_INSTEADOF = unchecked((int)(1  << (int) 0)),
            
            /// <summary>
            /// Don't build a fetchspec from the name if none is set
            /// </summary>
            GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = unchecked((int)(1  << (int) 1)),
        }
        
        /// <summary>
        /// Ignore the repository apply.insteadOf configuration
        /// </summary>
        public const libgit2.git_remote_create_flags GIT_REMOTE_CREATE_SKIP_INSTEADOF = git_remote_create_flags.GIT_REMOTE_CREATE_SKIP_INSTEADOF;
        
        /// <summary>
        /// Don't build a fetchspec from the name if none is set
        /// </summary>
        public const libgit2.git_remote_create_flags GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = git_remote_create_flags.GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC;
        
        /// <summary>
        /// Acceptable prune settings when fetching
        /// </summary>
        public enum git_fetch_prune_t : int
        {
            /// <summary>
            /// Use the setting from the configuration
            /// </summary>
            GIT_FETCH_PRUNE_UNSPECIFIED,
            
            /// <summary>
            /// Force pruning on
            /// </summary>
            GIT_FETCH_PRUNE,
            
            /// <summary>
            /// Force pruning off
            /// </summary>
            GIT_FETCH_NO_PRUNE,
        }
        
        /// <summary>
        /// Use the setting from the configuration
        /// </summary>
        public const libgit2.git_fetch_prune_t GIT_FETCH_PRUNE_UNSPECIFIED = git_fetch_prune_t.GIT_FETCH_PRUNE_UNSPECIFIED;
        
        /// <summary>
        /// Force pruning on
        /// </summary>
        public const libgit2.git_fetch_prune_t GIT_FETCH_PRUNE = git_fetch_prune_t.GIT_FETCH_PRUNE;
        
        /// <summary>
        /// Force pruning off
        /// </summary>
        public const libgit2.git_fetch_prune_t GIT_FETCH_NO_PRUNE = git_fetch_prune_t.GIT_FETCH_NO_PRUNE;
        
        /// <summary>
        /// Automatic tag following option
        /// </summary>
        /// <remarks>
        /// Lets us select the --tags option to use.
        /// </remarks>
        public enum git_remote_autotag_option_t : int
        {
            /// <summary>
            /// Use the setting from the configuration.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = unchecked((int)0),
            
            /// <summary>
            /// Ask the server for tags pointing to objects we're already
            /// downloading.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
            
            /// <summary>
            /// Don't ask for any tags beyond the refspecs.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_NONE,
            
            /// <summary>
            /// Ask for the all the tags.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_ALL,
        }
        
        /// <summary>
        /// Use the setting from the configuration.
        /// </summary>
        public const libgit2.git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED;
        
        /// <summary>
        /// Ask the server for tags pointing to objects we're already
        /// downloading.
        /// </summary>
        public const libgit2.git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_AUTO = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_AUTO;
        
        /// <summary>
        /// Don't ask for any tags beyond the refspecs.
        /// </summary>
        public const libgit2.git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_NONE = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_NONE;
        
        /// <summary>
        /// Ask for the all the tags.
        /// </summary>
        public const libgit2.git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_ALL = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_ALL;
        
        /// <summary>
        /// Constants for fetch depth (shallowness of fetch).
        /// </summary>
        public enum git_fetch_depth_t : int
        {
            /// <summary>
            /// The fetch is "full" (not shallow). This is the default.
            /// </summary>
            GIT_FETCH_DEPTH_FULL = unchecked((int)0),
            
            /// <summary>
            /// The fetch should "unshallow" and fetch missing data.
            /// </summary>
            GIT_FETCH_DEPTH_UNSHALLOW = unchecked((int)2147483647),
        }
        
        /// <summary>
        /// The fetch is "full" (not shallow). This is the default.
        /// </summary>
        public const libgit2.git_fetch_depth_t GIT_FETCH_DEPTH_FULL = git_fetch_depth_t.GIT_FETCH_DEPTH_FULL;
        
        /// <summary>
        /// The fetch should "unshallow" and fetch missing data.
        /// </summary>
        public const libgit2.git_fetch_depth_t GIT_FETCH_DEPTH_UNSHALLOW = git_fetch_depth_t.GIT_FETCH_DEPTH_UNSHALLOW;
        
        /// <summary>
        /// Remote creation options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_remote_create_options_init`.
        /// </remarks>
        public partial struct git_remote_create_options
        {
            public uint version;
            
            /// <summary>
            /// The repository that should own the remote.
            /// Setting this to NULL results in a detached remote.
            /// </summary>
            public libgit2.git_repository repository;
            
            /// <summary>
            /// The remote's name.
            /// Setting this to NULL results in an in-memory/anonymous remote.
            /// </summary>
            public byte* name;
            
            /// <summary>
            /// The fetchspec the remote should use.
            /// </summary>
            public byte* fetchspec;
            
            /// <summary>
            /// Additional flags for the remote. See git_remote_create_flags.
            /// </summary>
            public libgit2.git_remote_create_flags flags;
        }
        
        /// <summary>
        /// Represents an update which will be performed on the remote during push
        /// </summary>
        public partial struct git_push_update
        {
            /// <summary>
            /// The source name of the reference
            /// </summary>
            public byte* src_refname;
            
            /// <summary>
            /// The name of the reference to update on the server
            /// </summary>
            public byte* dst_refname;
            
            /// <summary>
            /// The current target of the reference
            /// </summary>
            public libgit2.git_oid src;
            
            /// <summary>
            /// The new target for the reference
            /// </summary>
            public libgit2.git_oid dst;
        }
        
        /// <summary>
        /// Fetch options structure.
        /// </summary>
        /// <remarks>
        /// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
        /// correctly set the `version` field.  E.g.git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
        /// </remarks>
        public partial struct git_fetch_options
        {
            public int version;
            
            /// <summary>
            /// Callbacks to use for this fetch operation
            /// </summary>
            public libgit2.git_remote_callbacks callbacks;
            
            /// <summary>
            /// Whether to perform a prune after the fetch
            /// </summary>
            public libgit2.git_fetch_prune_t prune;
            
            /// <summary>
            /// Whether to write the results to FETCH_HEAD. Defaults to
            /// on. Leave this default in order to behave like git.
            /// </summary>
            public int update_fetchhead;
            
            /// <summary>
            /// Determines how to behave regarding tags on the remote, such
            /// as auto-downloading tags for objects we're downloading or
            /// downloading all of them.
            /// </summary>
            /// <remarks>
            /// The default is to auto-follow tags.
            /// </remarks>
            public libgit2.git_remote_autotag_option_t download_tags;
            
            /// <summary>
            /// Proxy options to use, by default no proxy is used.
            /// </summary>
            public libgit2.git_proxy_options proxy_opts;
            
            /// <summary>
            /// Depth of the fetch to perform, or `GIT_FETCH_DEPTH_FULL`
            /// (or `0`) for full history, or `GIT_FETCH_DEPTH_UNSHALLOW`
            /// to "unshallow" a shallow repository.
            /// </summary>
            /// <remarks>
            /// The default is full (`GIT_FETCH_DEPTH_FULL` or `0`).
            /// </remarks>
            public int depth;
            
            /// <summary>
            /// Whether to allow off-site redirects.  If this is not
            /// specified, the `http.followRedirects` configuration setting
            /// will be consulted.
            /// </summary>
            public libgit2.git_remote_redirect_t follow_redirects;
            
            /// <summary>
            /// Extra headers for this fetch operation
            /// </summary>
            public libgit2.git_strarray custom_headers;
        }
        
        /// <summary>
        /// Controls the behavior of a git_push object.
        /// </summary>
        public partial struct git_push_options
        {
            public uint version;
            
            /// <summary>
            /// If the transport being used to push to the remote requires the creation
            /// of a pack file, this controls the number of worker threads used by
            /// the packbuilder when creating that pack file to be sent to the remote.
            /// </summary>
            /// <remarks>
            /// If set to 0, the packbuilder will auto-detect the number of threads
            /// to create. The default value is 1.
            /// </remarks>
            public uint pb_parallelism;
            
            /// <summary>
            /// Callbacks to use for this push operation
            /// </summary>
            public libgit2.git_remote_callbacks callbacks;
            
            /// <summary>
            /// Proxy options to use, by default no proxy is used.
            /// </summary>
            public libgit2.git_proxy_options proxy_opts;
            
            /// <summary>
            /// Whether to allow off-site redirects.  If this is not
            /// specified, the `http.followRedirects` configuration setting
            /// will be consulted.
            /// </summary>
            public libgit2.git_remote_redirect_t follow_redirects;
            
            /// <summary>
            /// Extra headers for this push operation
            /// </summary>
            public libgit2.git_strarray custom_headers;
        }
        
        /// <summary>
        /// Remote creation options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_remote_create_options_init`.
        /// </remarks>
        public partial struct git_remote_connect_options
        {
            public uint version;
            
            /// <summary>
            /// Callbacks to use for this connection
            /// </summary>
            public libgit2.git_remote_callbacks callbacks;
            
            /// <summary>
            /// HTTP Proxy settings
            /// </summary>
            public libgit2.git_proxy_options proxy_opts;
            
            /// <summary>
            /// Whether to allow off-site redirects.  If this is not
            /// specified, the `http.followRedirects` configuration setting
            /// will be consulted.
            /// </summary>
            public libgit2.git_remote_redirect_t follow_redirects;
            
            /// <summary>
            /// Extra HTTP headers to use in this connection
            /// </summary>
            public libgit2.git_strarray custom_headers;
        }
        
        /// <summary>
        /// Push network progress notification function
        /// </summary>
        public readonly partial struct git_push_transfer_progress_cb : IEquatable<git_push_transfer_progress_cb>
        {
            public git_push_transfer_progress_cb(delegate*unmanaged[Cdecl]<uint, uint, libgit2.size_t, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<uint, uint, libgit2.size_t, void*, int> Value { get; }
            
            public bool Equals(git_push_transfer_progress_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_push_transfer_progress_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<uint, uint, libgit2.size_t, void*, int>(git_push_transfer_progress_cb from) => from.Value;
            
            public static implicit operator git_push_transfer_progress_cb(delegate*unmanaged[Cdecl]<uint, uint, libgit2.size_t, void*, int> from) => new git_push_transfer_progress_cb(from);
            
            public static bool operator ==(git_push_transfer_progress_cb left, git_push_transfer_progress_cb right) => left.Equals(right);
            
            public static bool operator !=(git_push_transfer_progress_cb left, git_push_transfer_progress_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Callback used to inform of upcoming updates.
        /// </summary>
        /// <param name="updates">an array containing the updates which will be sent
        /// as commands to the destination.</param>
        /// <param name="len">number of elements in `updates`</param>
        /// <param name="payload">Payload provided by the caller</param>
        public readonly partial struct git_push_negotiation : IEquatable<git_push_negotiation>
        {
            public git_push_negotiation(delegate*unmanaged[Cdecl]<libgit2.git_push_update**, libgit2.size_t, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_push_update**, libgit2.size_t, void*, int> Value { get; }
            
            public bool Equals(git_push_negotiation other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_push_negotiation other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_push_update**, libgit2.size_t, void*, int>(git_push_negotiation from) => from.Value;
            
            public static implicit operator git_push_negotiation(delegate*unmanaged[Cdecl]<libgit2.git_push_update**, libgit2.size_t, void*, int> from) => new git_push_negotiation(from);
            
            public static bool operator ==(git_push_negotiation left, git_push_negotiation right) => left.Equals(right);
            
            public static bool operator !=(git_push_negotiation left, git_push_negotiation right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Callback used to inform of the update status from the remote.
        /// </summary>
        /// <param name="refname">refname specifying to the remote ref</param>
        /// <param name="status">status message sent from the remote</param>
        /// <param name="data">data provided by the caller</param>
        /// <returns>@return 0 on success, otherwise an error</returns>
        /// <remarks>
        /// Called for each updated reference on push. If `status` is
        /// not `NULL`, the update was rejected by the remote server
        /// and `status` contains the reason given.
        /// </remarks>
        public readonly partial struct git_push_update_reference_cb : IEquatable<git_push_update_reference_cb>
        {
            public git_push_update_reference_cb(delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> Value { get; }
            
            public bool Equals(git_push_update_reference_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_push_update_reference_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, byte*, void*, int>(git_push_update_reference_cb from) => from.Value;
            
            public static implicit operator git_push_update_reference_cb(delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> from) => new git_push_update_reference_cb(from);
            
            public static bool operator ==(git_push_update_reference_cb left, git_push_update_reference_cb right) => left.Equals(right);
            
            public static bool operator !=(git_push_update_reference_cb left, git_push_update_reference_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Callback invoked immediately before we attempt to connect to the
        /// given url.  Callers may change the URL before the connection by
        /// calling `git_remote_set_instance_url` in the callback.
        /// </summary>
        /// <param name="remote">The remote to be connected</param>
        /// <param name="direction">GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH</param>
        /// <param name="payload">Payload provided by the caller</param>
        /// <returns>@return 0 on success, or an error</returns>
        public readonly partial struct git_remote_ready_cb : IEquatable<git_remote_ready_cb>
        {
            public git_remote_ready_cb(delegate*unmanaged[Cdecl]<libgit2.git_remote, int, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_remote, int, void*, int> Value { get; }
            
            public bool Equals(git_remote_ready_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_remote_ready_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_remote, int, void*, int>(git_remote_ready_cb from) => from.Value;
            
            public static implicit operator git_remote_ready_cb(delegate*unmanaged[Cdecl]<libgit2.git_remote, int, void*, int> from) => new git_remote_ready_cb(from);
            
            public static bool operator ==(git_remote_ready_cb left, git_remote_ready_cb right) => left.Equals(right);
            
            public static bool operator !=(git_remote_ready_cb left, git_remote_ready_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Add a remote with the default fetch refspec to the repository's configuration.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create(out libgit2.git_remote @out, libgit2.git_repository repo, byte* name, byte* url);
        
        /// <summary>
        /// Add a remote with the default fetch refspec to the repository's configuration.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create(out libgit2.git_remote @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Initialize git_remote_create_options structure
        /// </summary>
        /// <param name="opts">The `git_remote_create_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_remote_create_options` with default values. Equivalent to
        /// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_options_init(out libgit2.git_remote_create_options opts, uint version);
        
        /// <summary>
        /// Create a remote, with options.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="url">the remote's url</param>
        /// <param name="opts">the remote creation options</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This function allows more fine-grained control over the remote creation.Passing NULL as the opts argument will result in a detached remote.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_with_opts")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_with_opts(out libgit2.git_remote @out, byte* url, in libgit2.git_remote_create_options opts);
        
        /// <summary>
        /// Create a remote, with options.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="url">the remote's url</param>
        /// <param name="opts">the remote creation options</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This function allows more fine-grained control over the remote creation.Passing NULL as the opts argument will result in a detached remote.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_with_opts")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_with_opts(out libgit2.git_remote @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url, in libgit2.git_remote_create_options opts);
        
        /// <summary>
        /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
        /// configuration.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <param name="fetch">the remote fetch value</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_with_fetchspec")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_with_fetchspec(out libgit2.git_remote @out, libgit2.git_repository repo, byte* name, byte* url, byte* fetch);
        
        /// <summary>
        /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
        /// configuration.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <param name="fetch">the remote fetch value</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_with_fetchspec")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_with_fetchspec(out libgit2.git_remote @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fetch);
        
        /// <summary>
        /// Create an anonymous remote
        /// </summary>
        /// <param name="out">pointer to the new remote objects</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_anonymous")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_anonymous(out libgit2.git_remote @out, libgit2.git_repository repo, byte* url);
        
        /// <summary>
        /// Create an anonymous remote
        /// </summary>
        /// <param name="out">pointer to the new remote objects</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_anonymous")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_anonymous(out libgit2.git_remote @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Create a remote without a connected local repo
        /// </summary>
        /// <param name="out">pointer to the new remote objects</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.Contrasted with git_remote_create_anonymous, a detached remote
        /// will not consider any repo configuration values (such as insteadof url
        /// substitutions).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_detached")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_detached(out libgit2.git_remote @out, byte* url);
        
        /// <summary>
        /// Create a remote without a connected local repo
        /// </summary>
        /// <param name="out">pointer to the new remote objects</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.Contrasted with git_remote_create_anonymous, a detached remote
        /// will not consider any repo configuration values (such as insteadof url
        /// substitutions).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_create_detached")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_create_detached(out libgit2.git_remote @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Get the information for a particular remote
        /// </summary>
        /// <param name="out">pointer to the new remote object</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="name">the remote's name</param>
        /// <returns>@return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_lookup(out libgit2.git_remote @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Get the information for a particular remote
        /// </summary>
        /// <param name="out">pointer to the new remote object</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="name">the remote's name</param>
        /// <returns>@return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_lookup(out libgit2.git_remote @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Create a copy of an existing remote.  All internal strings are also
        /// duplicated. Callbacks are not duplicated.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="source">object to copy</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_remote_free` to free the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_dup(out libgit2.git_remote dest, libgit2.git_remote source);
        
        /// <summary>
        /// Get the remote's repository
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the repository</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_remote_owner(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's name
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the name or NULL for in-memory remotes</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_remote_name(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's name
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the name or NULL for in-memory remotes</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_remote_name_string(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's url
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the url</returns>
        /// <remarks>
        /// If url.*.insteadOf has been configured for this URL, it will
        /// return the modified URL.  If `git_remote_set_instance_pushurl`
        /// has been called for this remote, then that URL will be returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_remote_url(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's url
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the url</returns>
        /// <remarks>
        /// If url.*.insteadOf has been configured for this URL, it will
        /// return the modified URL.  If `git_remote_set_instance_pushurl`
        /// has been called for this remote, then that URL will be returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_remote_url_string(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's url for pushing.
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the url or NULL if no special url for pushing is set</returns>
        /// <remarks>
        /// If url.*.pushInsteadOf has been configured for this URL, it
        /// will return the modified URL.  If `git_remote_set_instance_pushurl`
        /// has been called for this remote, then that URL will be returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_remote_pushurl(libgit2.git_remote remote);
        
        /// <summary>
        /// Get the remote's url for pushing.
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return a pointer to the url or NULL if no special url for pushing is set</returns>
        /// <remarks>
        /// If url.*.pushInsteadOf has been configured for this URL, it
        /// will return the modified URL.  If `git_remote_set_instance_pushurl`
        /// has been called for this remote, then that URL will be returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_remote_pushurl_string(libgit2.git_remote remote);
        
        /// <summary>
        /// Set the remote's url in the configuration
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_url(libgit2.git_repository repo, byte* remote, byte* url);
        
        /// <summary>
        /// Set the remote's url in the configuration
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_url(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Set the remote's url for pushing in the configuration.
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_pushurl(libgit2.git_repository repo, byte* remote, byte* url);
        
        /// <summary>
        /// Set the remote's url for pushing in the configuration.
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_pushurl(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Set the url for this particular url instance.  The URL in the
        /// configuration will be ignored, and will not be changed.
        /// </summary>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_instance_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_instance_url(libgit2.git_remote remote, byte* url);
        
        /// <summary>
        /// Set the url for this particular url instance.  The URL in the
        /// configuration will be ignored, and will not be changed.
        /// </summary>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_instance_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_instance_url(libgit2.git_remote remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Set the push url for this particular url instance.  The URL in the
        /// configuration will be ignored, and will not be changed.
        /// </summary>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_instance_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_instance_pushurl(libgit2.git_remote remote, byte* url);
        
        /// <summary>
        /// Set the push url for this particular url instance.  The URL in the
        /// configuration will be ignored, and will not be changed.
        /// </summary>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>@return 0 or an error value</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_instance_pushurl")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_instance_pushurl(libgit2.git_remote remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Add a fetch refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new fetch refspec</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the fetch list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_add_fetch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_add_fetch(libgit2.git_repository repo, byte* remote, byte* refspec);
        
        /// <summary>
        /// Add a fetch refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new fetch refspec</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the fetch list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_add_fetch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_add_fetch(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refspec);
        
        /// <summary>
        /// Get the remote's list of fetch refspecs
        /// </summary>
        /// <param name="array">pointer to the array in which to store the strings</param>
        /// <param name="remote">the remote to query</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The memory is owned by the user and should be freed with
        /// `git_strarray_free`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_get_fetch_refspecs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_get_fetch_refspecs(ref libgit2.git_strarray array, libgit2.git_remote remote);
        
        /// <summary>
        /// Add a push refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new push refspec</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the push list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_add_push")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_add_push(libgit2.git_repository repo, byte* remote, byte* refspec);
        
        /// <summary>
        /// Add a push refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new push refspec</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the push list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_add_push")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_add_push(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refspec);
        
        /// <summary>
        /// Get the remote's list of push refspecs
        /// </summary>
        /// <param name="array">pointer to the array in which to store the strings</param>
        /// <param name="remote">the remote to query</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The memory is owned by the user and should be freed with
        /// `git_strarray_free`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_get_push_refspecs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_get_push_refspecs(out libgit2.git_strarray array, libgit2.git_remote remote);
        
        /// <summary>
        /// Get the number of refspecs for a remote
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return the amount of refspecs configured in this remote</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_refspec_count")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_remote_refspec_count(libgit2.git_remote remote);
        
        /// <summary>
        /// Get a refspec from the remote
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <param name="n">the refspec to get</param>
        /// <returns>@return the nth refspec</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_get_refspec")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_refspec git_remote_get_refspec(libgit2.git_remote remote, libgit2.size_t n);
        
        /// <summary>
        /// Get the remote repository's reference advertisement list
        /// </summary>
        /// <param name="out">pointer to the array</param>
        /// <param name="size">the number of remote heads</param>
        /// <param name="remote">the remote</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// Get the list of references with which the server responds to a new
        /// connection.The remote (or more exactly its transport) must have connected to
        /// the remote repository. This list is available as soon as the
        /// connection to the remote is initiated and it remains available
        /// after disconnecting.The memory belongs to the remote. The pointer will be valid as long
        /// as a new connection is not initiated, but it is recommended that
        /// you make a copy in order to make use of the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_ls")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_ls(out libgit2.git_remote_head** @out, out libgit2.size_t size, libgit2.git_remote remote);
        
        /// <summary>
        /// Check whether the remote is connected
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return 1 if it's connected, 0 otherwise.</returns>
        /// <remarks>
        /// Check whether the remote's underlying transport is connected to the
        /// remote host.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_connected")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_remote_connected(libgit2.git_remote remote);
        
        /// <summary>
        /// Cancel the operation
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// At certain points in its operation, the network code checks whether
        /// the operation has been cancelled and if so stops the operation.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_stop")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_stop(libgit2.git_remote remote);
        
        /// <summary>
        /// Disconnect from the remote
        /// </summary>
        /// <param name="remote">the remote to disconnect from</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// Close the connection to the remote.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_disconnect")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_disconnect(libgit2.git_remote remote);
        
        /// <summary>
        /// Free the memory associated with a remote
        /// </summary>
        /// <param name="remote">the remote to free</param>
        /// <remarks>
        /// This also disconnects from the remote, if the connection
        /// has not been closed yet (using git_remote_disconnect).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_remote_free(libgit2.git_remote remote);
        
        /// <summary>
        /// Get a list of the configured remotes for a repo
        /// </summary>
        /// <param name="out">a string array which receives the names of the remotes</param>
        /// <param name="repo">the repository to query</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The string array must be freed by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_list")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_list(out libgit2.git_strarray @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Initializes a `git_remote_callbacks` with default values. Equivalent to
        /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
        /// </summary>
        /// <param name="opts">the `git_remote_callbacks` struct to initialize</param>
        /// <param name="version">Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_init_callbacks")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_init_callbacks(out libgit2.git_remote_callbacks opts, uint version);
        
        /// <summary>
        /// Initialize git_fetch_options structure
        /// </summary>
        /// <param name="opts">The `git_fetch_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_fetch_options` with default values. Equivalent to
        /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_fetch_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_fetch_options_init(out libgit2.git_fetch_options opts, uint version);
        
        /// <summary>
        /// Initialize git_push_options structure
        /// </summary>
        /// <param name="opts">The `git_push_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_push_options` with default values. Equivalent to
        /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_push_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_push_options_init(out libgit2.git_push_options opts, uint version);
        
        /// <summary>
        /// Initialize git_remote_connect_options structure.
        /// </summary>
        /// <param name="opts">The `git_remote_connect_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_REMOTE_CONNECT_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_remote_connect_options` with default values.
        /// Equivalent to creating an instance with
        /// `GIT_REMOTE_CONNECT_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_connect_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_connect_options_init(out libgit2.git_remote_connect_options opts, uint version);
        
        /// <summary>
        /// Open a connection to a remote.
        /// </summary>
        /// <param name="remote">the remote to connect to</param>
        /// <param name="direction">GIT_DIRECTION_FETCH if you want to fetch or
        /// GIT_DIRECTION_PUSH if you want to push</param>
        /// <param name="callbacks">the callbacks to use for this connection</param>
        /// <param name="proxy_opts">proxy settings</param>
        /// <param name="custom_headers">extra HTTP headers to use in this connection</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The transport is selected based on the URL; the direction argument
        /// is due to a limitation of the git protocol which starts up a
        /// specific binary which can only do the one or the other.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_connect")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_connect(libgit2.git_remote remote, libgit2.git_direction direction, in libgit2.git_remote_callbacks callbacks, in libgit2.git_proxy_options proxy_opts, in libgit2.git_strarray custom_headers);
        
        /// <summary>
        /// Open a connection to a remote with extended options.
        /// </summary>
        /// <param name="remote">the remote to connect to</param>
        /// <param name="direction">GIT_DIRECTION_FETCH if you want to fetch or
        /// GIT_DIRECTION_PUSH if you want to push</param>
        /// <param name="opts">the remote connection options</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The transport is selected based on the URL; the direction argument
        /// is due to a limitation of the git protocol which starts up a
        /// specific binary which can only do the one or the other.The given options structure will form the defaults for connection
        /// options and callback setup.  Callers may override these defaults
        /// by specifying `git_fetch_options` or `git_push_options` in
        /// subsequent calls.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_connect_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_connect_ext(libgit2.git_remote remote, libgit2.git_direction direction, in libgit2.git_remote_connect_options opts);
        
        /// <summary>
        /// Download and index the packfile.
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <param name="refspecs">the refspecs to use for this negotiation and
        /// download. Use NULL or an empty array to use the base refspecs</param>
        /// <param name="opts">the options to use for this fetch or NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Connect to the remote if it hasn't been done yet, negotiate with
        /// the remote git which objects are missing, download and index the
        /// packfile.The .idx file will be created and both it and the packfile with be
        /// renamed to their final name.If options are specified and this remote is already connected then
        /// the existing remote connection options will be discarded and the
        /// remote will now use the new options.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_download")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_download(libgit2.git_remote remote, in libgit2.git_strarray refspecs, in libgit2.git_fetch_options opts);
        
        /// <summary>
        /// Create a packfile and send it to the server
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <param name="refspecs">the refspecs to use for this negotiation and
        /// upload. Use NULL or an empty array to use the base refspecs</param>
        /// <param name="opts">the options to use for this push</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Connect to the remote if it hasn't been done yet, negotiate with
        /// the remote git which objects are missing, create a packfile with
        /// the missing objects and send it.If options are specified and this remote is already connected then
        /// the existing remote connection options will be discarded and the
        /// remote will now use the new options.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_upload")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_upload(libgit2.git_remote remote, in libgit2.git_strarray refspecs, in libgit2.git_push_options opts);
        
        /// <summary>
        /// Update the tips to the new state.
        /// </summary>
        /// <param name="remote">the remote to update</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If
        /// NULL and fetching, the default is "fetch &lt;name&gt;", where 
        /// &lt;name
        /// &gt; is
        /// the name of the remote (or its url, for in-memory remotes). This
        /// parameter is ignored when pushing.</param>
        /// <param name="callbacks">pointer to the callback structure to use or NULL</param>
        /// <param name="update_fetchhead">whether to write to FETCH_HEAD. Pass 1 to behave like git.</param>
        /// <param name="download_tags">what the behaviour for downloading tags is for this fetch. This is
        /// ignored for push. This must be the same value passed to `git_remote_download()`.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If callbacks are not specified then the callbacks specified to
        /// `git_remote_connect` will be used (if it was called).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_update_tips")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_update_tips(libgit2.git_remote remote, in libgit2.git_remote_callbacks callbacks, int update_fetchhead, libgit2.git_remote_autotag_option_t download_tags, byte* reflog_message);
        
        /// <summary>
        /// Update the tips to the new state.
        /// </summary>
        /// <param name="remote">the remote to update</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If
        /// NULL and fetching, the default is "fetch &lt;name&gt;", where 
        /// &lt;name
        /// &gt; is
        /// the name of the remote (or its url, for in-memory remotes). This
        /// parameter is ignored when pushing.</param>
        /// <param name="callbacks">pointer to the callback structure to use or NULL</param>
        /// <param name="update_fetchhead">whether to write to FETCH_HEAD. Pass 1 to behave like git.</param>
        /// <param name="download_tags">what the behaviour for downloading tags is for this fetch. This is
        /// ignored for push. This must be the same value passed to `git_remote_download()`.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If callbacks are not specified then the callbacks specified to
        /// `git_remote_connect` will be used (if it was called).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_update_tips")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_update_tips(libgit2.git_remote remote, in libgit2.git_remote_callbacks callbacks, int update_fetchhead, libgit2.git_remote_autotag_option_t download_tags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> reflog_message);
        
        /// <summary>
        /// Download new data and update tips.
        /// </summary>
        /// <param name="remote">the remote to fetch from</param>
        /// <param name="refspecs">the refspecs to use for this fetch. Pass NULL or an
        /// empty array to use the base refspecs.</param>
        /// <param name="opts">options to use for this fetch or NULL</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If NULL, the
        /// default is "fetch"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Convenience function to connect to a remote, download the data,
        /// disconnect and update the remote-tracking branches.If options are specified and this remote is already connected then
        /// the existing remote connection options will be discarded and the
        /// remote will now use the new options.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_fetch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_fetch(libgit2.git_remote remote, in libgit2.git_strarray refspecs, in libgit2.git_fetch_options opts, byte* reflog_message);
        
        /// <summary>
        /// Download new data and update tips.
        /// </summary>
        /// <param name="remote">the remote to fetch from</param>
        /// <param name="refspecs">the refspecs to use for this fetch. Pass NULL or an
        /// empty array to use the base refspecs.</param>
        /// <param name="opts">options to use for this fetch or NULL</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If NULL, the
        /// default is "fetch"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Convenience function to connect to a remote, download the data,
        /// disconnect and update the remote-tracking branches.If options are specified and this remote is already connected then
        /// the existing remote connection options will be discarded and the
        /// remote will now use the new options.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_fetch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_fetch(libgit2.git_remote remote, in libgit2.git_strarray refspecs, in libgit2.git_fetch_options opts, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> reflog_message);
        
        /// <summary>
        /// Prune tracking refs that are no longer present on remote.
        /// </summary>
        /// <param name="remote">the remote to prune</param>
        /// <param name="callbacks">callbacks to use for this prune</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If callbacks are not specified then the callbacks specified to
        /// `git_remote_connect` will be used (if it was called).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_prune")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_prune(libgit2.git_remote remote, in libgit2.git_remote_callbacks callbacks);
        
        /// <summary>
        /// Perform a push.
        /// </summary>
        /// <param name="remote">the remote to push to</param>
        /// <param name="refspecs">the refspecs to use for pushing. If NULL or an empty
        /// array, the configured refspecs will be used</param>
        /// <param name="opts">options to use for this push</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// If options are specified and this remote is already connected then
        /// the existing remote connection options will be discarded and the
        /// remote will now use the new options.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_push")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_push(libgit2.git_remote remote, in libgit2.git_strarray refspecs, in libgit2.git_push_options opts);
        
        /// <summary>
        /// Get the statistics structure that is filled in by the fetch operation.
        /// </summary>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_stats")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_indexer_progress* git_remote_stats(libgit2.git_remote remote);
        
        /// <summary>
        /// Retrieve the tag auto-follow setting
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <returns>@return the auto-follow setting</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_autotag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_remote_autotag_option_t git_remote_autotag(libgit2.git_remote remote);
        
        /// <summary>
        /// Set the remote's tag following setting.
        /// </summary>
        /// <param name="repo">the repository in which to make the change</param>
        /// <param name="remote">the name of the remote</param>
        /// <param name="value">the new value to take.</param>
        /// <returns>@return 0, or an error code.</returns>
        /// <remarks>
        /// The change will be made in the configuration. No loaded remotes
        /// will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_autotag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_autotag(libgit2.git_repository repo, byte* remote, libgit2.git_remote_autotag_option_t value);
        
        /// <summary>
        /// Set the remote's tag following setting.
        /// </summary>
        /// <param name="repo">the repository in which to make the change</param>
        /// <param name="remote">the name of the remote</param>
        /// <param name="value">the new value to take.</param>
        /// <returns>@return 0, or an error code.</returns>
        /// <remarks>
        /// The change will be made in the configuration. No loaded remotes
        /// will be affected.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_set_autotag")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_set_autotag(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote, libgit2.git_remote_autotag_option_t value);
        
        /// <summary>
        /// Retrieve the ref-prune setting
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <returns>@return the ref-prune setting</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_prune_refs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_remote_prune_refs(libgit2.git_remote remote);
        
        /// <summary>
        /// Give the remote a new name
        /// </summary>
        /// <param name="problems">non-default refspecs cannot be renamed and will be
        /// stored here for further processing by the caller. Always free this
        /// strarray on successful return.</param>
        /// <param name="repo">the repository in which to rename</param>
        /// <param name="name">the current name of the remote</param>
        /// <param name="new_name">the new name the remote should bear</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote are updated.The new name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.No loaded instances of a the remote with the old name will change
        /// their name or their list of refspecs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_rename(ref libgit2.git_strarray problems, libgit2.git_repository repo, byte* name, byte* new_name);
        
        /// <summary>
        /// Give the remote a new name
        /// </summary>
        /// <param name="problems">non-default refspecs cannot be renamed and will be
        /// stored here for further processing by the caller. Always free this
        /// strarray on successful return.</param>
        /// <param name="repo">the repository in which to rename</param>
        /// <param name="name">the current name of the remote</param>
        /// <param name="new_name">the new name the remote should bear</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote are updated.The new name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.No loaded instances of a the remote with the old name will change
        /// their name or their list of refspecs.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_rename(ref libgit2.git_strarray problems, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> new_name);
        
        /// <summary>
        /// Ensure the remote name is well-formed.
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given remote name</param>
        /// <param name="remote_name">name to be checked.</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_name_is_valid(ref int valid, byte* remote_name);
        
        /// <summary>
        /// Ensure the remote name is well-formed.
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given remote name</param>
        /// <param name="remote_name">name to be checked.</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_name_is_valid(ref int valid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> remote_name);
        
        /// <summary>
        /// Delete an existing persisted remote.
        /// </summary>
        /// <param name="repo">the repository in which to act</param>
        /// <param name="name">the name of the remote to delete</param>
        /// <returns>@return 0 on success, or an error code.</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote will be removed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_delete(libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Delete an existing persisted remote.
        /// </summary>
        /// <param name="repo">the repository in which to act</param>
        /// <param name="name">the name of the remote to delete</param>
        /// <returns>@return 0 on success, or an error code.</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote will be removed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_delete(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Retrieve the name of the remote's default branch
        /// </summary>
        /// <param name="out">the buffer in which to store the reference name</param>
        /// <param name="remote">the remote</param>
        /// <returns>@return 0, GIT_ENOTFOUND if the remote does not have any references
        /// or none of them point to HEAD's commit, or an error message.</returns>
        /// <remarks>
        /// The default branch of a repository is the branch which HEAD points
        /// to. If the remote does not support reporting this information
        /// directly, it performs the guess as git does; that is, if there are
        /// multiple branches which point to the same commit, the first one is
        /// chosen. If the master branch is a candidate, it wins.This function must only be called after connecting.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_remote_default_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_remote_default_branch(out libgit2.git_buf @out, libgit2.git_remote remote);
    }
}
