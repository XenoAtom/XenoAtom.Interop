//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Create a new action signature.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <param name="time">time (in seconds from epoch) when the action happened</param>
        /// <param name="offset">timezone offset (in minutes) for the time</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.Note: angle brackets ('
        /// &lt;
        /// ' and '&gt;') characters are not allowed
        /// to be used in either the `name` or the `email` parameter.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_new(out libgit2.git_signature* @out, byte* name, byte* email, libgit2.git_time_t time, int offset);
        
        /// <summary>
        /// Create a new action signature.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <param name="time">time (in seconds from epoch) when the action happened</param>
        /// <param name="offset">timezone offset (in minutes) for the time</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.Note: angle brackets ('
        /// &lt;
        /// ' and '&gt;') characters are not allowed
        /// to be used in either the `name` or the `email` parameter.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_new(out libgit2.git_signature* @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> email, libgit2.git_time_t time, int offset);
        
        /// <summary>
        /// Create a new action signature with a timestamp of 'now'.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_now")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_now(out libgit2.git_signature* @out, byte* name, byte* email);
        
        /// <summary>
        /// Create a new action signature with a timestamp of 'now'.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_now")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_now(out libgit2.git_signature* @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> email);
        
        /// <summary>
        /// Create a new action signature with default user and now timestamp.
        /// </summary>
        /// <param name="out">new signature</param>
        /// <param name="repo">repository pointer</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if config is missing, or error code</returns>
        /// <remarks>
        /// This looks up the user.name and user.email from the configuration and
        /// uses the current time as the timestamp, and creates a new signature
        /// based on that information.  It will return GIT_ENOTFOUND if either the
        /// user.name or user.email are not set.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_default")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_default(out libgit2.git_signature* @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Create a new signature by parsing the given buffer, which is
        /// expected to be in the format "Real Name &lt;email&gt; timestamp tzoffset",
        /// where `timestamp` is the number of seconds since the Unix epoch and
        /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
        /// of a colon separator).
        /// </summary>
        /// <param name="out">new signature</param>
        /// <param name="buf">signature string</param>
        /// <returns>@return 0 on success, GIT_EINVALID if the signature is not parseable, or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_from_buffer(out libgit2.git_signature* @out, byte* buf);
        
        /// <summary>
        /// Create a new signature by parsing the given buffer, which is
        /// expected to be in the format "Real Name &lt;email&gt; timestamp tzoffset",
        /// where `timestamp` is the number of seconds since the Unix epoch and
        /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
        /// of a colon separator).
        /// </summary>
        /// <param name="out">new signature</param>
        /// <param name="buf">signature string</param>
        /// <returns>@return 0 on success, GIT_EINVALID if the signature is not parseable, or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_from_buffer(out libgit2.git_signature* @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> buf);
        
        /// <summary>
        /// Create a copy of an existing signature.  All internal strings are also
        /// duplicated.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="sig">signature to duplicate</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_signature_dup(ref libgit2.git_signature* dest, in libgit2.git_signature sig);
        
        /// <summary>
        /// Free an existing signature.
        /// </summary>
        /// <param name="sig">signature to free</param>
        /// <remarks>
        /// Because the signature is not an opaque structure, it is legal to free it
        /// manually, but be sure to free the "name" and "email" strings in addition
        /// to the structure itself.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_signature_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_signature_free(libgit2.git_signature* sig);
    }
}
