//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Flags to control the functionality of `git_blob_filter`.
        /// </summary>
        [Flags]
        public enum git_blob_filter_flag_t : int
        {
            /// <summary>
            /// When set, filters will not be applied to binary files.
            /// </summary>
            GIT_BLOB_FILTER_CHECK_FOR_BINARY = unchecked((int)(1  << (int) 0)),
            
            /// <summary>
            /// When set, filters will not load configuration from the
            /// system-wide `gitattributes` in `/etc` (or system equivalent).
            /// </summary>
            GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = unchecked((int)(1  << (int) 1)),
            
            /// <summary>
            /// When set, filters will be loaded from a `.gitattributes` file
            /// in the HEAD commit.
            /// </summary>
            GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD = unchecked((int)(1  << (int) 2)),
            
            /// <summary>
            /// When set, filters will be loaded from a `.gitattributes` file
            /// in the specified commit.
            /// </summary>
            GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT = unchecked((int)(1  << (int) 3)),
        }
        
        /// <summary>
        /// When set, filters will not be applied to binary files.
        /// </summary>
        public const libgit2.git_blob_filter_flag_t GIT_BLOB_FILTER_CHECK_FOR_BINARY = git_blob_filter_flag_t.GIT_BLOB_FILTER_CHECK_FOR_BINARY;
        
        /// <summary>
        /// When set, filters will not load configuration from the
        /// system-wide `gitattributes` in `/etc` (or system equivalent).
        /// </summary>
        public const libgit2.git_blob_filter_flag_t GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = git_blob_filter_flag_t.GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES;
        
        /// <summary>
        /// When set, filters will be loaded from a `.gitattributes` file
        /// in the HEAD commit.
        /// </summary>
        public const libgit2.git_blob_filter_flag_t GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD = git_blob_filter_flag_t.GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD;
        
        /// <summary>
        /// When set, filters will be loaded from a `.gitattributes` file
        /// in the specified commit.
        /// </summary>
        public const libgit2.git_blob_filter_flag_t GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT = git_blob_filter_flag_t.GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT;
        
        /// <summary>
        /// The options used when applying filter options to a file.
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_BLOB_FILTER_OPTIONS_INIT`. Alternatively, you can
        /// use `git_blob_filter_options_init`.
        /// </remarks>
        public partial struct git_blob_filter_options
        {
            public int version;
            
            /// <summary>
            /// Flags to control the filtering process, see `git_blob_filter_flag_t` above
            /// </summary>
            public libgit2.git_blob_filter_flag_t flags;
            
            public void* reserved;
            
            /// <summary>
            /// The commit to load attributes from, when
            /// `GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
            /// </summary>
            public libgit2.git_oid attr_commit_id;
        }
        
        /// <summary>
        /// Lookup a blob object from a repository.
        /// </summary>
        /// <param name="blob">pointer to the looked up blob</param>
        /// <param name="repo">the repo to use when locating the blob.</param>
        /// <param name="id">identity of the blob to locate.</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_lookup(out libgit2.git_blob blob, libgit2.git_repository repo, in libgit2.git_oid id);
        
        /// <summary>
        /// Lookup a blob object from a repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <param name="blob">pointer to the looked up blob</param>
        /// <param name="repo">the repo to use when locating the blob.</param>
        /// <param name="id">identity of the blob to locate.</param>
        /// <param name="len">the length of the short identifier</param>
        /// <returns>@return 0 or an error code</returns>
        /// <seealso cref="git_object_lookup_prefix"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_lookup_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_lookup_prefix(out libgit2.git_blob blob, libgit2.git_repository repo, in libgit2.git_oid id, libgit2.size_t len);
        
        /// <summary>
        /// Close an open blob
        /// </summary>
        /// <param name="blob">the blob to close</param>
        /// <remarks>
        /// This is a wrapper around git_object_free()IMPORTANT:
        /// It *is* necessary to call this method when you stop
        /// using a blob. Failure to do so will cause a memory leak.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_blob_free(libgit2.git_blob blob);
        
        /// <summary>
        /// Get the id of a blob.
        /// </summary>
        /// <param name="blob">a previously loaded blob.</param>
        /// <returns>@return SHA1 hash for this blob.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_blob_id(libgit2.git_blob blob);
        
        /// <summary>
        /// Get the repository that contains the blob.
        /// </summary>
        /// <param name="blob">A previously loaded blob.</param>
        /// <returns>@return Repository that contains this blob.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_blob_owner(libgit2.git_blob blob);
        
        /// <summary>
        /// Get a read-only buffer with the raw content of a blob.
        /// </summary>
        /// <param name="blob">pointer to the blob</param>
        /// <returns>@return the pointer, or NULL on error</returns>
        /// <remarks>
        /// A pointer to the raw content of a blob is returned;
        /// this pointer is owned internally by the object and shall
        /// not be free'd. The pointer may be invalidated at a later
        /// time.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_rawcontent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void* git_blob_rawcontent(libgit2.git_blob blob);
        
        /// <summary>
        /// Get the size in bytes of the contents of a blob
        /// </summary>
        /// <param name="blob">pointer to the blob</param>
        /// <returns>@return size on bytes</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_rawsize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_object_size_t git_blob_rawsize(libgit2.git_blob blob);
        
        /// <summary>
        /// Initialize git_blob_filter_options structure
        /// </summary>
        /// <param name="opts">The `git_blob_filter_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_BLOB_FILTER_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_blob_filter_options` with default values. Equivalent
        /// to creating an instance with `GIT_BLOB_FILTER_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_filter_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_filter_options_init(ref libgit2.git_blob_filter_options opts, uint version);
        
        /// <summary>
        /// Get a buffer with the filtered content of a blob.
        /// </summary>
        /// <param name="out">The git_buf to be filled in</param>
        /// <param name="blob">Pointer to the blob</param>
        /// <param name="as_path">Path used for file attribute lookups, etc.</param>
        /// <param name="opts">Options to use for filtering the blob</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// This applies filters as if the blob was being checked out to the
        /// working directory under the specified filename.  This may apply
        /// CRLF filtering or other types of changes depending on the file
        /// attributes set for the blob and the content detected in it.The output is written into a `git_buf` which the caller must free
        /// when done (via `git_buf_dispose`).If no filters need to be applied, then the `out` buffer will just
        /// be populated with a pointer to the raw content of the blob.  In
        /// that case, be careful to *not* free the blob until done with the
        /// buffer or copy it into memory you own.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_filter")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_filter(out libgit2.git_buf @out, libgit2.git_blob blob, byte* as_path, ref libgit2.git_blob_filter_options opts);
        
        /// <summary>
        /// Get a buffer with the filtered content of a blob.
        /// </summary>
        /// <param name="out">The git_buf to be filled in</param>
        /// <param name="blob">Pointer to the blob</param>
        /// <param name="as_path">Path used for file attribute lookups, etc.</param>
        /// <param name="opts">Options to use for filtering the blob</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// This applies filters as if the blob was being checked out to the
        /// working directory under the specified filename.  This may apply
        /// CRLF filtering or other types of changes depending on the file
        /// attributes set for the blob and the content detected in it.The output is written into a `git_buf` which the caller must free
        /// when done (via `git_buf_dispose`).If no filters need to be applied, then the `out` buffer will just
        /// be populated with a pointer to the raw content of the blob.  In
        /// that case, be careful to *not* free the blob until done with the
        /// buffer or copy it into memory you own.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_filter")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_filter(out libgit2.git_buf @out, libgit2.git_blob blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> as_path, ref libgit2.git_blob_filter_options opts);
        
        /// <summary>
        /// Read a file from the working folder of a repository
        /// and write it to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository cannot be bare</param>
        /// <param name="relative_path">file from which the blob will be created,
        /// relative to the repository's working dir</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_workdir(out libgit2.git_oid id, libgit2.git_repository repo, byte* relative_path);
        
        /// <summary>
        /// Read a file from the working folder of a repository
        /// and write it to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository cannot be bare</param>
        /// <param name="relative_path">file from which the blob will be created,
        /// relative to the repository's working dir</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_workdir(out libgit2.git_oid id, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> relative_path);
        
        /// <summary>
        /// Read a file from the filesystem and write its content
        /// to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository can be bare or not</param>
        /// <param name="path">file from which the blob will be created</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_disk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_disk(out libgit2.git_oid id, libgit2.git_repository repo, byte* path);
        
        /// <summary>
        /// Read a file from the filesystem and write its content
        /// to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository can be bare or not</param>
        /// <param name="path">file from which the blob will be created</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_disk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_disk(out libgit2.git_oid id, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Create a stream to write a new blob into the object db
        /// </summary>
        /// <param name="out">the stream into which to write</param>
        /// <param name="repo">Repository where the blob will be written.
        /// This repository can be bare or not.</param>
        /// <param name="hintpath">If not NULL, will be used to select data filters
        /// to apply onto the content of the blob to be created.</param>
        /// <returns>@return 0 or error code</returns>
        /// <remarks>
        /// This function may need to buffer the data on disk and will in
        /// general not be the right choice if you know the size of the data
        /// to write. If you have data in memory, use
        /// `git_blob_create_from_buffer()`. If you do not, but know the size of
        /// the contents (and don't want/need to perform filtering), use
        /// `git_odb_open_wstream()`.Don't close this stream yourself but pass it to
        /// `git_blob_create_from_stream_commit()` to commit the write to the
        /// object db and get the object id.If the `hintpath` parameter is filled, it will be used to determine
        /// what git filters should be applied to the object before it is written
        /// to the object database.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_stream")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_stream(out libgit2.git_writestream* @out, libgit2.git_repository repo, byte* hintpath);
        
        /// <summary>
        /// Create a stream to write a new blob into the object db
        /// </summary>
        /// <param name="out">the stream into which to write</param>
        /// <param name="repo">Repository where the blob will be written.
        /// This repository can be bare or not.</param>
        /// <param name="hintpath">If not NULL, will be used to select data filters
        /// to apply onto the content of the blob to be created.</param>
        /// <returns>@return 0 or error code</returns>
        /// <remarks>
        /// This function may need to buffer the data on disk and will in
        /// general not be the right choice if you know the size of the data
        /// to write. If you have data in memory, use
        /// `git_blob_create_from_buffer()`. If you do not, but know the size of
        /// the contents (and don't want/need to perform filtering), use
        /// `git_odb_open_wstream()`.Don't close this stream yourself but pass it to
        /// `git_blob_create_from_stream_commit()` to commit the write to the
        /// object db and get the object id.If the `hintpath` parameter is filled, it will be used to determine
        /// what git filters should be applied to the object before it is written
        /// to the object database.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_stream")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_stream(out libgit2.git_writestream* @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> hintpath);
        
        /// <summary>
        /// Close the stream and write the blob to the object db
        /// </summary>
        /// <param name="out">the id of the new blob</param>
        /// <param name="stream">the stream to close</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The stream will be closed and freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_stream_commit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_stream_commit(out libgit2.git_oid @out, ref libgit2.git_writestream stream);
        
        /// <summary>
        /// Write an in-memory buffer to the ODB as a blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written</param>
        /// <param name="buffer">data to be written into the blob</param>
        /// <param name="len">length of the data</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_create_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_blob_create_from_buffer(out libgit2.git_oid id, libgit2.git_repository repo, void* buffer, libgit2.size_t len);
        
        /// <summary>
        /// Determine if the blob content is most certainly binary or not.
        /// </summary>
        /// <param name="blob">The blob which content should be analyzed</param>
        /// <returns>@return 1 if the content of the blob is detected
        /// as binary; 0 otherwise.</returns>
        /// <remarks>
        /// The heuristic used to guess if a file is binary is taken from core git:
        /// Searching for NUL bytes and looking for a reasonable ratio of printable
        /// to non-printable characters among the first 8000 bytes.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_is_binary")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_blob_is_binary(libgit2.git_blob blob);
        
        /// <summary>
        /// Determine if the given content is most certainly binary or not;
        /// this is the same mechanism used by `git_blob_is_binary` but only
        /// looking at raw data.
        /// </summary>
        /// <param name="data">The blob data which content should be analyzed</param>
        /// <param name="len">The length of the data</param>
        /// <returns>@return 1 if the content of the blob is detected
        /// as binary; 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_data_is_binary")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_blob_data_is_binary(byte* data, libgit2.size_t len);
        
        /// <summary>
        /// Create an in-memory copy of a blob. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="out">Pointer to store the copy of the object</param>
        /// <param name="source">Original object to copy</param>
        /// <returns>@return 0.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_blob_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_blob_dup(out libgit2.git_blob @out, libgit2.git_blob source);
    }
}
