//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Callback for git_note_foreach.
        /// </summary>
        /// <remarks>
        /// Receives:
        /// - blob_id: Oid of the blob containing the message
        /// - annotated_object_id: Oid of the git object being annotated
        /// - payload: Payload data passed to `git_note_foreach`
        /// </remarks>
        public readonly partial struct git_note_foreach_cb : IEquatable<git_note_foreach_cb>
        {
            public git_note_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_oid*, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_oid*, void*, int>* Value;
            
            public bool Equals(git_note_foreach_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_note_foreach_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_oid*, void*, int>*(git_note_foreach_cb from) => from.Value;
            
            public static implicit operator git_note_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_oid*, void*, int>* from) => new git_note_foreach_cb(from);
            
            public static bool operator ==(git_note_foreach_cb left, git_note_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_note_foreach_cb left, git_note_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Creates a new iterator for notes
        /// </summary>
        /// <param name="out">pointer to the iterator</param>
        /// <param name="repo">repository where to look up the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional); defaults to
        /// "refs/notes/commits"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The iterator must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_iterator_new(out libgit2.git_iterator @out, libgit2.git_repository repo, byte* notes_ref);
        
        /// <summary>
        /// Creates a new iterator for notes
        /// </summary>
        /// <param name="out">pointer to the iterator</param>
        /// <param name="repo">repository where to look up the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional); defaults to
        /// "refs/notes/commits"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The iterator must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_iterator_new(out libgit2.git_iterator @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string notes_ref);
        
        /// <summary>
        /// Creates a new iterator for notes from a commit
        /// </summary>
        /// <param name="out">pointer to the iterator</param>
        /// <param name="notes_commit">a pointer to the notes commit object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The iterator must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_commit_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_commit_iterator_new(out libgit2.git_iterator @out, libgit2.git_commit notes_commit);
        
        /// <summary>
        /// Frees an git_note_iterator
        /// </summary>
        /// <param name="it">pointer to the iterator</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_note_iterator_free(libgit2.git_iterator it);
        
        /// <summary>
        /// Return the current item (note_id and annotated_id) and advance the iterator
        /// internally to the next value
        /// </summary>
        /// <param name="note_id">id of blob containing the message</param>
        /// <param name="annotated_id">id of the git object being annotated</param>
        /// <param name="it">pointer to the iterator</param>
        /// <returns>@return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
        /// (negative value)</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_next(out libgit2.git_oid note_id, out libgit2.git_oid annotated_id, libgit2.git_iterator it);
        
        /// <summary>
        /// Read the note for an object
        /// </summary>
        /// <param name="out">pointer to the read note; NULL in case of error</param>
        /// <param name="repo">repository where to look up the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional); defaults to
        /// "refs/notes/commits"</param>
        /// <param name="oid">OID of the git object to read the note from</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The note must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_read(out libgit2.git_note @out, libgit2.git_repository repo, byte* notes_ref, in libgit2.git_oid oid);
        
        /// <summary>
        /// Read the note for an object
        /// </summary>
        /// <param name="out">pointer to the read note; NULL in case of error</param>
        /// <param name="repo">repository where to look up the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional); defaults to
        /// "refs/notes/commits"</param>
        /// <param name="oid">OID of the git object to read the note from</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The note must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_read(out libgit2.git_note @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string notes_ref, in libgit2.git_oid oid);
        
        /// <summary>
        /// Read the note for an object from a note commit
        /// </summary>
        /// <param name="out">pointer to the read note; NULL in case of error</param>
        /// <param name="repo">repository where to look up the note</param>
        /// <param name="notes_commit">a pointer to the notes commit object</param>
        /// <param name="oid">OID of the git object to read the note from</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The note must be freed manually by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_commit_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_commit_read(out libgit2.git_note @out, libgit2.git_repository repo, libgit2.git_commit notes_commit, in libgit2.git_oid oid);
        
        /// <summary>
        /// Get the note author
        /// </summary>
        /// <param name="note">the note</param>
        /// <returns>@return the author</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_author")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_note_author(libgit2.git_note note);
        
        /// <summary>
        /// Get the note committer
        /// </summary>
        /// <param name="note">the note</param>
        /// <returns>@return the committer</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_committer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_note_committer(libgit2.git_note note);
        
        /// <summary>
        /// Get the note message
        /// </summary>
        /// <param name="note">the note</param>
        /// <returns>@return the note message</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_note_message(libgit2.git_note note);
        
        /// <summary>
        /// Get the note message
        /// </summary>
        /// <param name="note">the note</param>
        /// <returns>@return the note message</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static partial string git_note_message_string(libgit2.git_note note);
        
        /// <summary>
        /// Get the note object's id
        /// </summary>
        /// <param name="note">the note</param>
        /// <returns>@return the note object's id</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_note_id(libgit2.git_note note);
        
        /// <summary>
        /// Add a note for an object
        /// </summary>
        /// <param name="out">pointer to store the OID (optional); NULL in case of error</param>
        /// <param name="repo">repository where to store the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional);
        /// defaults to "refs/notes/commits"</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to decorate</param>
        /// <param name="note">Content of the note to add for object oid</param>
        /// <param name="force">Overwrite existing note</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_create(out libgit2.git_oid @out, libgit2.git_repository repo, byte* notes_ref, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid, byte* note, int force);
        
        /// <summary>
        /// Add a note for an object
        /// </summary>
        /// <param name="out">pointer to store the OID (optional); NULL in case of error</param>
        /// <param name="repo">repository where to store the note</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional);
        /// defaults to "refs/notes/commits"</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to decorate</param>
        /// <param name="note">Content of the note to add for object oid</param>
        /// <param name="force">Overwrite existing note</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_create(out libgit2.git_oid @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string notes_ref, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string note, int force);
        
        /// <summary>
        /// Add a note for an object from a commit
        /// </summary>
        /// <param name="notes_commit_out">pointer to store the commit (optional);
        /// NULL in case of error</param>
        /// <param name="notes_blob_out">a point to the id of a note blob (optional)</param>
        /// <param name="repo">repository where the note will live</param>
        /// <param name="parent">Pointer to parent note
        /// or NULL if this shall start a new notes tree</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to decorate</param>
        /// <param name="note">Content of the note to add for object oid</param>
        /// <param name="allow_note_overwrite">Overwrite existing note</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function will create a notes commit for a given object,
        /// the commit is a dangling commit, no reference is created.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_commit_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_commit_create(out libgit2.git_oid notes_commit_out, out libgit2.git_oid notes_blob_out, libgit2.git_repository repo, libgit2.git_commit parent, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid, byte* note, int allow_note_overwrite);
        
        /// <summary>
        /// Add a note for an object from a commit
        /// </summary>
        /// <param name="notes_commit_out">pointer to store the commit (optional);
        /// NULL in case of error</param>
        /// <param name="notes_blob_out">a point to the id of a note blob (optional)</param>
        /// <param name="repo">repository where the note will live</param>
        /// <param name="parent">Pointer to parent note
        /// or NULL if this shall start a new notes tree</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to decorate</param>
        /// <param name="note">Content of the note to add for object oid</param>
        /// <param name="allow_note_overwrite">Overwrite existing note</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function will create a notes commit for a given object,
        /// the commit is a dangling commit, no reference is created.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_commit_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_commit_create(out libgit2.git_oid notes_commit_out, out libgit2.git_oid notes_blob_out, libgit2.git_repository repo, libgit2.git_commit parent, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string note, int allow_note_overwrite);
        
        /// <summary>
        /// Remove the note for an object
        /// </summary>
        /// <param name="repo">repository where the note lives</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional);
        /// defaults to "refs/notes/commits"</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to remove the note from</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_remove(libgit2.git_repository repo, byte* notes_ref, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid);
        
        /// <summary>
        /// Remove the note for an object
        /// </summary>
        /// <param name="repo">repository where the note lives</param>
        /// <param name="notes_ref">canonical name of the reference to use (optional);
        /// defaults to "refs/notes/commits"</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to remove the note from</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_remove(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string notes_ref, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid);
        
        /// <summary>
        /// Remove the note for an object
        /// </summary>
        /// <param name="notes_commit_out">pointer to store the new notes commit (optional);
        /// NULL in case of error.
        /// When removing a note a new tree containing all notes
        /// sans the note to be removed is created and a new commit
        /// pointing to that tree is also created.
        /// In the case where the resulting tree is an empty tree
        /// a new commit pointing to this empty tree will be returned.</param>
        /// <param name="repo">repository where the note lives</param>
        /// <param name="notes_commit">a pointer to the notes commit object</param>
        /// <param name="author">signature of the notes commit author</param>
        /// <param name="committer">signature of the notes commit committer</param>
        /// <param name="oid">OID of the git object to remove the note from</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_commit_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_commit_remove(out libgit2.git_oid notes_commit_out, libgit2.git_repository repo, libgit2.git_commit notes_commit, in libgit2.git_signature author, in libgit2.git_signature committer, in libgit2.git_oid oid);
        
        /// <summary>
        /// Free a git_note object
        /// </summary>
        /// <param name="note">git_note object</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_note_free(libgit2.git_note note);
        
        /// <summary>
        /// Get the default notes reference for a repository
        /// </summary>
        /// <param name="out">buffer in which to store the name of the default notes reference</param>
        /// <param name="repo">The Git repository</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_default_ref")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_default_ref(out libgit2.git_buf @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Loop over all the notes within a specified namespace
        /// and issue a callback for each one.
        /// </summary>
        /// <param name="repo">Repository where to find the notes.</param>
        /// <param name="notes_ref">Reference to read from (optional); defaults to
        /// "refs/notes/commits".</param>
        /// <param name="note_cb">Callback to invoke per found annotation.  Return non-zero
        /// to stop looping.</param>
        /// <param name="payload">Extra parameter to callback function.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_foreach(libgit2.git_repository repo, byte* notes_ref, libgit2.git_note_foreach_cb note_cb, void* payload);
        
        /// <summary>
        /// Loop over all the notes within a specified namespace
        /// and issue a callback for each one.
        /// </summary>
        /// <param name="repo">Repository where to find the notes.</param>
        /// <param name="notes_ref">Reference to read from (optional); defaults to
        /// "refs/notes/commits".</param>
        /// <param name="note_cb">Callback to invoke per found annotation.  Return non-zero
        /// to stop looping.</param>
        /// <param name="payload">Extra parameter to callback function.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_note_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_note_foreach(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string notes_ref, libgit2.git_note_foreach_cb note_cb, void* payload);
    }
}
