//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Commit creation callback: used when a function is going to create
        /// commits (for example, in `git_rebase_commit`) to allow callers to
        /// override the commit creation behavior.  For example, users may
        /// wish to sign commits by providing this information to
        /// `git_commit_create_buffer`, signing that buffer, then calling
        /// `git_commit_create_with_signature`.  The resultant commit id
        /// should be set in the `out` object id parameter.
        /// </summary>
        /// <param name="out">pointer that this callback will populate with the object
        /// id of the commit that is created</param>
        /// <param name="author">the author name and time of the commit</param>
        /// <param name="committer">the committer name and time of the commit</param>
        /// <param name="message_encoding">the encoding of the given message, or NULL
        /// to assume UTF8</param>
        /// <param name="message">the commit message</param>
        /// <param name="tree">the tree to be committed</param>
        /// <param name="parent_count">the number of parents for this commit</param>
        /// <param name="parents">the commit parents</param>
        /// <param name="payload">the payload pointer in the rebase options</param>
        /// <returns>@return 0 if this callback has created the commit and populated the out
        /// parameter, GIT_PASSTHROUGH if the callback has not created a
        /// commit and wants the calling function to create the commit as
        /// if no callback had been specified, any other value to stop
        /// and return a failure</returns>
        public readonly partial struct git_commit_create_cb : IEquatable<git_commit_create_cb>
        {
            public git_commit_create_cb(delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_signature*, libgit2.git_signature*, byte*, byte*, libgit2.git_tree, nuint, libgit2.git_commit*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_signature*, libgit2.git_signature*, byte*, byte*, libgit2.git_tree, nuint, libgit2.git_commit*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_commit_create_cb other && Equals(other);
            
            public bool Equals(git_commit_create_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_signature*, libgit2.git_signature*, byte*, byte*, libgit2.git_tree, nuint, libgit2.git_commit*, void*, int> (libgit2.git_commit_create_cb from) => from.Value;
            
            public static implicit operator libgit2.git_commit_create_cb (delegate*unmanaged[Cdecl]<libgit2.git_oid*, libgit2.git_signature*, libgit2.git_signature*, byte*, byte*, libgit2.git_tree, nuint, libgit2.git_commit*, void*, int> from) => new libgit2.git_commit_create_cb(from);
            
            public static bool operator ==(git_commit_create_cb left, git_commit_create_cb right) => left.Equals(right);
            
            public static bool operator !=(git_commit_create_cb left, git_commit_create_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Lookup a commit object from a repository.
        /// </summary>
        /// <param name="commit">pointer to the looked up commit</param>
        /// <param name="repo">the repo to use when locating the commit.</param>
        /// <param name="id">identity of the commit to locate. If the object is
        /// an annotated tag it will be peeled back to the commit.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The returned object should be released with `git_commit_free` when no
        /// longer needed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_lookup(out libgit2.git_commit commit, libgit2.git_repository repo, in libgit2.git_oid id);
        
        /// <summary>
        /// Lookup a commit object from a repository, given a prefix of its
        /// identifier (short id).
        /// </summary>
        /// <param name="commit">pointer to the looked up commit</param>
        /// <param name="repo">the repo to use when locating the commit.</param>
        /// <param name="id">identity of the commit to locate. If the object is
        /// an annotated tag it will be peeled back to the commit.</param>
        /// <param name="len">the length of the short identifier</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The returned object should be released with `git_commit_free` when no
        /// longer needed.
        /// </remarks>
        /// <seealso cref="git_object_lookup_prefix"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_lookup_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_lookup_prefix(out libgit2.git_commit commit, libgit2.git_repository repo, in libgit2.git_oid id, nuint len);
        
        /// <summary>
        /// Close an open commit
        /// </summary>
        /// <param name="commit">the commit to close</param>
        /// <remarks>
        /// This is a wrapper around git_object_free()IMPORTANT:
        /// It *is* necessary to call this method when you stop
        /// using a commit. Failure to do so will cause a memory leak.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_commit_free(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the id of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return object identity for the commit.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_commit_id(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the repository that contains the commit.
        /// </summary>
        /// <param name="commit">A previously loaded commit.</param>
        /// <returns>@return Repository that contains this commit.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_commit_owner(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the encoding for the message of a commit,
        /// as a string representing a standard encoding name.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return NULL, or the encoding</returns>
        /// <remarks>
        /// The encoding may be NULL if the `encoding` header
        /// in the commit is missing; in that case UTF-8 is assumed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message_encoding")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_message_encoding(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the encoding for the message of a commit,
        /// as a string representing a standard encoding name.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return NULL, or the encoding</returns>
        /// <remarks>
        /// The encoding may be NULL if the `encoding` header
        /// in the commit is missing; in that case UTF-8 is assumed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message_encoding")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_message_encoding_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the full message of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the message of a commit</returns>
        /// <remarks>
        /// The returned message will be slightly prettified by removing any
        /// potential leading newlines.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_message(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the full message of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the message of a commit</returns>
        /// <remarks>
        /// The returned message will be slightly prettified by removing any
        /// potential leading newlines.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_message_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the full raw message of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the raw message of a commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message_raw")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_message_raw(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the full raw message of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the raw message of a commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_message_raw")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_message_raw_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the short "summary" of the git commit message.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the summary of a commit or NULL on error</returns>
        /// <remarks>
        /// The returned message is the summary of the commit, comprising the
        /// first paragraph of the message with whitespace trimmed and squashed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_summary")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_summary(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the short "summary" of the git commit message.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the summary of a commit or NULL on error</returns>
        /// <remarks>
        /// The returned message is the summary of the commit, comprising the
        /// first paragraph of the message with whitespace trimmed and squashed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_summary")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_summary_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the long "body" of the git commit message.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the body of a commit or NULL when no the message only
        /// consists of a summary</returns>
        /// <remarks>
        /// The returned message is the body of the commit, comprising
        /// everything but the first paragraph of the message. Leading and
        /// trailing whitespaces are trimmed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_body")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_body(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the long "body" of the git commit message.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the body of a commit or NULL when no the message only
        /// consists of a summary</returns>
        /// <remarks>
        /// The returned message is the body of the commit, comprising
        /// everything but the first paragraph of the message. Leading and
        /// trailing whitespaces are trimmed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_body")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_body_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the commit time (i.e. committer time) of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the time of a commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_time")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_time_t git_commit_time(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return positive or negative timezone offset, in minutes from UTC</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_time_offset")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_commit_time_offset(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the committer of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the committer of a commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_committer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_commit_committer(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the author of a commit.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the author of a commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_author")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_commit_author(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the committer of a commit, using the mailmap to map names and email
        /// addresses to canonical real names and email addresses.
        /// </summary>
        /// <param name="out">a pointer to store the resolved signature.</param>
        /// <param name="commit">a previously loaded commit.</param>
        /// <param name="mailmap">the mailmap to resolve with. (may be NULL)</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free` to free the signature.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_committer_with_mailmap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_committer_with_mailmap(out libgit2.git_signature* @out, libgit2.git_commit commit, libgit2.git_mailmap mailmap);
        
        /// <summary>
        /// Get the author of a commit, using the mailmap to map names and email
        /// addresses to canonical real names and email addresses.
        /// </summary>
        /// <param name="out">a pointer to store the resolved signature.</param>
        /// <param name="commit">a previously loaded commit.</param>
        /// <param name="mailmap">the mailmap to resolve with. (may be NULL)</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free` to free the signature.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_author_with_mailmap")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_author_with_mailmap(out libgit2.git_signature* @out, libgit2.git_commit commit, libgit2.git_mailmap mailmap);
        
        /// <summary>
        /// Get the full raw text of the commit header.
        /// </summary>
        /// <param name="commit">a previously loaded commit</param>
        /// <returns>@return the header text of the commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_raw_header")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_commit_raw_header(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the full raw text of the commit header.
        /// </summary>
        /// <param name="commit">a previously loaded commit</param>
        /// <returns>@return the header text of the commit</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_raw_header")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_commit_raw_header_string(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the tree pointed to by a commit.
        /// </summary>
        /// <param name="tree_out">pointer where to store the tree object</param>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_tree(out libgit2.git_tree tree_out, libgit2.git_commit commit);
        
        /// <summary>
        /// Get the id of the tree pointed to by a commit. This differs from
        /// `git_commit_tree` in that no attempts are made to fetch an object
        /// from the ODB.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return the id of tree pointed to by commit.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_tree_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_commit_tree_id(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the number of parents of this commit
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <returns>@return integer of count of parents</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_parentcount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint git_commit_parentcount(libgit2.git_commit commit);
        
        /// <summary>
        /// Get the specified parent of the commit.
        /// </summary>
        /// <param name="out">Pointer where to store the parent commit</param>
        /// <param name="commit">a previously loaded commit.</param>
        /// <param name="n">the position of the parent (from 0 to `parentcount`)</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_parent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_parent(out libgit2.git_commit @out, libgit2.git_commit commit, uint n);
        
        /// <summary>
        /// Get the oid of a specified parent for a commit. This is different from
        /// `git_commit_parent`, which will attempt to load the parent commit from
        /// the ODB.
        /// </summary>
        /// <param name="commit">a previously loaded commit.</param>
        /// <param name="n">the position of the parent (from 0 to `parentcount`)</param>
        /// <returns>@return the id of the parent, NULL on error.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_parent_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_commit_parent_id(libgit2.git_commit commit, uint n);
        
        /// <summary>
        /// Get the commit object that is the 
        /// &lt;n
        /// &gt;th generation ancestor
        /// of the named commit object, following only the first parents.
        /// The returned commit has to be freed by the caller.
        /// </summary>
        /// <param name="ancestor">Pointer where to store the ancestor commit</param>
        /// <param name="commit">a previously loaded commit.</param>
        /// <param name="n">the requested generation</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND if no matching ancestor exists
        /// or an error code</returns>
        /// <remarks>
        /// Passing `0` as the generation number returns another instance of the
        /// base commit itself.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_nth_gen_ancestor")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_nth_gen_ancestor(ref libgit2.git_commit ancestor, libgit2.git_commit commit, uint n);
        
        /// <summary>
        /// Get an arbitrary header field
        /// </summary>
        /// <param name="out">the buffer to fill; existing content will be
        /// overwritten</param>
        /// <param name="commit">the commit to look in</param>
        /// <param name="field">the header field to return</param>
        /// <returns>@return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
        /// or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_header_field")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_header_field(out libgit2.git_buf @out, libgit2.git_commit commit, byte* field);
        
        /// <summary>
        /// Get an arbitrary header field
        /// </summary>
        /// <param name="out">the buffer to fill; existing content will be
        /// overwritten</param>
        /// <param name="commit">the commit to look in</param>
        /// <param name="field">the header field to return</param>
        /// <returns>@return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
        /// or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_header_field")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_header_field(out libgit2.git_buf @out, libgit2.git_commit commit, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> field);
        
        /// <summary>
        /// Extract the signature from a commit
        /// </summary>
        /// <param name="signature">the signature block; existing content will be
        /// overwritten</param>
        /// <param name="signed_data">signed data; this is the commit contents minus the signature block;
        /// existing content will be overwritten</param>
        /// <param name="repo">the repository in which the commit exists</param>
        /// <param name="commit_id">the commit from which to extract the data</param>
        /// <param name="field">the name of the header field containing the signature
        /// block; pass `NULL` to extract the default 'gpgsig'</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if the id is not for a commit
        /// or the commit does not have a signature.</returns>
        /// <remarks>
        /// If the id is not for a commit, the error class will be
        /// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
        /// error class will be `GIT_ERROR_OBJECT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_extract_signature")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_commit_extract_signature(ref libgit2.git_buf signature, libgit2.git_buf* signed_data, libgit2.git_repository repo, in libgit2.git_oid commit_id, byte* field);
        
        /// <summary>
        /// Extract the signature from a commit
        /// </summary>
        /// <param name="signature">the signature block; existing content will be
        /// overwritten</param>
        /// <param name="signed_data">signed data; this is the commit contents minus the signature block;
        /// existing content will be overwritten</param>
        /// <param name="repo">the repository in which the commit exists</param>
        /// <param name="commit_id">the commit from which to extract the data</param>
        /// <param name="field">the name of the header field containing the signature
        /// block; pass `NULL` to extract the default 'gpgsig'</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if the id is not for a commit
        /// or the commit does not have a signature.</returns>
        /// <remarks>
        /// If the id is not for a commit, the error class will be
        /// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
        /// error class will be `GIT_ERROR_OBJECT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_extract_signature")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_commit_extract_signature(ref libgit2.git_buf signature, libgit2.git_buf* signed_data, libgit2.git_repository repo, in libgit2.git_oid commit_id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> field);
        
        /// <summary>
        /// Create new commit in the repository from a list of `git_object` pointers
        /// </summary>
        /// <param name="id">Pointer in which to store the OID of the newly created commit</param>
        /// <param name="repo">Repository where to store the commit</param>
        /// <param name="update_ref">If not NULL, name of the reference that
        /// will be updated to point to this commit. If the reference
        /// is not direct, it will be resolved to a direct reference.
        /// Use "HEAD" to update the HEAD of the current branch and
        /// make it point to this commit. If the reference doesn't
        /// exist yet, it will be created. If it does exist, the first
        /// parent must be the tip of this branch.</param>
        /// <param name="author">Signature with author and author time of commit</param>
        /// <param name="committer">Signature with committer and * commit time of commit</param>
        /// <param name="message_encoding">The encoding for the message in the
        /// commit, represented with a standard encoding name.
        /// E.g. "UTF-8". If NULL, no encoding header is written and
        /// UTF-8 is assumed.</param>
        /// <param name="message">Full message for this commit</param>
        /// <param name="tree">An instance of a `git_tree` object that will
        /// be used as the tree for the commit. This tree object must
        /// also be owned by the given `repo`.</param>
        /// <param name="parent_count">Number of parents for this commit</param>
        /// <param name="parents">Array of `parent_count` pointers to `git_commit`
        /// objects that will be used as the parents for this commit. This
        /// array may be NULL if `parent_count` is 0 (root commit). All the
        /// given commits must be owned by the `repo`.</param>
        /// <returns>@return 0 or an error code
        /// The created commit will be written to the Object Database and
        /// the given reference will be updated to point to it</returns>
        /// <remarks>
        /// The message will **not** be cleaned up automatically. You can do that
        /// with the `git_message_prettify()` function.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create(out libgit2.git_oid id, libgit2.git_repository repo, byte* update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, byte* message_encoding, byte* message, libgit2.git_tree tree, nuint parent_count, libgit2.git_commit* parents);
        
        /// <summary>
        /// Create new commit in the repository from a list of `git_object` pointers
        /// </summary>
        /// <param name="id">Pointer in which to store the OID of the newly created commit</param>
        /// <param name="repo">Repository where to store the commit</param>
        /// <param name="update_ref">If not NULL, name of the reference that
        /// will be updated to point to this commit. If the reference
        /// is not direct, it will be resolved to a direct reference.
        /// Use "HEAD" to update the HEAD of the current branch and
        /// make it point to this commit. If the reference doesn't
        /// exist yet, it will be created. If it does exist, the first
        /// parent must be the tip of this branch.</param>
        /// <param name="author">Signature with author and author time of commit</param>
        /// <param name="committer">Signature with committer and * commit time of commit</param>
        /// <param name="message_encoding">The encoding for the message in the
        /// commit, represented with a standard encoding name.
        /// E.g. "UTF-8". If NULL, no encoding header is written and
        /// UTF-8 is assumed.</param>
        /// <param name="message">Full message for this commit</param>
        /// <param name="tree">An instance of a `git_tree` object that will
        /// be used as the tree for the commit. This tree object must
        /// also be owned by the given `repo`.</param>
        /// <param name="parent_count">Number of parents for this commit</param>
        /// <param name="parents">Array of `parent_count` pointers to `git_commit`
        /// objects that will be used as the parents for this commit. This
        /// array may be NULL if `parent_count` is 0 (root commit). All the
        /// given commits must be owned by the `repo`.</param>
        /// <returns>@return 0 or an error code
        /// The created commit will be written to the Object Database and
        /// the given reference will be updated to point to it</returns>
        /// <remarks>
        /// The message will **not** be cleaned up automatically. You can do that
        /// with the `git_message_prettify()` function.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create(out libgit2.git_oid id, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message_encoding, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, libgit2.git_tree tree, nuint parent_count, libgit2.git_commit* parents);
        
        /// <summary>
        /// Create new commit in the repository using a variable argument list.
        /// </summary>
        /// <remarks>
        /// The message will **not** be cleaned up automatically. You can do that
        /// with the `git_message_prettify()` function.The parents for the commit are specified as a variable list of pointers
        /// to `const git_commit *`. Note that this is a convenience method which may
        /// not be safe to export for certain languages or compilersAll other parameters remain the same as `git_commit_create()`.
        /// </remarks>
        /// <seealso cref="git_commit_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_v")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_v(out libgit2.git_oid id, libgit2.git_repository repo, byte* update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, byte* message_encoding, byte* message, libgit2.git_tree tree, nuint parent_count);
        
        /// <summary>
        /// Create new commit in the repository using a variable argument list.
        /// </summary>
        /// <remarks>
        /// The message will **not** be cleaned up automatically. You can do that
        /// with the `git_message_prettify()` function.The parents for the commit are specified as a variable list of pointers
        /// to `const git_commit *`. Note that this is a convenience method which may
        /// not be safe to export for certain languages or compilersAll other parameters remain the same as `git_commit_create()`.
        /// </remarks>
        /// <seealso cref="git_commit_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_v")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_v(out libgit2.git_oid id, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message_encoding, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, libgit2.git_tree tree, nuint parent_count);
        
        /// <summary>
        /// Amend an existing commit by replacing only non-NULL values.
        /// </summary>
        /// <remarks>
        /// This creates a new commit that is exactly the same as the old commit,
        /// except that any non-NULL values will be updated.  The new commit has
        /// the same parents as the old commit.The `update_ref` value works as in the regular `git_commit_create()`,
        /// updating the ref to point to the newly rewritten commit.  If you want
        /// to amend a commit that is not currently the tip of the branch and then
        /// rewrite the following commits to reach a ref, pass this as NULL and
        /// update the rest of the commit chain and ref separately.Unlike `git_commit_create()`, the `author`, `committer`, `message`,
        /// `message_encoding`, and `tree` parameters can be NULL in which case this
        /// will use the values from the original `commit_to_amend`.All parameters have the same meanings as in `git_commit_create()`.
        /// </remarks>
        /// <seealso cref="git_commit_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_amend")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_amend(out libgit2.git_oid id, libgit2.git_commit commit_to_amend, byte* update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, byte* message_encoding, byte* message, libgit2.git_tree tree);
        
        /// <summary>
        /// Amend an existing commit by replacing only non-NULL values.
        /// </summary>
        /// <remarks>
        /// This creates a new commit that is exactly the same as the old commit,
        /// except that any non-NULL values will be updated.  The new commit has
        /// the same parents as the old commit.The `update_ref` value works as in the regular `git_commit_create()`,
        /// updating the ref to point to the newly rewritten commit.  If you want
        /// to amend a commit that is not currently the tip of the branch and then
        /// rewrite the following commits to reach a ref, pass this as NULL and
        /// update the rest of the commit chain and ref separately.Unlike `git_commit_create()`, the `author`, `committer`, `message`,
        /// `message_encoding`, and `tree` parameters can be NULL in which case this
        /// will use the values from the original `commit_to_amend`.All parameters have the same meanings as in `git_commit_create()`.
        /// </remarks>
        /// <seealso cref="git_commit_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_amend")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_amend(out libgit2.git_oid id, libgit2.git_commit commit_to_amend, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> update_ref, in libgit2.git_signature author, in libgit2.git_signature committer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message_encoding, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, libgit2.git_tree tree);
        
        /// <summary>
        /// Create a commit and write it into a buffer
        /// </summary>
        /// <param name="out">the buffer into which to write the commit object content</param>
        /// <param name="repo">Repository where the referenced tree and parents live</param>
        /// <param name="author">Signature with author and author time of commit</param>
        /// <param name="committer">Signature with committer and * commit time of commit</param>
        /// <param name="message_encoding">The encoding for the message in the
        /// commit, represented with a standard encoding name.
        /// E.g. "UTF-8". If NULL, no encoding header is written and
        /// UTF-8 is assumed.</param>
        /// <param name="message">Full message for this commit</param>
        /// <param name="tree">An instance of a `git_tree` object that will
        /// be used as the tree for the commit. This tree object must
        /// also be owned by the given `repo`.</param>
        /// <param name="parent_count">Number of parents for this commit</param>
        /// <param name="parents">Array of `parent_count` pointers to `git_commit`
        /// objects that will be used as the parents for this commit. This
        /// array may be NULL if `parent_count` is 0 (root commit). All the
        /// given commits must be owned by the `repo`.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a commit as with `git_commit_create()` but instead of
        /// writing it to the objectdb, write the contents of the object into a
        /// buffer.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_buffer(out libgit2.git_buf @out, libgit2.git_repository repo, in libgit2.git_signature author, in libgit2.git_signature committer, byte* message_encoding, byte* message, libgit2.git_tree tree, nuint parent_count, libgit2.git_commit* parents);
        
        /// <summary>
        /// Create a commit and write it into a buffer
        /// </summary>
        /// <param name="out">the buffer into which to write the commit object content</param>
        /// <param name="repo">Repository where the referenced tree and parents live</param>
        /// <param name="author">Signature with author and author time of commit</param>
        /// <param name="committer">Signature with committer and * commit time of commit</param>
        /// <param name="message_encoding">The encoding for the message in the
        /// commit, represented with a standard encoding name.
        /// E.g. "UTF-8". If NULL, no encoding header is written and
        /// UTF-8 is assumed.</param>
        /// <param name="message">Full message for this commit</param>
        /// <param name="tree">An instance of a `git_tree` object that will
        /// be used as the tree for the commit. This tree object must
        /// also be owned by the given `repo`.</param>
        /// <param name="parent_count">Number of parents for this commit</param>
        /// <param name="parents">Array of `parent_count` pointers to `git_commit`
        /// objects that will be used as the parents for this commit. This
        /// array may be NULL if `parent_count` is 0 (root commit). All the
        /// given commits must be owned by the `repo`.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a commit as with `git_commit_create()` but instead of
        /// writing it to the objectdb, write the contents of the object into a
        /// buffer.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_buffer(out libgit2.git_buf @out, libgit2.git_repository repo, in libgit2.git_signature author, in libgit2.git_signature committer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message_encoding, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, libgit2.git_tree tree, nuint parent_count, libgit2.git_commit* parents);
        
        /// <summary>
        /// Create a commit object from the given buffer and signature
        /// </summary>
        /// <param name="out">the resulting commit id</param>
        /// <param name="repo">the repository to create the commit in.</param>
        /// <param name="commit_content">the content of the unsigned commit object</param>
        /// <param name="signature">the signature to add to the commit. Leave `NULL`
        /// to create a commit without adding a signature field.</param>
        /// <param name="signature_field">which header field should contain this
        /// signature. Leave `NULL` for the default of "gpgsig"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Given the unsigned commit object's contents, its signature and the
        /// header field in which to store the signature, attach the signature
        /// to the commit and write it into the given repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_with_signature")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_with_signature(out libgit2.git_oid @out, libgit2.git_repository repo, byte* commit_content, byte* signature, byte* signature_field);
        
        /// <summary>
        /// Create a commit object from the given buffer and signature
        /// </summary>
        /// <param name="out">the resulting commit id</param>
        /// <param name="repo">the repository to create the commit in.</param>
        /// <param name="commit_content">the content of the unsigned commit object</param>
        /// <param name="signature">the signature to add to the commit. Leave `NULL`
        /// to create a commit without adding a signature field.</param>
        /// <param name="signature_field">which header field should contain this
        /// signature. Leave `NULL` for the default of "gpgsig"</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Given the unsigned commit object's contents, its signature and the
        /// header field in which to store the signature, attach the signature
        /// to the commit and write it into the given repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_create_with_signature")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_commit_create_with_signature(out libgit2.git_oid @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> commit_content, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> signature, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> signature_field);
        
        /// <summary>
        /// Create an in-memory copy of a commit. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="out">Pointer to store the copy of the commit</param>
        /// <param name="source">Original commit to copy</param>
        /// <returns>@return 0</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_commit_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_commit_dup(out libgit2.git_commit @out, libgit2.git_commit source);
    }
}
