//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Return codes for submodule status.
        /// </summary>
        /// <remarks>
        /// A combination of these flags will be returned to describe the status of a
        /// submodule.  Depending on the "ignore" property of the submodule, some of
        /// the flags may never be returned because they indicate changes that are
        /// supposed to be ignored.Submodule info is contained in 4 places: the HEAD tree, the index, config
        /// files (both .git/config and .gitmodules), and the working directory.  Any
        /// or all of those places might be missing information about the submodule
        /// depending on what state the repo is in.  We consider all four places to
        /// build the combination of status flags.There are four values that are not really status, but give basic info
        /// about what sources of submodule data are available.  These will be
        /// returned even if ignore is set to "ALL".* IN_HEAD   - superproject head contains submodule
        /// * IN_INDEX  - superproject index contains submodule
        /// * IN_CONFIG - superproject gitmodules has submodule
        /// * IN_WD     - superproject workdir has submoduleThe following values will be returned so long as ignore is not "ALL".* INDEX_ADDED       - in index, not in head
        /// * INDEX_DELETED     - in head, not in index
        /// * INDEX_MODIFIED    - index and head don't match
        /// * WD_UNINITIALIZED  - workdir contains empty directory
        /// * WD_ADDED          - in workdir, not index
        /// * WD_DELETED        - in index, not workdir
        /// * WD_MODIFIED       - index and workdir head don't matchThe following can only be returned if ignore is "NONE" or "UNTRACKED".* WD_INDEX_MODIFIED - submodule workdir index is dirty
        /// * WD_WD_MODIFIED    - submodule workdir has modified filesLastly, the following will only be returned for ignore "NONE".* WD_UNTRACKED      - wd contains untracked files
        /// </remarks>
        [Flags]
        public enum git_submodule_status_t : uint
        {
            GIT_SUBMODULE_STATUS_IN_HEAD = unchecked((uint)1),
            
            GIT_SUBMODULE_STATUS_IN_INDEX = unchecked((uint)2),
            
            GIT_SUBMODULE_STATUS_IN_CONFIG = unchecked((uint)4),
            
            GIT_SUBMODULE_STATUS_IN_WD = unchecked((uint)8),
            
            GIT_SUBMODULE_STATUS_INDEX_ADDED = unchecked((uint)16),
            
            GIT_SUBMODULE_STATUS_INDEX_DELETED = unchecked((uint)32),
            
            GIT_SUBMODULE_STATUS_INDEX_MODIFIED = unchecked((uint)64),
            
            GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = unchecked((uint)128),
            
            GIT_SUBMODULE_STATUS_WD_ADDED = unchecked((uint)256),
            
            GIT_SUBMODULE_STATUS_WD_DELETED = unchecked((uint)512),
            
            GIT_SUBMODULE_STATUS_WD_MODIFIED = unchecked((uint)1024),
            
            GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = unchecked((uint)2048),
            
            GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = unchecked((uint)4096),
            
            GIT_SUBMODULE_STATUS_WD_UNTRACKED = unchecked((uint)8192),
        }
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_IN_HEAD = git_submodule_status_t.GIT_SUBMODULE_STATUS_IN_HEAD;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_IN_INDEX = git_submodule_status_t.GIT_SUBMODULE_STATUS_IN_INDEX;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_IN_CONFIG = git_submodule_status_t.GIT_SUBMODULE_STATUS_IN_CONFIG;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_IN_WD = git_submodule_status_t.GIT_SUBMODULE_STATUS_IN_WD;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_INDEX_ADDED = git_submodule_status_t.GIT_SUBMODULE_STATUS_INDEX_ADDED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_INDEX_DELETED = git_submodule_status_t.GIT_SUBMODULE_STATUS_INDEX_DELETED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_INDEX_MODIFIED = git_submodule_status_t.GIT_SUBMODULE_STATUS_INDEX_MODIFIED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_ADDED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_ADDED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_DELETED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_DELETED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_MODIFIED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_MODIFIED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;
        
        public const libgit2.git_submodule_status_t GIT_SUBMODULE_STATUS_WD_UNTRACKED = git_submodule_status_t.GIT_SUBMODULE_STATUS_WD_UNTRACKED;
        
        /// <summary>
        /// Submodule update options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_submodule_update_options_init`.
        /// </remarks>
        public partial struct git_submodule_update_options
        {
            public uint version;
            
            /// <summary>
            /// These options are passed to the checkout step. To disable
            /// checkout, set the `checkout_strategy` to
            /// `GIT_CHECKOUT_NONE`. Generally you will want the use
            /// GIT_CHECKOUT_SAFE to update files in the working
            /// directory.
            /// </summary>
            public libgit2.git_checkout_options checkout_opts;
            
            /// <summary>
            /// Options which control the fetch, including callbacks.
            /// </summary>
            /// <remarks>
            /// The callbacks to use for reporting fetch progress, and for acquiring
            /// credentials in the event they are needed.
            /// </remarks>
            public libgit2.git_fetch_options fetch_opts;
            
            /// <summary>
            /// Allow fetching from the submodule's default remote if the target
            /// commit isn't found. Enabled by default.
            /// </summary>
            public int allow_fetch;
        }
        
        /// <summary>
        /// Function pointer to receive each submodule
        /// </summary>
        /// <param name="sm">git_submodule currently being visited</param>
        /// <param name="name">name of the submodule</param>
        /// <param name="payload">value you passed to the foreach function as payload</param>
        /// <returns>@return 0 on success or error code</returns>
        public readonly partial struct git_submodule_cb : IEquatable<libgit2.git_submodule_cb>
        {
            public git_submodule_cb(delegate*unmanaged[Cdecl]<libgit2.git_submodule, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_submodule, byte*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_submodule_cb other && Equals(other);
            
            public bool Equals(git_submodule_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_submodule, byte*, void*, int> (libgit2.git_submodule_cb from) => from.Value;
            
            public static implicit operator libgit2.git_submodule_cb (delegate*unmanaged[Cdecl]<libgit2.git_submodule, byte*, void*, int> from) => new libgit2.git_submodule_cb(from);
            
            public static bool operator ==(git_submodule_cb left, git_submodule_cb right) => left.Equals(right);
            
            public static bool operator !=(git_submodule_cb left, git_submodule_cb right) => !left.Equals(right);
        }
        
        public const uint GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// Initialize git_submodule_update_options structure
        /// </summary>
        /// <param name="opts">The `git_submodule_update_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_SUBMODULE_UPDATE_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_submodule_update_options` with default values. Equivalent to
        /// creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_update_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_update_options_init(out libgit2.git_submodule_update_options opts, uint version);
        
        /// <summary>
        /// Update a submodule. This will clone a missing submodule and
        /// checkout the subrepository to the commit specified in the index of
        /// the containing repository. If the submodule repository doesn't contain
        /// the target commit (e.g. because fetchRecurseSubmodules isn't set), then
        /// the submodule is fetched using the fetch options supplied in options.
        /// </summary>
        /// <param name="submodule">Submodule object</param>
        /// <param name="init">If the submodule is not initialized, setting this flag to true
        /// will initialize the submodule before updating. Otherwise, this will
        /// return an error if attempting to update an uninitialized repository.
        /// but setting this to true forces them to be updated.</param>
        /// <param name="options">configuration options for the update.  If NULL, the
        /// function works as though GIT_SUBMODULE_UPDATE_OPTIONS_INIT was passed.</param>
        /// <returns>@return 0 on success, any non-zero return value from a callback
        /// function, or a negative value to indicate an error (use
        /// `git_error_last` for a detailed error message).</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_update")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_update(libgit2.git_submodule submodule, int init, in libgit2.git_submodule_update_options options);
        
        /// <summary>
        /// Lookup submodule information by name or path.
        /// </summary>
        /// <param name="out">Output ptr to submodule; pass NULL to just get return code</param>
        /// <param name="repo">The parent repository</param>
        /// <param name="name">The name of or path to the submodule; trailing slashes okay</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if submodule does not exist,
        /// GIT_EEXISTS if a repository is found in working directory only,
        /// -1 on other errors.</returns>
        /// <remarks>
        /// Given either the submodule name or path (they are usually the same), this
        /// returns a structure describing the submodule.There are two expected error scenarios:- The submodule is not mentioned in the HEAD, the index, and the config,
        /// but does "exist" in the working directory (i.e. there is a subdirectory
        /// that appears to be a Git repository).  In this case, this function
        /// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
        /// state where a git_submodule can be instantiated.
        /// - The submodule is not mentioned in the HEAD, index, or config and the
        /// working directory doesn't contain a value git repo at that path.
        /// There may or may not be anything else at that path, but nothing that
        /// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.You must call `git_submodule_free` when done with the submodule.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_lookup(out libgit2.git_submodule @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Lookup submodule information by name or path.
        /// </summary>
        /// <param name="out">Output ptr to submodule; pass NULL to just get return code</param>
        /// <param name="repo">The parent repository</param>
        /// <param name="name">The name of or path to the submodule; trailing slashes okay</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if submodule does not exist,
        /// GIT_EEXISTS if a repository is found in working directory only,
        /// -1 on other errors.</returns>
        /// <remarks>
        /// Given either the submodule name or path (they are usually the same), this
        /// returns a structure describing the submodule.There are two expected error scenarios:- The submodule is not mentioned in the HEAD, the index, and the config,
        /// but does "exist" in the working directory (i.e. there is a subdirectory
        /// that appears to be a Git repository).  In this case, this function
        /// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
        /// state where a git_submodule can be instantiated.
        /// - The submodule is not mentioned in the HEAD, index, or config and the
        /// working directory doesn't contain a value git repo at that path.
        /// There may or may not be anything else at that path, but nothing that
        /// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.You must call `git_submodule_free` when done with the submodule.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_lookup(out libgit2.git_submodule @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Create an in-memory copy of a submodule. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="out">Pointer to store the copy of the submodule.</param>
        /// <param name="source">Original submodule to copy.</param>
        /// <returns>@return 0</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_submodule_dup(out libgit2.git_submodule @out, libgit2.git_submodule source);
        
        /// <summary>
        /// Release a submodule
        /// </summary>
        /// <param name="submodule">Submodule object</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_submodule_free(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Iterate over all tracked submodules of a repository.
        /// </summary>
        /// <param name="repo">The repository</param>
        /// <param name="callback">Function to be called with the name of each submodule.
        /// Return a non-zero value to terminate the iteration.</param>
        /// <param name="payload">Extra data to pass to callback</param>
        /// <returns>@return 0 on success, -1 on error, or non-zero return value of callback</returns>
        /// <remarks>
        /// See the note on `git_submodule` above.  This iterates over the tracked
        /// submodules as described therein.If you are concerned about items in the working directory that look like
        /// submodules but are not tracked, the diff API will generate a diff record
        /// for workdir items that look like submodules but are not tracked, showing
        /// them as added in the workdir.  Also, the status API will treat the entire
        /// subdirectory of a contained git repo as a single GIT_STATUS_WT_NEW item.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_foreach(libgit2.git_repository repo, libgit2.git_submodule_cb callback, void* payload);
        
        /// <summary>
        /// Set up a new git submodule for checkout.
        /// </summary>
        /// <param name="out">The newly created submodule ready to open for clone</param>
        /// <param name="repo">The repository in which you want to create the submodule</param>
        /// <param name="url">URL for the submodule's remote</param>
        /// <param name="path">Path at which the submodule should be created</param>
        /// <param name="use_gitlink">Should workdir contain a gitlink to the repo in
        /// .git/modules vs. repo directly in workdir.</param>
        /// <returns>@return 0 on success, GIT_EEXISTS if submodule already exists,
        /// -1 on other errors.</returns>
        /// <remarks>
        /// This does "git submodule add" up to the fetch and checkout of the
        /// submodule contents.  It preps a new submodule, creates an entry in
        /// .gitmodules and creates an empty initialized repository either at the
        /// given path in the working directory or in .git/modules with a gitlink
        /// from the working directory to the new repo.To fully emulate "git submodule add" call this function, then open the
        /// submodule repo and perform the clone step as needed (if you don't need
        /// anything custom see `git_submodule_add_clone()`). Lastly, call
        /// `git_submodule_add_finalize()` to wrap up adding the new submodule and
        /// .gitmodules to the index to be ready to commit.You must call `git_submodule_free` on the submodule object when done.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_add_setup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_add_setup(out libgit2.git_submodule @out, libgit2.git_repository repo, byte* url, byte* path, int use_gitlink);
        
        /// <summary>
        /// Set up a new git submodule for checkout.
        /// </summary>
        /// <param name="out">The newly created submodule ready to open for clone</param>
        /// <param name="repo">The repository in which you want to create the submodule</param>
        /// <param name="url">URL for the submodule's remote</param>
        /// <param name="path">Path at which the submodule should be created</param>
        /// <param name="use_gitlink">Should workdir contain a gitlink to the repo in
        /// .git/modules vs. repo directly in workdir.</param>
        /// <returns>@return 0 on success, GIT_EEXISTS if submodule already exists,
        /// -1 on other errors.</returns>
        /// <remarks>
        /// This does "git submodule add" up to the fetch and checkout of the
        /// submodule contents.  It preps a new submodule, creates an entry in
        /// .gitmodules and creates an empty initialized repository either at the
        /// given path in the working directory or in .git/modules with a gitlink
        /// from the working directory to the new repo.To fully emulate "git submodule add" call this function, then open the
        /// submodule repo and perform the clone step as needed (if you don't need
        /// anything custom see `git_submodule_add_clone()`). Lastly, call
        /// `git_submodule_add_finalize()` to wrap up adding the new submodule and
        /// .gitmodules to the index to be ready to commit.You must call `git_submodule_free` on the submodule object when done.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_add_setup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_add_setup(out libgit2.git_submodule @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, int use_gitlink);
        
        /// <summary>
        /// Perform the clone step for a newly created submodule.
        /// </summary>
        /// <param name="out">The newly created repository object. Optional.</param>
        /// <param name="submodule">The submodule currently waiting for its clone.</param>
        /// <param name="opts">The options to use.</param>
        /// <returns>@return 0 on success, -1 on other errors (see git_clone).</returns>
        /// <remarks>
        /// This performs the necessary `git_clone` to setup a newly-created submodule.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_clone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_clone(out libgit2.git_repository @out, libgit2.git_submodule submodule, in libgit2.git_submodule_update_options opts);
        
        /// <summary>
        /// Resolve the setup of a new git submodule.
        /// </summary>
        /// <param name="submodule">The submodule to finish adding.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This should be called on a submodule once you have called add setup
        /// and done the clone of the submodule.  This adds the .gitmodules file
        /// and the newly cloned submodule to the index to be ready to be committed
        /// (but doesn't actually do the commit).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_add_finalize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_add_finalize(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Add current submodule HEAD commit to index of superproject.
        /// </summary>
        /// <param name="submodule">The submodule to add to the index</param>
        /// <param name="write_index">Boolean if this should immediately write the index
        /// file.  If you pass this as false, you will have to get the
        /// git_index and explicitly call `git_index_write()` on it to
        /// save the change.</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_add_to_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_add_to_index(libgit2.git_submodule submodule, int write_index);
        
        /// <summary>
        /// Get the containing repository for a submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to `git_repository`</returns>
        /// <remarks>
        /// This returns a pointer to the repository that contains the submodule.
        /// This is a just a reference to the repository that was passed to the
        /// original `git_submodule_lookup()` call, so if that repository has been
        /// freed, then this may be a dangling reference.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_submodule_owner(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the name of submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule name</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_submodule_name_(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the name of submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule name</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_submodule_name(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the path to the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule path</returns>
        /// <remarks>
        /// The path is almost always the same as the submodule name, but the
        /// two are actually not required to match.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_submodule_path_(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the path to the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule path</returns>
        /// <remarks>
        /// The path is almost always the same as the submodule name, but the
        /// two are actually not required to match.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_submodule_path(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the URL for the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule url</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_submodule_url_(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the URL for the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule url</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_submodule_url(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Resolve a submodule url relative to the given repository.
        /// </summary>
        /// <param name="out">buffer to store the absolute submodule url in</param>
        /// <param name="repo">Pointer to repository object</param>
        /// <param name="url">Relative url</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_resolve_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_resolve_url(out libgit2.git_buf @out, libgit2.git_repository repo, byte* url);
        
        /// <summary>
        /// Resolve a submodule url relative to the given repository.
        /// </summary>
        /// <param name="out">buffer to store the absolute submodule url in</param>
        /// <param name="repo">Pointer to repository object</param>
        /// <param name="url">Relative url</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_resolve_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_resolve_url(out libgit2.git_buf @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Get the branch for the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule branch</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_submodule_branch_(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the branch for the submodule.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to the submodule branch</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_submodule_branch(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Set the branch for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="branch">Branch that should be used for the submodule</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// After calling this, you may wish to call `git_submodule_sync()` to
        /// write the changes to the checked out submodule repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_branch(libgit2.git_repository repo, byte* name, byte* branch);
        
        /// <summary>
        /// Set the branch for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="branch">Branch that should be used for the submodule</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// After calling this, you may wish to call `git_submodule_sync()` to
        /// write the changes to the checked out submodule repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_branch")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_branch(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> branch);
        
        /// <summary>
        /// Set the URL for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="url">URL that should be used for the submodule</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// After calling this, you may wish to call `git_submodule_sync()` to
        /// write the changes to the checked out submodule repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_url(libgit2.git_repository repo, byte* name, byte* url);
        
        /// <summary>
        /// Set the URL for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="url">URL that should be used for the submodule</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// After calling this, you may wish to call `git_submodule_sync()` to
        /// write the changes to the checked out submodule repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_url")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_url(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);
        
        /// <summary>
        /// Get the OID for the submodule in the index.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to git_oid or NULL if submodule is not in index.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_index_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_submodule_index_id(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the OID for the submodule in the current HEAD tree.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to git_oid or NULL if submodule is not in the HEAD.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_head_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_submodule_head_id(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the OID for the submodule in the current working directory.
        /// </summary>
        /// <param name="submodule">Pointer to submodule object</param>
        /// <returns>@return Pointer to git_oid or NULL if submodule is not checked out.</returns>
        /// <remarks>
        /// This returns the OID that corresponds to looking up 'HEAD' in the checked
        /// out submodule.  If there are pending changes in the index or anything
        /// else, this won't notice that.  You should call `git_submodule_status()`
        /// for a more complete picture about the state of the working directory.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_wd_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_submodule_wd_id(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Get the ignore rule that will be used for the submodule.
        /// </summary>
        /// <param name="submodule">The submodule to check</param>
        /// <returns>@return The current git_submodule_ignore_t valyue what will be used for
        /// this submodule.</returns>
        /// <remarks>
        /// These values control the behavior of `git_submodule_status()` for this
        /// submodule.  There are four ignore values:- **GIT_SUBMODULE_IGNORE_NONE** will consider any change to the contents
        /// of the submodule from a clean checkout to be dirty, including the
        /// addition of untracked files.  This is the default if unspecified.
        /// - **GIT_SUBMODULE_IGNORE_UNTRACKED** examines the contents of the
        /// working tree (i.e. call `git_status_foreach()` on the submodule) but
        /// UNTRACKED files will not count as making the submodule dirty.
        /// - **GIT_SUBMODULE_IGNORE_DIRTY** means to only check if the HEAD of the
        /// submodule has moved for status.  This is fast since it does not need to
        /// scan the working tree of the submodule at all.
        /// - **GIT_SUBMODULE_IGNORE_ALL** means not to open the submodule repo.
        /// The working directory will be consider clean so long as there is a
        /// checked out version present.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_ignore")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_submodule_ignore_t git_submodule_ignore(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Set the ignore rule for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submdule</param>
        /// <param name="ignore">The new value for the ignore rule</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This does not affect any currently-loaded instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_ignore")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_ignore(libgit2.git_repository repo, byte* name, libgit2.git_submodule_ignore_t ignore);
        
        /// <summary>
        /// Set the ignore rule for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submdule</param>
        /// <param name="ignore">The new value for the ignore rule</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This does not affect any currently-loaded instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_ignore")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_ignore(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, libgit2.git_submodule_ignore_t ignore);
        
        /// <summary>
        /// Get the update rule that will be used for the submodule.
        /// </summary>
        /// <param name="submodule">The submodule to check</param>
        /// <returns>@return The current git_submodule_update_t value that will be used
        /// for this submodule.</returns>
        /// <remarks>
        /// This value controls the behavior of the `git submodule update` command.
        /// There are four useful values documented with `git_submodule_update_t`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_update_strategy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_submodule_update_t git_submodule_update_strategy(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Set the update rule for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="update">The new value to use</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This setting won't affect any existing instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_update")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_update(libgit2.git_repository repo, byte* name, libgit2.git_submodule_update_t update);
        
        /// <summary>
        /// Set the update rule for the submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the name of the submodule to configure</param>
        /// <param name="update">The new value to use</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This setting won't affect any existing instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_update")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_set_update(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, libgit2.git_submodule_update_t update);
        
        /// <summary>
        /// Read the fetchRecurseSubmodules rule for a submodule.
        /// </summary>
        /// <returns>@return 0 if fetchRecurseSubmodules is false, 1 if true</returns>
        /// <remarks>
        /// This accesses the submodule.
        /// &lt;name
        /// &gt;.fetchRecurseSubmodules value for
        /// the submodule that controls fetching behavior for the submodule.Note that at this time, libgit2 does not honor this setting and the
        /// fetch functionality current ignores submodules.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_fetch_recurse_submodules")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_submodule_recurse_t git_submodule_fetch_recurse_submodules(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Set the fetchRecurseSubmodules rule for a submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the submodule to configure</param>
        /// <param name="fetch_recurse_submodules">Boolean value</param>
        /// <returns>@return old value for fetchRecurseSubmodules</returns>
        /// <remarks>
        /// This setting won't affect any existing instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_fetch_recurse_submodules")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_submodule_set_fetch_recurse_submodules(libgit2.git_repository repo, byte* name, libgit2.git_submodule_recurse_t fetch_recurse_submodules);
        
        /// <summary>
        /// Set the fetchRecurseSubmodules rule for a submodule in the configuration
        /// </summary>
        /// <param name="repo">the repository to affect</param>
        /// <param name="name">the submodule to configure</param>
        /// <param name="fetch_recurse_submodules">Boolean value</param>
        /// <returns>@return old value for fetchRecurseSubmodules</returns>
        /// <remarks>
        /// This setting won't affect any existing instances.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_set_fetch_recurse_submodules")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_submodule_set_fetch_recurse_submodules(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, libgit2.git_submodule_recurse_t fetch_recurse_submodules);
        
        /// <summary>
        /// Copy submodule info into ".git/config" file.
        /// </summary>
        /// <param name="submodule">The submodule to write into the superproject config</param>
        /// <param name="overwrite">By default, existing entries will not be overwritten,
        /// but setting this to true forces them to be updated.</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure.</returns>
        /// <remarks>
        /// Just like "git submodule init", this copies information about the
        /// submodule into ".git/config".  You can use the accessor functions
        /// above to alter the in-memory git_submodule object and control what
        /// is written to the config, overriding what is in .gitmodules.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_init(libgit2.git_submodule submodule, int overwrite);
        
        /// <summary>
        /// Set up the subrepository for a submodule in preparation for clone.
        /// </summary>
        /// <param name="out">Output pointer to the created git repository.</param>
        /// <param name="sm">The submodule to create a new subrepository from.</param>
        /// <param name="use_gitlink">Should the workdir contain a gitlink to
        /// the repo in .git/modules vs. repo directly in workdir.</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure.</returns>
        /// <remarks>
        /// This function can be called to init and set up a submodule
        /// repository from a submodule in preparation to clone it from
        /// its remote.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_repo_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_repo_init(out libgit2.git_repository @out, libgit2.git_submodule sm, int use_gitlink);
        
        /// <summary>
        /// Copy submodule remote info into submodule repo.
        /// </summary>
        /// <param name="submodule">The submodule to copy.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This copies the information about the submodules URL into the checked out
        /// submodule config, acting like "git submodule sync".  This is useful if
        /// you have altered the URL for the submodule (or it has been altered by a
        /// fetch of upstream changes) and you need to update your local repo.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_sync")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_sync(libgit2.git_submodule submodule);
        
        /// <summary>
        /// Open the repository for a submodule.
        /// </summary>
        /// <param name="repo">Pointer to the submodule repo which was opened</param>
        /// <param name="submodule">Submodule to be opened</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 if submodule repo could not be opened.</returns>
        /// <remarks>
        /// This is a newly opened repository object.  The caller is responsible for
        /// calling `git_repository_free()` on it when done.  Multiple calls to this
        /// function will return distinct `git_repository` objects.  This will only
        /// work if the submodule is checked out into the working directory.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_submodule_open(out libgit2.git_repository repo, libgit2.git_submodule submodule);
        
        /// <summary>
        /// Reread submodule info from config, index, and HEAD.
        /// </summary>
        /// <param name="submodule">The submodule to reload</param>
        /// <param name="force">Force reload even if the data doesn't seem out of date</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// Call this to reread cached submodule information for this submodule if
        /// you have reason to believe that it has changed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_reload")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_reload(libgit2.git_submodule submodule, int force);
        
        /// <summary>
        /// Get the status for a submodule.
        /// </summary>
        /// <param name="status">Combination of `GIT_SUBMODULE_STATUS` flags</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="name">name of the submodule</param>
        /// <param name="ignore">the ignore rules to follow</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This looks at a submodule and tries to determine the status.  It
        /// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
        /// How deeply it examines the working directory to do this will depend
        /// on the `git_submodule_ignore_t` value for the submodule.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_status")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_status(out uint status, libgit2.git_repository repo, byte* name, libgit2.git_submodule_ignore_t ignore);
        
        /// <summary>
        /// Get the status for a submodule.
        /// </summary>
        /// <param name="status">Combination of `GIT_SUBMODULE_STATUS` flags</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="name">name of the submodule</param>
        /// <param name="ignore">the ignore rules to follow</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This looks at a submodule and tries to determine the status.  It
        /// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
        /// How deeply it examines the working directory to do this will depend
        /// on the `git_submodule_ignore_t` value for the submodule.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_status")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_status(out uint status, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, libgit2.git_submodule_ignore_t ignore);
        
        /// <summary>
        /// Get the locations of submodule information.
        /// </summary>
        /// <param name="location_status">Combination of first four `GIT_SUBMODULE_STATUS` flags</param>
        /// <param name="submodule">Submodule for which to get status</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on error</returns>
        /// <remarks>
        /// This is a bit like a very lightweight version of `git_submodule_status`.
        /// It just returns a made of the first four submodule status values (i.e.
        /// the ones like GIT_SUBMODULE_STATUS_IN_HEAD, etc) that tell you where the
        /// submodule data comes from (i.e. the HEAD commit, gitmodules file, etc.).
        /// This can be useful if you want to know if the submodule is present in the
        /// working directory at this point in time, etc.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_submodule_location")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_submodule_location(out uint location_status, libgit2.git_submodule submodule);
    }
}
