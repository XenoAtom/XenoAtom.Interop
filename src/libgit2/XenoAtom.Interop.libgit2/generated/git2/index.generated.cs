//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Flags for index entries
        /// </summary>
        public enum git_index_entry_flag_t : uint
        {
            GIT_INDEX_ENTRY_EXTENDED = unchecked((uint)16384),
            
            GIT_INDEX_ENTRY_VALID = unchecked((uint)32768),
        }
        
        public const libgit2.git_index_entry_flag_t GIT_INDEX_ENTRY_EXTENDED = git_index_entry_flag_t.GIT_INDEX_ENTRY_EXTENDED;
        
        public const libgit2.git_index_entry_flag_t GIT_INDEX_ENTRY_VALID = git_index_entry_flag_t.GIT_INDEX_ENTRY_VALID;
        
        /// <summary>
        /// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
        /// </summary>
        /// <remarks>
        /// In memory, the `flags_extended` fields are divided into two parts: the
        /// fields that are read from and written to disk, and other fields that
        /// in-memory only and used by libgit2.  Only the flags in
        /// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.Thee first three bitmasks match the three fields in the
        /// `git_index_entry` `flags_extended` value that belong on disk.  You
        /// can use them to interpret the data in the `flags_extended`.The rest of the bitmasks match the other fields in the `git_index_entry`
        /// `flags_extended` value that are only used in-memory by libgit2.
        /// You can use them to interpret the data in the `flags_extended`.
        /// </remarks>
        [Flags]
        public enum git_index_entry_extended_flag_t : uint
        {
            GIT_INDEX_ENTRY_INTENT_TO_ADD = unchecked((uint)8192),
            
            GIT_INDEX_ENTRY_SKIP_WORKTREE = unchecked((uint)16384),
            
            GIT_INDEX_ENTRY_EXTENDED_FLAGS = unchecked((uint)24576),
            
            GIT_INDEX_ENTRY_UPTODATE = unchecked((uint)4),
        }
        
        public const libgit2.git_index_entry_extended_flag_t GIT_INDEX_ENTRY_INTENT_TO_ADD = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_INTENT_TO_ADD;
        
        public const libgit2.git_index_entry_extended_flag_t GIT_INDEX_ENTRY_SKIP_WORKTREE = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_SKIP_WORKTREE;
        
        public const libgit2.git_index_entry_extended_flag_t GIT_INDEX_ENTRY_EXTENDED_FLAGS = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_EXTENDED_FLAGS;
        
        public const libgit2.git_index_entry_extended_flag_t GIT_INDEX_ENTRY_UPTODATE = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_UPTODATE;
        
        /// <summary>
        /// Capabilities of system that affect index actions.
        /// </summary>
        public enum git_index_capability_t : int
        {
            GIT_INDEX_CAPABILITY_IGNORE_CASE = unchecked((int)1),
            
            GIT_INDEX_CAPABILITY_NO_FILEMODE = unchecked((int)2),
            
            GIT_INDEX_CAPABILITY_NO_SYMLINKS = unchecked((int)4),
            
            GIT_INDEX_CAPABILITY_FROM_OWNER = unchecked((int)-1),
        }
        
        public const libgit2.git_index_capability_t GIT_INDEX_CAPABILITY_IGNORE_CASE = git_index_capability_t.GIT_INDEX_CAPABILITY_IGNORE_CASE;
        
        public const libgit2.git_index_capability_t GIT_INDEX_CAPABILITY_NO_FILEMODE = git_index_capability_t.GIT_INDEX_CAPABILITY_NO_FILEMODE;
        
        public const libgit2.git_index_capability_t GIT_INDEX_CAPABILITY_NO_SYMLINKS = git_index_capability_t.GIT_INDEX_CAPABILITY_NO_SYMLINKS;
        
        public const libgit2.git_index_capability_t GIT_INDEX_CAPABILITY_FROM_OWNER = git_index_capability_t.GIT_INDEX_CAPABILITY_FROM_OWNER;
        
        /// <summary>
        /// Flags for APIs that add files matching pathspec
        /// </summary>
        [Flags]
        public enum git_index_add_option_t : uint
        {
            GIT_INDEX_ADD_DEFAULT = unchecked((uint)0),
            
            GIT_INDEX_ADD_FORCE = unchecked((uint)1),
            
            GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = unchecked((uint)2),
            
            GIT_INDEX_ADD_CHECK_PATHSPEC = unchecked((uint)4),
        }
        
        public const libgit2.git_index_add_option_t GIT_INDEX_ADD_DEFAULT = git_index_add_option_t.GIT_INDEX_ADD_DEFAULT;
        
        public const libgit2.git_index_add_option_t GIT_INDEX_ADD_FORCE = git_index_add_option_t.GIT_INDEX_ADD_FORCE;
        
        public const libgit2.git_index_add_option_t GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = git_index_add_option_t.GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH;
        
        public const libgit2.git_index_add_option_t GIT_INDEX_ADD_CHECK_PATHSPEC = git_index_add_option_t.GIT_INDEX_ADD_CHECK_PATHSPEC;
        
        /// <summary>
        /// Git index stage states
        /// </summary>
        public enum git_index_stage_t : int
        {
            /// <summary>
            /// Match any index stage.
            /// </summary>
            /// <remarks>
            /// Some index APIs take a stage to match; pass this value to match
            /// any entry matching the path regardless of stage.
            /// </remarks>
            GIT_INDEX_STAGE_ANY = unchecked((int)-1),
            
            /// <summary>
            /// A normal staged file in the index.
            /// </summary>
            GIT_INDEX_STAGE_NORMAL = unchecked((int)0),
            
            /// <summary>
            /// The ancestor side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_ANCESTOR = unchecked((int)1),
            
            /// <summary>
            /// The "ours" side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_OURS = unchecked((int)2),
            
            /// <summary>
            /// The "theirs" side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_THEIRS = unchecked((int)3),
        }
        
        /// <summary>
        /// Match any index stage.
        /// </summary>
        /// <remarks>
        /// Some index APIs take a stage to match; pass this value to match
        /// any entry matching the path regardless of stage.
        /// </remarks>
        public const libgit2.git_index_stage_t GIT_INDEX_STAGE_ANY = git_index_stage_t.GIT_INDEX_STAGE_ANY;
        
        /// <summary>
        /// A normal staged file in the index.
        /// </summary>
        public const libgit2.git_index_stage_t GIT_INDEX_STAGE_NORMAL = git_index_stage_t.GIT_INDEX_STAGE_NORMAL;
        
        /// <summary>
        /// The ancestor side of a conflict.
        /// </summary>
        public const libgit2.git_index_stage_t GIT_INDEX_STAGE_ANCESTOR = git_index_stage_t.GIT_INDEX_STAGE_ANCESTOR;
        
        /// <summary>
        /// The "ours" side of a conflict.
        /// </summary>
        public const libgit2.git_index_stage_t GIT_INDEX_STAGE_OURS = git_index_stage_t.GIT_INDEX_STAGE_OURS;
        
        /// <summary>
        /// The "theirs" side of a conflict.
        /// </summary>
        public const libgit2.git_index_stage_t GIT_INDEX_STAGE_THEIRS = git_index_stage_t.GIT_INDEX_STAGE_THEIRS;
        
        /// <summary>
        /// Time structure used in a git index entry
        /// </summary>
        public partial struct git_index_time
        {
            public int seconds;
            
            /// <summary>
            /// nsec should not be stored as time_t compatible
            /// </summary>
            public uint nanoseconds;
        }
        
        /// <summary>
        /// In-memory representation of a file entry in the index.
        /// </summary>
        /// <remarks>
        /// This is a public structure that represents a file entry in the index.
        /// The meaning of the fields corresponds to core Git's documentation (in
        /// "Documentation/technical/index-format.txt").The `flags` field consists of a number of bit fields which can be
        /// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
        /// These flags are all read from and persisted to disk.The `flags_extended` field also has a number of bit fields which can be
        /// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
        /// these flags are read from and written to disk, but some are set aside
        /// for in-memory only reference.Note that the time and size fields are truncated to 32 bits. This
        /// is enough to detect changes, which is enough for the index to
        /// function as a cache, but it should not be taken as an authoritative
        /// source for that data.
        /// </remarks>
        public partial struct git_index_entry
        {
            public libgit2.git_index_time ctime;
            
            public libgit2.git_index_time mtime;
            
            public uint dev;
            
            public uint ino;
            
            public uint mode;
            
            public uint uid;
            
            public uint gid;
            
            public uint file_size;
            
            public libgit2.git_oid id;
            
            public ushort flags;
            
            public ushort flags_extended;
            
            public byte* path;
        }
        
        /// <summary>
        /// Callback for APIs that add/remove/update files matching pathspec
        /// </summary>
        public readonly partial struct git_index_matched_path_cb : IEquatable<git_index_matched_path_cb>
        {
            public git_index_matched_path_cb(delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_index_matched_path_cb other && Equals(other);
            
            public bool Equals(git_index_matched_path_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> (libgit2.git_index_matched_path_cb from) => from.Value;
            
            public static implicit operator libgit2.git_index_matched_path_cb (delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> from) => new libgit2.git_index_matched_path_cb(from);
            
            public static bool operator ==(git_index_matched_path_cb left, git_index_matched_path_cb right) => left.Equals(right);
            
            public static bool operator !=(git_index_matched_path_cb left, git_index_matched_path_cb right) => !left.Equals(right);
        }
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_open(out libgit2.git_index @out, byte* index_path);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_open(out libgit2.git_index @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> index_path);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_new(out libgit2.git_index @out);
        
        /// <summary>
        /// Free an existing index object.
        /// </summary>
        /// <param name="index">an existing index object</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_index_free(libgit2.git_index index);
        
        /// <summary>
        /// Get the repository this index relates to
        /// </summary>
        /// <param name="index">The index</param>
        /// <returns>@return A pointer to the repository</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_index_owner(libgit2.git_index index);
        
        /// <summary>
        /// Read index capabilities flags.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <returns>@return A combination of GIT_INDEX_CAPABILITY values</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_caps")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_index_capability_t git_index_caps(libgit2.git_index index);
        
        /// <summary>
        /// Set index capabilities flags.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="caps">A combination of GIT_INDEX_CAPABILITY values</param>
        /// <returns>@return 0 on success, -1 on failure</returns>
        /// <remarks>
        /// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
        /// capabilities will be read from the config of the owner object,
        /// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_set_caps")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_set_caps(libgit2.git_index index, libgit2.git_index_capability_t caps);
        
        /// <summary>
        /// Get index on-disk version.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <returns>@return the index version</returns>
        /// <remarks>
        /// Valid return values are 2, 3, or 4.  If 3 is returned, an index
        /// with version 2 may be written instead, if the extension data in
        /// version 3 is not necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_version")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial uint git_index_version(libgit2.git_index index);
        
        /// <summary>
        /// Set index on-disk version.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="version">The new version number</param>
        /// <returns>@return 0 on success, -1 on failure</returns>
        /// <remarks>
        /// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
        /// write an index with version 3 instead, if necessary to accurately
        /// represent the index.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_set_version")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_set_version(libgit2.git_index index, uint version);
        
        /// <summary>
        /// Update the contents of an existing index object in memory by reading
        /// from the hard disk.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="force">if true, always reload, vs. only read if file has changed</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If `force` is true, this performs a "hard" read that discards in-memory
        /// changes and always reloads the on-disk index data.  If there is no
        /// on-disk version, the index will be cleared.If `force` is false, this does a "soft" read that reloads the index
        /// data from disk only if it has changed since the last time it was
        /// loaded.  Purely in-memory index data will be untouched.  Be aware: if
        /// there are changes on disk, unwritten in-memory changes are discarded.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_read(libgit2.git_index index, int force);
        
        /// <summary>
        /// Write an existing index object from memory back to disk
        /// using an atomic file lock.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_write")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_write(libgit2.git_index index);
        
        /// <summary>
        /// Get the full path to the index file on disk.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return path to index file or NULL for in-memory index</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_index_path(libgit2.git_index index);
        
        /// <summary>
        /// Get the full path to the index file on disk.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return path to index file or NULL for in-memory index</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_index_path_string(libgit2.git_index index);
        
        /// <summary>
        /// Read a tree into the index file with stats
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="tree">tree to read</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The current index contents will be replaced by the specified tree.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_read_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_read_tree(libgit2.git_index index, libgit2.git_tree tree);
        
        /// <summary>
        /// Write the index as a tree
        /// </summary>
        /// <param name="out">Pointer where to store the OID of the written tree</param>
        /// <param name="index">Index to write</param>
        /// <returns>@return 0 on success, GIT_EUNMERGED when the index is not clean
        /// or an error code</returns>
        /// <remarks>
        /// This method will scan the index and write a representation
        /// of its current state back to disk; it recursively creates
        /// tree objects for each of the subtrees stored in the index,
        /// but only returns the OID of the root tree. This is the OID
        /// that can be used e.g. to create a commit.The index instance cannot be bare, and needs to be associated
        /// to an existing repository.The index must not contain any file in conflict.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_write_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_write_tree(out libgit2.git_oid @out, libgit2.git_index index);
        
        /// <summary>
        /// Write the index as a tree to the given repository
        /// </summary>
        /// <param name="out">Pointer where to store OID of the written tree</param>
        /// <param name="index">Index to write</param>
        /// <param name="repo">Repository where to write the tree</param>
        /// <returns>@return 0 on success, GIT_EUNMERGED when the index is not clean
        /// or an error code</returns>
        /// <remarks>
        /// This method will do the same as `git_index_write_tree`, but
        /// letting the user choose the repository where the tree will
        /// be written.The index must not contain any file in conflict.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_write_tree_to")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_write_tree_to(out libgit2.git_oid @out, libgit2.git_index index, libgit2.git_repository repo);
        
        /// <summary>
        /// Get the count of entries currently in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return integer of count of current entries</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_entrycount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint git_index_entrycount(libgit2.git_index index);
        
        /// <summary>
        /// Clear the contents (all the entries) of an index object.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return 0 on success, error code 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// This clears the index object in memory; changes must be explicitly
        /// written to disk for them to take effect persistently.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_clear")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_clear(libgit2.git_index index);
        
        /// <summary>
        /// Get a pointer to one of the entries in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="n">the position of the entry</param>
        /// <returns>@return a pointer to the entry; NULL if out of bounds</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_get_byindex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_index_entry* git_index_get_byindex(libgit2.git_index index, nuint n);
        
        /// <summary>
        /// Get a pointer to one of the entries in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return a pointer to the entry; NULL if it was not found</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_get_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_index_entry* git_index_get_bypath(libgit2.git_index index, byte* path, int stage);
        
        /// <summary>
        /// Get a pointer to one of the entries in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return a pointer to the entry; NULL if it was not found</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_get_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_index_entry* git_index_get_bypath(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, int stage);
        
        /// <summary>
        /// Remove an entry from the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove(libgit2.git_index index, byte* path, int stage);
        
        /// <summary>
        /// Remove an entry from the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, int stage);
        
        /// <summary>
        /// Remove all entries from the index under a given directory
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="dir">container directory path</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove_directory")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove_directory(libgit2.git_index index, byte* dir, int stage);
        
        /// <summary>
        /// Remove all entries from the index under a given directory
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="dir">container directory path</param>
        /// <param name="stage">stage to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove_directory")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove_directory(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> dir, int stage);
        
        /// <summary>
        /// Add or update an index entry from an in-memory struct
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="source_entry">new entry object</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If a previous index entry exists that has the same path and stage
        /// as the given 'source_entry', it will be replaced.  Otherwise, the
        /// 'source_entry' will be added.A full copy (including the 'path' string) of the given
        /// 'source_entry' will be inserted on the index.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_add(libgit2.git_index index, in libgit2.git_index_entry source_entry);
        
        /// <summary>
        /// Return the stage number from a git index entry
        /// </summary>
        /// <param name="entry">The entry</param>
        /// <returns>@return the stage number</returns>
        /// <remarks>
        /// This entry is calculated from the entry's flag attribute like this:(entry-&gt;flags 
        /// &amp;
        /// GIT_INDEX_ENTRY_STAGEMASK) &gt;&gt; GIT_INDEX_ENTRY_STAGESHIFT
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_entry_stage")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_entry_stage(in libgit2.git_index_entry entry);
        
        /// <summary>
        /// Return whether the given index entry is a conflict (has a high stage
        /// entry).  This is simply shorthand for `git_index_entry_stage &gt; 0`.
        /// </summary>
        /// <param name="entry">The entry</param>
        /// <returns>@return 1 if the entry is a conflict entry, 0 otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_entry_is_conflict")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_entry_is_conflict(in libgit2.git_index_entry entry);
        
        /// <summary>
        /// Create an iterator that will return every entry contained in the
        /// index at the time of creation.  Entries are returned in order,
        /// sorted by path.  This iterator is backed by a snapshot that allows
        /// callers to modify the index while iterating without affecting the
        /// iterator.
        /// </summary>
        /// <param name="iterator_out">The newly created iterator</param>
        /// <param name="index">The index to iterate</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_iterator_new(out libgit2.git_index_iterator iterator_out, libgit2.git_index index);
        
        /// <summary>
        /// Return the next index entry in-order from the iterator.
        /// </summary>
        /// <param name="out">Pointer to store the index entry in</param>
        /// <param name="iterator">The iterator</param>
        /// <returns>@return 0, GIT_ITEROVER on iteration completion or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_iterator_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_iterator_next(out libgit2.git_index_entry* @out, libgit2.git_index_iterator iterator);
        
        /// <summary>
        /// Free the index iterator
        /// </summary>
        /// <param name="iterator">The iterator to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_index_iterator_free(libgit2.git_index_iterator iterator);
        
        /// <summary>
        /// Add or update an index entry from a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to add</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder and must be readable.This method will fail in bare index instances.This forces the file to be added to the index, not looking
        /// at gitignore rules.  Those rules can be evaluated through
        /// the git_status APIs (in status.h) before calling this.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_add_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_add_bypath(libgit2.git_index index, byte* path);
        
        /// <summary>
        /// Add or update an index entry from a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to add</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder and must be readable.This method will fail in bare index instances.This forces the file to be added to the index, not looking
        /// at gitignore rules.  Those rules can be evaluated through
        /// the git_status APIs (in status.h) before calling this.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_add_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_add_bypath(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Add or update an index entry from a buffer in memory
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="entry">filename to add</param>
        /// <param name="buffer">data to be written into the blob</param>
        /// <param name="len">length of the data</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This method will create a blob in the repository that owns the
        /// index and then add the index entry to the index.  The `path` of the
        /// entry represents the position of the blob relative to the
        /// repository's root folder.If a previous index entry exists that has the same path as the
        /// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
        /// added.This forces the file to be added to the index, not looking
        /// at gitignore rules.  Those rules can be evaluated through
        /// the git_status APIs (in status.h) before calling this.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_add_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_add_from_buffer(libgit2.git_index index, in libgit2.git_index_entry entry, void* buffer, nuint len);
        
        /// <summary>
        /// Remove an index entry corresponding to a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to remove</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder.  It may exist.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove_bypath(libgit2.git_index index, byte* path);
        
        /// <summary>
        /// Remove an index entry corresponding to a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to remove</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder.  It may exist.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove_bypath")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove_bypath(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Add or update index entries matching files in the working directory.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="flags">combination of git_index_add_option_t flags</param>
        /// <param name="callback">notification callback for each added/updated path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>@return 0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// This method will fail in bare index instances.The `pathspec` is a list of file names or shell glob patterns that will
        /// be matched against files in the repository's working directory.  Each
        /// file that matches will be added to the index (either updating an
        /// existing entry or adding a new entry).  You can disable glob expansion
        /// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
        /// flag.Files that are ignored will be skipped (unlike `git_index_add_bypath`).
        /// If a file is already tracked in the index, then it *will* be updated
        /// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
        /// the checking of ignore rules.To emulate `git add -A` and generate an error if the pathspec contains
        /// the exact path of an ignored file (when not using FORCE), add the
        /// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
        /// in the `pathspec` that is an exact match to a filename on disk is
        /// either not ignored or already in the index.  If this check fails, the
        /// function will return GIT_EINVALIDSPEC.To emulate `git add -A` with the "dry-run" option, just use a callback
        /// function that always returns a positive value.  See below for details.If any files are currently the result of a merge conflict, those files
        /// will no longer be marked as conflicting.  The data about the conflicts
        /// will be moved to the "resolve undo" (REUC) section.If you provide a callback function, it will be invoked on each matching
        /// item in the working directory immediately *before* it is added to /
        /// updated in the index.  Returning zero will add the item to the index,
        /// greater than zero will skip the item, and less than zero will abort the
        /// scan and return that value to the caller.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_add_all")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_add_all(libgit2.git_index index, in libgit2.git_strarray pathspec, libgit2.git_index_add_option_t flags, libgit2.git_index_matched_path_cb callback, void* payload);
        
        /// <summary>
        /// Remove all matching index entries.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="callback">notification callback for each removed path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>@return 0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// If you provide a callback function, it will be invoked on each matching
        /// item in the index immediately *before* it is removed.  Return 0 to
        /// remove the item, &gt; 0 to skip the item, and 
        /// &lt;
        /// 0 to abort the scan.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_remove_all")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_remove_all(libgit2.git_index index, in libgit2.git_strarray pathspec, libgit2.git_index_matched_path_cb callback, void* payload);
        
        /// <summary>
        /// Update all index entries to match the working directory
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="callback">notification callback for each updated path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>@return 0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// This method will fail in bare index instances.This scans the existing index entries and synchronizes them with the
        /// working directory, deleting them if the corresponding working directory
        /// file no longer exists otherwise updating the information (including
        /// adding the latest version of file to the ODB if needed).If you provide a callback function, it will be invoked on each matching
        /// item in the index immediately *before* it is updated (either refreshed
        /// or removed depending on working directory state).  Return 0 to proceed
        /// with updating the item, &gt; 0 to skip the item, and 
        /// &lt;
        /// 0 to abort the scan.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_update_all")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_update_all(libgit2.git_index index, in libgit2.git_strarray pathspec, libgit2.git_index_matched_path_cb callback, void* payload);
        
        /// <summary>
        /// Find the first position of any entries which point to given
        /// path in the Git index.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_find")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_find(out nuint at_pos, libgit2.git_index index, byte* path);
        
        /// <summary>
        /// Find the first position of any entries which point to given
        /// path in the Git index.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_find")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_find(out nuint at_pos, libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Find the first position of any entries matching a prefix. To find the first position
        /// of a path inside a given folder, suffix the prefix with a '/'.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="prefix">the prefix to search for</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_find_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_find_prefix(out nuint at_pos, libgit2.git_index index, byte* prefix);
        
        /// <summary>
        /// Find the first position of any entries matching a prefix. To find the first position
        /// of a path inside a given folder, suffix the prefix with a '/'.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="prefix">the prefix to search for</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_find_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_find_prefix(out nuint at_pos, libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> prefix);
        
        /// <summary>
        /// Add or update index entries to represent a conflict.  Any staged
        /// entries that exist at the given paths will be removed.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="ancestor_entry">the entry data for the ancestor of the conflict</param>
        /// <param name="our_entry">the entry data for our side of the merge conflict</param>
        /// <param name="their_entry">the entry data for their side of the merge conflict</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The entries are the entries from the tree included in the merge.  Any
        /// entry may be null to indicate that that file was not present in the
        /// trees during the merge.  For example, ancestor_entry may be NULL to
        /// indicate that a file was added in both branches and must be resolved.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_add(libgit2.git_index index, in libgit2.git_index_entry ancestor_entry, in libgit2.git_index_entry our_entry, in libgit2.git_index_entry their_entry);
        
        /// <summary>
        /// Get the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="ancestor_out">Pointer to store the ancestor entry</param>
        /// <param name="our_out">Pointer to store the our entry</param>
        /// <param name="their_out">Pointer to store the their entry</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The entries are not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_get")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_get(out libgit2.git_index_entry* ancestor_out, ref libgit2.git_index_entry* our_out, ref libgit2.git_index_entry* their_out, libgit2.git_index index, byte* path);
        
        /// <summary>
        /// Get the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="ancestor_out">Pointer to store the ancestor entry</param>
        /// <param name="our_out">Pointer to store the our entry</param>
        /// <param name="their_out">Pointer to store the their entry</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The entries are not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_get")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_get(out libgit2.git_index_entry* ancestor_out, ref libgit2.git_index_entry* our_out, ref libgit2.git_index_entry* their_out, libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Removes the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to remove conflicts for</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_remove(libgit2.git_index index, byte* path);
        
        /// <summary>
        /// Removes the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to remove conflicts for</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_remove(libgit2.git_index index, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Remove all conflicts in the index (entries with a stage greater than 0).
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_cleanup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_cleanup(libgit2.git_index index);
        
        /// <summary>
        /// Determine if the index contains entries representing file conflicts.
        /// </summary>
        /// <param name="index">An existing index object.</param>
        /// <returns>@return 1 if at least one conflict is found, 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_has_conflicts")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_index_has_conflicts(libgit2.git_index index);
        
        /// <summary>
        /// Create an iterator for the conflicts in the index.
        /// </summary>
        /// <param name="iterator_out">The newly created conflict iterator</param>
        /// <param name="index">The index to scan</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The index must not be modified while iterating; the results are undefined.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_iterator_new(out libgit2.git_index_conflict_iterator iterator_out, libgit2.git_index index);
        
        /// <summary>
        /// Returns the current conflict (ancestor, ours and theirs entry) and
        /// advance the iterator internally to the next value.
        /// </summary>
        /// <param name="ancestor_out">Pointer to store the ancestor side of the conflict</param>
        /// <param name="our_out">Pointer to store our side of the conflict</param>
        /// <param name="their_out">Pointer to store their side of the conflict</param>
        /// <param name="iterator">The conflict iterator.</param>
        /// <returns>@return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
        /// (negative value)</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_index_conflict_next(out libgit2.git_index_entry* ancestor_out, out libgit2.git_index_entry* our_out, out libgit2.git_index_entry* their_out, libgit2.git_index_conflict_iterator iterator);
        
        /// <summary>
        /// Frees a `git_index_conflict_iterator`.
        /// </summary>
        /// <param name="iterator">pointer to the iterator</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_index_conflict_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_index_conflict_iterator_free(libgit2.git_index_conflict_iterator iterator);
    }
}
