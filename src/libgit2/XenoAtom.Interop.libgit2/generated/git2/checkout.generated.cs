//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Checkout behavior flags
        /// </summary>
        /// <remarks>
        /// In libgit2, checkout is used to update the working directory and index
        /// to match a target tree.  Unlike git checkout, it does not move the HEAD
        /// commit for you - use `git_repository_set_head` or the like to do that.Checkout looks at (up to) four things: the "target" tree you want to
        /// check out, the "baseline" tree of what was checked out previously, the
        /// working directory for actual files, and the index for staged changes.You give checkout one of three strategies for update:- `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
        /// etc., but doesn't make any actual changes.- `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
        /// make the working directory match the target (including potentially
        /// discarding modified files).- `GIT_CHECKOUT_SAFE` is between these two options, it will only make
        /// modifications that will not lose changes.|  target == baseline   |  target != baseline  |
        /// ---------------------|-----------------------|----------------------|
        /// workdir == baseline |       no action       |  create, update, or  |
        /// |                       |     delete file      |
        /// ---------------------|-----------------------|----------------------|
        /// workdir exists and  |       no action       |   conflict (notify   |
        /// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
        /// ---------------------|-----------------------|----------------------|
        /// workdir missing,   | notify dirty DELETED  |     create file      |
        /// baseline present   |                       |                      |
        /// ---------------------|-----------------------|----------------------|To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
        /// notification callback (see below) that displays information about dirty
        /// files.  The default behavior will cancel checkout on conflicts.To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
        /// notification callback that cancels the operation if a dirty-but-existing
        /// file is found in the working directory.  This core git command isn't
        /// quite "force" but is sensitive about some types of changes.To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.There are some additional flags to modify the behavior of checkout:- GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
        /// even if there are conflicts (instead of cancelling the checkout).- GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
        /// in target, baseline, or index, and not ignored) from the working dir.- GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
        /// untracked) from the working directory as well.- GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
        /// already exist.  Files will not be created nor deleted.  This just skips
        /// applying adds, deletes, and typechanges.- GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
        /// updated files' information to the index.- Normally, checkout will reload the index and git attributes from disk
        /// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.- Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
        /// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
        /// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
        /// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.- GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
        /// overwritten.  Normally, files that are ignored in the working directory
        /// are not considered "precious" and may be overwritten if the checkout
        /// target contains that file.- GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
        /// files or folders that fold to the same name on case insensitive
        /// filesystems.  This can cause files to retain their existing names
        /// and write through existing symbolic links.
        /// </remarks>
        [Flags]
        public enum git_checkout_strategy_t : uint
        {
            /// <summary>
            /// default is a dry run, no actual updates
            /// </summary>
            GIT_CHECKOUT_NONE = unchecked((uint)0),
            
            /// <summary>
            /// Allow safe updates that cannot overwrite uncommitted data.
            /// If the uncommitted changes don't conflict with the checked out files,
            /// the checkout will still proceed, leaving the changes intact.
            /// </summary>
            /// <remarks>
            /// Mutually exclusive with GIT_CHECKOUT_FORCE.
            /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
            /// </remarks>
            GIT_CHECKOUT_SAFE = unchecked((uint)1),
            
            /// <summary>
            /// Allow all updates to force working directory to look like index.
            /// </summary>
            /// <remarks>
            /// Mutually exclusive with GIT_CHECKOUT_SAFE.
            /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
            /// </remarks>
            GIT_CHECKOUT_FORCE = unchecked((uint)2),
            
            /// <summary>
            /// Allow checkout to recreate missing files
            /// </summary>
            GIT_CHECKOUT_RECREATE_MISSING = unchecked((uint)4),
            
            /// <summary>
            /// Allow checkout to make safe updates even if conflicts are found
            /// </summary>
            GIT_CHECKOUT_ALLOW_CONFLICTS = unchecked((uint)16),
            
            /// <summary>
            /// Remove untracked files not in index (that are not ignored)
            /// </summary>
            GIT_CHECKOUT_REMOVE_UNTRACKED = unchecked((uint)32),
            
            /// <summary>
            /// Remove ignored files not in index
            /// </summary>
            GIT_CHECKOUT_REMOVE_IGNORED = unchecked((uint)64),
            
            /// <summary>
            /// Only update existing files, don't create new ones
            /// </summary>
            GIT_CHECKOUT_UPDATE_ONLY = unchecked((uint)128),
            
            /// <summary>
            /// Normally checkout updates index entries as it goes; this stops that.
            /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
            /// </summary>
            GIT_CHECKOUT_DONT_UPDATE_INDEX = unchecked((uint)256),
            
            /// <summary>
            /// Don't refresh index/config/etc before doing checkout
            /// </summary>
            GIT_CHECKOUT_NO_REFRESH = unchecked((uint)512),
            
            /// <summary>
            /// Allow checkout to skip unmerged files
            /// </summary>
            GIT_CHECKOUT_SKIP_UNMERGED = unchecked((uint)1024),
            
            /// <summary>
            /// For unmerged files, checkout stage 2 from index
            /// </summary>
            GIT_CHECKOUT_USE_OURS = unchecked((uint)2048),
            
            /// <summary>
            /// For unmerged files, checkout stage 3 from index
            /// </summary>
            GIT_CHECKOUT_USE_THEIRS = unchecked((uint)4096),
            
            /// <summary>
            /// Treat pathspec as simple list of exact match file paths
            /// </summary>
            GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = unchecked((uint)8192),
            
            /// <summary>
            /// Ignore directories in use, they will be left empty
            /// </summary>
            GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = unchecked((uint)262144),
            
            /// <summary>
            /// Don't overwrite ignored files that exist in the checkout target
            /// </summary>
            GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = unchecked((uint)524288),
            
            /// <summary>
            /// Write normal merge files for conflicts
            /// </summary>
            GIT_CHECKOUT_CONFLICT_STYLE_MERGE = unchecked((uint)1048576),
            
            /// <summary>
            /// Include common ancestor data in diff3 format files for conflicts
            /// </summary>
            GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = unchecked((uint)2097152),
            
            /// <summary>
            /// Don't overwrite existing files or folders
            /// </summary>
            GIT_CHECKOUT_DONT_REMOVE_EXISTING = unchecked((uint)4194304),
            
            /// <summary>
            /// Normally checkout writes the index upon completion; this prevents that.
            /// </summary>
            GIT_CHECKOUT_DONT_WRITE_INDEX = unchecked((uint)8388608),
            
            /// <summary>
            /// Show what would be done by a checkout.  Stop after sending
            /// notifications; don't update the working directory or index.
            /// </summary>
            GIT_CHECKOUT_DRY_RUN = unchecked((uint)16777216),
            
            /// <summary>
            /// Include common ancestor data in zdiff3 format for conflicts
            /// </summary>
            GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = unchecked((uint)33554432),
            
            /// <summary>
            /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
            /// </summary>
            GIT_CHECKOUT_UPDATE_SUBMODULES = unchecked((uint)65536),
            
            /// <summary>
            /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
            /// </summary>
            GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = unchecked((uint)131072),
        }
        
        /// <summary>
        /// default is a dry run, no actual updates
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_NONE = git_checkout_strategy_t.GIT_CHECKOUT_NONE;
        
        /// <summary>
        /// Allow safe updates that cannot overwrite uncommitted data.
        /// If the uncommitted changes don't conflict with the checked out files,
        /// the checkout will still proceed, leaving the changes intact.
        /// </summary>
        /// <remarks>
        /// Mutually exclusive with GIT_CHECKOUT_FORCE.
        /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
        /// </remarks>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_SAFE = git_checkout_strategy_t.GIT_CHECKOUT_SAFE;
        
        /// <summary>
        /// Allow all updates to force working directory to look like index.
        /// </summary>
        /// <remarks>
        /// Mutually exclusive with GIT_CHECKOUT_SAFE.
        /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
        /// </remarks>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_FORCE = git_checkout_strategy_t.GIT_CHECKOUT_FORCE;
        
        /// <summary>
        /// Allow checkout to recreate missing files
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_RECREATE_MISSING = git_checkout_strategy_t.GIT_CHECKOUT_RECREATE_MISSING;
        
        /// <summary>
        /// Allow checkout to make safe updates even if conflicts are found
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_ALLOW_CONFLICTS = git_checkout_strategy_t.GIT_CHECKOUT_ALLOW_CONFLICTS;
        
        /// <summary>
        /// Remove untracked files not in index (that are not ignored)
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_REMOVE_UNTRACKED = git_checkout_strategy_t.GIT_CHECKOUT_REMOVE_UNTRACKED;
        
        /// <summary>
        /// Remove ignored files not in index
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_REMOVE_IGNORED = git_checkout_strategy_t.GIT_CHECKOUT_REMOVE_IGNORED;
        
        /// <summary>
        /// Only update existing files, don't create new ones
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_UPDATE_ONLY = git_checkout_strategy_t.GIT_CHECKOUT_UPDATE_ONLY;
        
        /// <summary>
        /// Normally checkout updates index entries as it goes; this stops that.
        /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DONT_UPDATE_INDEX = git_checkout_strategy_t.GIT_CHECKOUT_DONT_UPDATE_INDEX;
        
        /// <summary>
        /// Don't refresh index/config/etc before doing checkout
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_NO_REFRESH = git_checkout_strategy_t.GIT_CHECKOUT_NO_REFRESH;
        
        /// <summary>
        /// Allow checkout to skip unmerged files
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_SKIP_UNMERGED = git_checkout_strategy_t.GIT_CHECKOUT_SKIP_UNMERGED;
        
        /// <summary>
        /// For unmerged files, checkout stage 2 from index
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_USE_OURS = git_checkout_strategy_t.GIT_CHECKOUT_USE_OURS;
        
        /// <summary>
        /// For unmerged files, checkout stage 3 from index
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_USE_THEIRS = git_checkout_strategy_t.GIT_CHECKOUT_USE_THEIRS;
        
        /// <summary>
        /// Treat pathspec as simple list of exact match file paths
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = git_checkout_strategy_t.GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH;
        
        /// <summary>
        /// Ignore directories in use, they will be left empty
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = git_checkout_strategy_t.GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES;
        
        /// <summary>
        /// Don't overwrite ignored files that exist in the checkout target
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = git_checkout_strategy_t.GIT_CHECKOUT_DONT_OVERWRITE_IGNORED;
        
        /// <summary>
        /// Write normal merge files for conflicts
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_CONFLICT_STYLE_MERGE = git_checkout_strategy_t.GIT_CHECKOUT_CONFLICT_STYLE_MERGE;
        
        /// <summary>
        /// Include common ancestor data in diff3 format files for conflicts
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = git_checkout_strategy_t.GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;
        
        /// <summary>
        /// Don't overwrite existing files or folders
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DONT_REMOVE_EXISTING = git_checkout_strategy_t.GIT_CHECKOUT_DONT_REMOVE_EXISTING;
        
        /// <summary>
        /// Normally checkout writes the index upon completion; this prevents that.
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DONT_WRITE_INDEX = git_checkout_strategy_t.GIT_CHECKOUT_DONT_WRITE_INDEX;
        
        /// <summary>
        /// Show what would be done by a checkout.  Stop after sending
        /// notifications; don't update the working directory or index.
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_DRY_RUN = git_checkout_strategy_t.GIT_CHECKOUT_DRY_RUN;
        
        /// <summary>
        /// Include common ancestor data in zdiff3 format for conflicts
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = git_checkout_strategy_t.GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3;
        
        /// <summary>
        /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_UPDATE_SUBMODULES = git_checkout_strategy_t.GIT_CHECKOUT_UPDATE_SUBMODULES;
        
        /// <summary>
        /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
        /// </summary>
        public const libgit2.git_checkout_strategy_t GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = git_checkout_strategy_t.GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED;
        
        /// <summary>
        /// Checkout notification flags
        /// </summary>
        /// <remarks>
        /// Checkout will invoke an options notification callback (`notify_cb`) for
        /// certain cases - you pick which ones via `notify_flags`:Returning a non-zero value from this callback will cancel the checkout.
        /// The non-zero return value will be propagated back and returned by the
        /// git_checkout_... call.Notification callbacks are made prior to modifying any files on disk,
        /// so canceling on any notification will still happen prior to any files
        /// being modified.
        /// </remarks>
        [Flags]
        public enum git_checkout_notify_t : uint
        {
            GIT_CHECKOUT_NOTIFY_NONE = unchecked((uint)0),
            
            /// <summary>
            /// Invokes checkout on conflicting paths.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_CONFLICT = unchecked((uint)1),
            
            /// <summary>
            /// Notifies about "dirty" files, i.e. those that do not need an update
            /// but no longer match the baseline.  Core git displays these files when
            /// checkout runs, but won't stop the checkout.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_DIRTY = unchecked((uint)2),
            
            /// <summary>
            /// Sends notification for any file changed.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_UPDATED = unchecked((uint)4),
            
            /// <summary>
            /// Notifies about untracked files.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_UNTRACKED = unchecked((uint)8),
            
            /// <summary>
            /// Notifies about ignored files.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_IGNORED = unchecked((uint)16),
            
            /// <summary>
            /// Notifies about ignored files.
            /// </summary>
            GIT_CHECKOUT_NOTIFY_ALL = unchecked((uint)65535),
        }
        
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_NONE = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_NONE;
        
        /// <summary>
        /// Invokes checkout on conflicting paths.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_CONFLICT = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_CONFLICT;
        
        /// <summary>
        /// Notifies about "dirty" files, i.e. those that do not need an update
        /// but no longer match the baseline.  Core git displays these files when
        /// checkout runs, but won't stop the checkout.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_DIRTY = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_DIRTY;
        
        /// <summary>
        /// Sends notification for any file changed.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_UPDATED = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_UPDATED;
        
        /// <summary>
        /// Notifies about untracked files.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_UNTRACKED = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_UNTRACKED;
        
        /// <summary>
        /// Notifies about ignored files.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_IGNORED = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_IGNORED;
        
        /// <summary>
        /// Notifies about ignored files.
        /// </summary>
        public const libgit2.git_checkout_notify_t GIT_CHECKOUT_NOTIFY_ALL = git_checkout_notify_t.GIT_CHECKOUT_NOTIFY_ALL;
        
        /// <summary>
        /// Checkout performance-reporting structure
        /// </summary>
        public partial struct git_checkout_perfdata
        {
            public nuint mkdir_calls;
            
            public nuint stat_calls;
            
            public nuint chmod_calls;
        }
        
        /// <summary>
        /// Checkout options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
        /// use `git_checkout_options_init`.
        /// </remarks>
        public partial struct git_checkout_options
        {
            /// <summary>
            /// The version
            /// </summary>
            public uint version;
            
            /// <summary>
            /// default will be a safe checkout
            /// </summary>
            public uint checkout_strategy;
            
            /// <summary>
            /// don't apply filters like CRLF conversion
            /// </summary>
            public int disable_filters;
            
            /// <summary>
            /// default is 0755
            /// </summary>
            public uint dir_mode;
            
            /// <summary>
            /// default is 0644 or 0755 as dictated by blob
            /// </summary>
            public uint file_mode;
            
            /// <summary>
            /// default is O_CREAT | O_TRUNC | O_WRONLY
            /// </summary>
            public int file_open_flags;
            
            /// <summary>
            /// see `git_checkout_notify_t` above
            /// </summary>
            public libgit2.git_checkout_notify_t notify_flags;
            
            /// <summary>
            /// Optional callback to get notifications on specific file states.
            /// </summary>
            /// <seealso cref="git_checkout_notify_t"/>
            public libgit2.git_checkout_notify_cb notify_cb;
            
            /// <summary>
            /// Payload passed to notify_cb
            /// </summary>
            public void* notify_payload;
            
            /// <summary>
            /// Optional callback to notify the consumer of checkout progress.
            /// </summary>
            public libgit2.git_checkout_progress_cb progress_cb;
            
            /// <summary>
            /// Payload passed to progress_cb
            /// </summary>
            public void* progress_payload;
            
            /// <summary>
            /// A list of wildmatch patterns or paths.
            /// </summary>
            /// <remarks>
            /// By default, all paths are processed. If you pass an array of wildmatch
            /// patterns, those will be used to filter which paths should be taken into
            /// account.Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
            /// </remarks>
            public libgit2.git_strarray paths;
            
            /// <summary>
            /// The expected content of the working directory; defaults to HEAD.
            /// </summary>
            /// <remarks>
            /// If the working directory does not match this baseline information,
            /// that will produce a checkout conflict.
            /// </remarks>
            public libgit2.git_tree baseline;
            
            /// <summary>
            /// Like `baseline` above, though expressed as an index.  This
            /// option overrides `baseline`.
            /// </summary>
            public libgit2.git_index baseline_index;
            
            /// <summary>
            /// alternative checkout path to workdir
            /// </summary>
            public byte* target_directory;
            
            /// <summary>
            /// the name of the common ancestor side of conflicts
            /// </summary>
            public byte* ancestor_label;
            
            /// <summary>
            /// the name of the "our" side of conflicts
            /// </summary>
            public byte* our_label;
            
            /// <summary>
            /// the name of the "their" side of conflicts
            /// </summary>
            public byte* their_label;
            
            /// <summary>
            /// Optional callback to notify the consumer of performance data.
            /// </summary>
            public libgit2.git_checkout_perfdata_cb perfdata_cb;
            
            /// <summary>
            /// Payload passed to perfdata_cb
            /// </summary>
            public void* perfdata_payload;
        }
        
        /// <summary>
        /// Checkout notification callback function
        /// </summary>
        public readonly partial struct git_checkout_notify_cb : IEquatable<libgit2.git_checkout_notify_cb>
        {
            public git_checkout_notify_cb(delegate*unmanaged[Cdecl]<libgit2.git_checkout_notify_t, byte*, libgit2.git_diff_file*, libgit2.git_diff_file*, libgit2.git_diff_file*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_checkout_notify_t, byte*, libgit2.git_diff_file*, libgit2.git_diff_file*, libgit2.git_diff_file*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_checkout_notify_cb other && Equals(other);
            
            public bool Equals(git_checkout_notify_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_checkout_notify_t, byte*, libgit2.git_diff_file*, libgit2.git_diff_file*, libgit2.git_diff_file*, void*, int> (libgit2.git_checkout_notify_cb from) => from.Value;
            
            public static implicit operator libgit2.git_checkout_notify_cb (delegate*unmanaged[Cdecl]<libgit2.git_checkout_notify_t, byte*, libgit2.git_diff_file*, libgit2.git_diff_file*, libgit2.git_diff_file*, void*, int> from) => new libgit2.git_checkout_notify_cb(from);
            
            public static bool operator ==(git_checkout_notify_cb left, git_checkout_notify_cb right) => left.Equals(right);
            
            public static bool operator !=(git_checkout_notify_cb left, git_checkout_notify_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Checkout progress notification function
        /// </summary>
        public readonly partial struct git_checkout_progress_cb : IEquatable<libgit2.git_checkout_progress_cb>
        {
            public git_checkout_progress_cb(delegate*unmanaged[Cdecl]<byte*, nuint, nuint, void*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, nuint, nuint, void*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is git_checkout_progress_cb other && Equals(other);
            
            public bool Equals(git_checkout_progress_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, nuint, nuint, void*, void> (libgit2.git_checkout_progress_cb from) => from.Value;
            
            public static implicit operator libgit2.git_checkout_progress_cb (delegate*unmanaged[Cdecl]<byte*, nuint, nuint, void*, void> from) => new libgit2.git_checkout_progress_cb(from);
            
            public static bool operator ==(git_checkout_progress_cb left, git_checkout_progress_cb right) => left.Equals(right);
            
            public static bool operator !=(git_checkout_progress_cb left, git_checkout_progress_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Checkout perfdata notification function
        /// </summary>
        public readonly partial struct git_checkout_perfdata_cb : IEquatable<libgit2.git_checkout_perfdata_cb>
        {
            public git_checkout_perfdata_cb(delegate*unmanaged[Cdecl]<libgit2.git_checkout_perfdata*, void*, void> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_checkout_perfdata*, void*, void> Value { get; }
            
            public override bool Equals(object obj) => obj is git_checkout_perfdata_cb other && Equals(other);
            
            public bool Equals(git_checkout_perfdata_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_checkout_perfdata*, void*, void> (libgit2.git_checkout_perfdata_cb from) => from.Value;
            
            public static implicit operator libgit2.git_checkout_perfdata_cb (delegate*unmanaged[Cdecl]<libgit2.git_checkout_perfdata*, void*, void> from) => new libgit2.git_checkout_perfdata_cb(from);
            
            public static bool operator ==(git_checkout_perfdata_cb left, git_checkout_perfdata_cb right) => left.Equals(right);
            
            public static bool operator !=(git_checkout_perfdata_cb left, git_checkout_perfdata_cb right) => !left.Equals(right);
        }
        
        public const uint GIT_CHECKOUT_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// Initialize git_checkout_options structure
        /// </summary>
        /// <param name="opts">The `git_checkout_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_checkout_options` with default values. Equivalent to creating
        /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_checkout_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_checkout_options_init(out libgit2.git_checkout_options opts, uint version);
        
        /// <summary>
        /// Updates files in the index and the working tree to match the content of
        /// the commit pointed at by HEAD.
        /// </summary>
        /// <param name="repo">repository to check out (must be non-bare)</param>
        /// <param name="opts">specifies checkout options (may be NULL)</param>
        /// <returns>@return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
        /// existing branch, non-zero value returned by `notify_cb`, or
        /// other error code 
        /// &lt;
        /// 0 (use git_error_last for error details)</returns>
        /// <remarks>
        /// Note that this is _not_ the correct mechanism used to switch branches;
        /// do not change your `HEAD` and then call this method, that would leave
        /// you with checkout conflicts since your working directory would then
        /// appear to be dirty.  Instead, checkout the target of the branch and
        /// then update `HEAD` using `git_repository_set_head` to point to the
        /// branch you checked out.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_checkout_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_checkout_head(libgit2.git_repository repo, in libgit2.git_checkout_options opts);
        
        /// <summary>
        /// Updates files in the working tree to match the content of the index.
        /// </summary>
        /// <param name="repo">repository into which to check out (must be non-bare)</param>
        /// <param name="index">index to be checked out (or NULL to use repository index)</param>
        /// <param name="opts">specifies checkout options (may be NULL)</param>
        /// <returns>@return 0 on success, non-zero return value from `notify_cb`, or error
        /// code 
        /// &lt;
        /// 0 (use git_error_last for error details)</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_checkout_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_checkout_index(libgit2.git_repository repo, libgit2.git_index index, in libgit2.git_checkout_options opts);
        
        /// <summary>
        /// Updates files in the index and working tree to match the content of the
        /// tree pointed at by the treeish.
        /// </summary>
        /// <param name="repo">repository to check out (must be non-bare)</param>
        /// <param name="treeish">a commit, tag or tree which content will be used to update
        /// the working directory (or NULL to use HEAD)</param>
        /// <param name="opts">specifies checkout options (may be NULL)</param>
        /// <returns>@return 0 on success, non-zero return value from `notify_cb`, or error
        /// code 
        /// &lt;
        /// 0 (use git_error_last for error details)</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_checkout_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_checkout_tree(libgit2.git_repository repo, libgit2.git_object treeish, in libgit2.git_checkout_options opts);
    }
}
