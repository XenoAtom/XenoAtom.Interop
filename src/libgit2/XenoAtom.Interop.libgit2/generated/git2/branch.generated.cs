//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Iterator type for branches
        /// </summary>
        public readonly partial struct git_branch_iterator : IEquatable<git_branch_iterator>
        {
            public git_branch_iterator(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_branch_iterator other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_branch_iterator other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_branch_iterator left, git_branch_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_branch_iterator left, git_branch_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <param name="out">Pointer where to store the underlying reference.</param>
        /// <param name="repo">the repository to create the branch in.</param>
        /// <param name="branch_name">Name for the branch; this name is
        /// validated for consistency. It should also not conflict with
        /// an already existing branch name.</param>
        /// <param name="target">Commit to which this branch should point. This object
        /// must belong to the given `repo`.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC or an error code.
        /// A proper reference is written in the refs/heads namespace
        /// pointing to the provided target commit.</returns>
        /// <remarks>
        /// A new direct reference will be created pointing to
        /// this target commit. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The returned reference must be freed by the user.The branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_create(out libgit2.git_reference @out, libgit2.git_repository repo, byte* branch_name, libgit2.git_commit target, int force);
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <param name="out">Pointer where to store the underlying reference.</param>
        /// <param name="repo">the repository to create the branch in.</param>
        /// <param name="branch_name">Name for the branch; this name is
        /// validated for consistency. It should also not conflict with
        /// an already existing branch name.</param>
        /// <param name="target">Commit to which this branch should point. This object
        /// must belong to the given `repo`.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC or an error code.
        /// A proper reference is written in the refs/heads namespace
        /// pointing to the provided target commit.</returns>
        /// <remarks>
        /// A new direct reference will be created pointing to
        /// this target commit. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The returned reference must be freed by the user.The branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_create(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> branch_name, libgit2.git_commit target, int force);
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <remarks>
        /// This behaves like `git_branch_create()` but takes an annotated
        /// commit, which lets you specify which extended sha syntax string was
        /// specified by a user, allowing for more exact reflog messages.See the documentation for `git_branch_create()`.
        /// </remarks>
        /// <seealso cref="git_branch_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_create_from_annotated")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_branch_create_from_annotated(ref libgit2.git_reference ref_out, libgit2.git_repository repository, byte* branch_name, libgit2.git_annotated_commit commit, int force);
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <remarks>
        /// This behaves like `git_branch_create()` but takes an annotated
        /// commit, which lets you specify which extended sha syntax string was
        /// specified by a user, allowing for more exact reflog messages.See the documentation for `git_branch_create()`.
        /// </remarks>
        /// <seealso cref="git_branch_create"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_create_from_annotated")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_branch_create_from_annotated(ref libgit2.git_reference ref_out, libgit2.git_repository repository, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> branch_name, libgit2.git_annotated_commit commit, int force);
        
        /// <summary>
        /// Delete an existing branch reference.
        /// </summary>
        /// <param name="branch">A valid reference representing a branch</param>
        /// <returns>@return 0 on success, or an error code.</returns>
        /// <remarks>
        /// Note that if the deletion succeeds, the reference object will not
        /// be valid anymore, and should be freed immediately by the user using
        /// `git_reference_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_delete(libgit2.git_reference branch);
        
        /// <summary>
        /// Create an iterator which loops over the requested branches.
        /// </summary>
        /// <param name="out">the iterator</param>
        /// <param name="repo">Repository where to find the branches.</param>
        /// <param name="list_flags">Filtering flags for the branch
        /// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
        /// or GIT_BRANCH_ALL.</param>
        /// <returns>@return 0 on success  or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_iterator_new(out libgit2.git_branch_iterator @out, libgit2.git_repository repo, libgit2.git_branch_t list_flags);
        
        /// <summary>
        /// Retrieve the next branch from the iterator
        /// </summary>
        /// <param name="out">the reference</param>
        /// <param name="out_type">the type of branch (local or remote-tracking)</param>
        /// <param name="iter">the branch iterator</param>
        /// <returns>@return 0 on success, GIT_ITEROVER if there are no more branches or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_next(out libgit2.git_reference @out, out libgit2.git_branch_t out_type, libgit2.git_branch_iterator iter);
        
        /// <summary>
        /// Free a branch iterator
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_branch_iterator_free(libgit2.git_branch_iterator iter);
        
        /// <summary>
        /// Move/rename an existing local branch reference.
        /// </summary>
        /// <param name="out">New reference object for the updated name.</param>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <param name="new_branch_name">Target name of the branch once the move
        /// is performed; this name is validated for consistency.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The new branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.Note that if the move succeeds, the old reference object will not
        /// be valid anymore, and should be freed immediately by the user using
        /// `git_reference_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_move")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_move(out libgit2.git_reference @out, libgit2.git_reference branch, byte* new_branch_name, int force);
        
        /// <summary>
        /// Move/rename an existing local branch reference.
        /// </summary>
        /// <param name="out">New reference object for the updated name.</param>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <param name="new_branch_name">Target name of the branch once the move
        /// is performed; this name is validated for consistency.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The new branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.Note that if the move succeeds, the old reference object will not
        /// be valid anymore, and should be freed immediately by the user using
        /// `git_reference_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_move")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_move(out libgit2.git_reference @out, libgit2.git_reference branch, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> new_branch_name, int force);
        
        /// <summary>
        /// Lookup a branch by its name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up branch reference</param>
        /// <param name="repo">the repository to look up the branch</param>
        /// <param name="branch_name">Name of the branch to be looked-up;
        /// this name is validated for consistency.</param>
        /// <param name="branch_type">Type of the considered branch. This should
        /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND when no matching branch
        /// exists, GIT_EINVALIDSPEC, otherwise an error code.</returns>
        /// <remarks>
        /// The generated reference must be freed by the user.
        /// The branch name will be checked for validity.
        /// </remarks>
        /// <seealso cref="git_tag_create for rules about valid names."/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_lookup(out libgit2.git_reference @out, libgit2.git_repository repo, byte* branch_name, libgit2.git_branch_t branch_type);
        
        /// <summary>
        /// Lookup a branch by its name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up branch reference</param>
        /// <param name="repo">the repository to look up the branch</param>
        /// <param name="branch_name">Name of the branch to be looked-up;
        /// this name is validated for consistency.</param>
        /// <param name="branch_type">Type of the considered branch. This should
        /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND when no matching branch
        /// exists, GIT_EINVALIDSPEC, otherwise an error code.</returns>
        /// <remarks>
        /// The generated reference must be freed by the user.
        /// The branch name will be checked for validity.
        /// </remarks>
        /// <seealso cref="git_tag_create for rules about valid names."/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_lookup(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> branch_name, libgit2.git_branch_t branch_type);
        
        /// <summary>
        /// Get the branch name
        /// </summary>
        /// <param name="out">Pointer to the abbreviated reference name.
        /// Owned by ref, do not free.</param>
        /// <param name="ref">A reference object, ideally pointing to a branch</param>
        /// <returns>@return 0 on success; GIT_EINVALID if the reference isn't either a local or
        /// remote branch, otherwise an error code.</returns>
        /// <remarks>
        /// Given a reference object, this will check that it really is a branch (ie.
        /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
        /// of it.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_name(out byte* @out, libgit2.git_reference @ref);
        
        /// <summary>
        /// Get the upstream of a branch
        /// </summary>
        /// <param name="out">Pointer where to store the retrieved reference.</param>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND when no remote tracking
        /// reference exists, otherwise an error code.</returns>
        /// <remarks>
        /// Given a reference, this will return a new reference object corresponding
        /// to its remote tracking branch. The reference must be a local branch.
        /// </remarks>
        /// <seealso cref="git_branch_upstream_name for details on the resolution."/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream(out libgit2.git_reference @out, libgit2.git_reference branch);
        
        /// <summary>
        /// Set a branch's upstream branch
        /// </summary>
        /// <param name="branch">the branch to configure</param>
        /// <param name="branch_name">remote-tracking or local branch to set as upstream.</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
        /// or an error code</returns>
        /// <remarks>
        /// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
        /// Pass a NULL name to unset the upstream information.
        /// </remarks>
        /// <note>
        /// @note the actual tracking reference must have been already created for the
        /// operation to succeed.
        /// </note>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_set_upstream")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_set_upstream(libgit2.git_reference branch, byte* branch_name);
        
        /// <summary>
        /// Set a branch's upstream branch
        /// </summary>
        /// <param name="branch">the branch to configure</param>
        /// <param name="branch_name">remote-tracking or local branch to set as upstream.</param>
        /// <returns>@return 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
        /// or an error code</returns>
        /// <remarks>
        /// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
        /// Pass a NULL name to unset the upstream information.
        /// </remarks>
        /// <note>
        /// @note the actual tracking reference must have been already created for the
        /// operation to succeed.
        /// </note>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_set_upstream")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_set_upstream(libgit2.git_reference branch, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> branch_name);
        
        /// <summary>
        /// Get the upstream name of a branch
        /// </summary>
        /// <param name="out">the buffer into which the name will be written.</param>
        /// <param name="repo">the repository where the branches live.</param>
        /// <param name="refname">reference name of the local branch.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
        /// or an error code.</returns>
        /// <remarks>
        /// Given a local branch, this will return its remote-tracking branch information,
        /// as a full reference name, ie. "feature/nice" would become
        /// "refs/remote/origin/feature/nice", depending on that branch's configuration.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_name(out libgit2.git_buf @out, libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Get the upstream name of a branch
        /// </summary>
        /// <param name="out">the buffer into which the name will be written.</param>
        /// <param name="repo">the repository where the branches live.</param>
        /// <param name="refname">reference name of the local branch.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
        /// or an error code.</returns>
        /// <remarks>
        /// Given a local branch, this will return its remote-tracking branch information,
        /// as a full reference name, ie. "feature/nice" would become
        /// "refs/remote/origin/feature/nice", depending on that branch's configuration.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_name(out libgit2.git_buf @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refname);
        
        /// <summary>
        /// Determine if HEAD points to the given branch
        /// </summary>
        /// <param name="branch">A reference to a local branch.</param>
        /// <returns>@return 1 if HEAD points at the branch, 0 if it isn't, or a negative value
        /// as an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_is_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_branch_is_head(libgit2.git_reference branch);
        
        /// <summary>
        /// Determine if any HEAD points to the current branch
        /// </summary>
        /// <param name="branch">A reference to a local branch.</param>
        /// <returns>@return 1 if branch is checked out, 0 if it isn't, an error code otherwise.</returns>
        /// <remarks>
        /// This will iterate over all known linked repositories (usually in the form of
        /// worktrees) and report whether any HEAD is pointing at the current branch.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_is_checked_out")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_branch_is_checked_out(libgit2.git_reference branch);
        
        /// <summary>
        /// Find the remote name of a remote-tracking branch
        /// </summary>
        /// <param name="out">The buffer into which the name will be written.</param>
        /// <param name="repo">The repository where the branch lives.</param>
        /// <param name="refname">complete name of the remote tracking branch.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND when no matching remote was found,
        /// GIT_EAMBIGUOUS when the branch maps to several remotes,
        /// otherwise an error code.</returns>
        /// <remarks>
        /// This will return the name of the remote whose fetch refspec is matching
        /// the given branch. E.g. given a branch "refs/remotes/test/master", it will
        /// extract the "test" part. If refspecs from multiple remotes match,
        /// the function will return GIT_EAMBIGUOUS.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_remote_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_remote_name(out libgit2.git_buf @out, libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Find the remote name of a remote-tracking branch
        /// </summary>
        /// <param name="out">The buffer into which the name will be written.</param>
        /// <param name="repo">The repository where the branch lives.</param>
        /// <param name="refname">complete name of the remote tracking branch.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND when no matching remote was found,
        /// GIT_EAMBIGUOUS when the branch maps to several remotes,
        /// otherwise an error code.</returns>
        /// <remarks>
        /// This will return the name of the remote whose fetch refspec is matching
        /// the given branch. E.g. given a branch "refs/remotes/test/master", it will
        /// extract the "test" part. If refspecs from multiple remotes match,
        /// the function will return GIT_EAMBIGUOUS.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_remote_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_remote_name(out libgit2.git_buf @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refname);
        
        /// <summary>
        /// Retrieve the upstream remote of a local branch
        /// </summary>
        /// <param name="buf">the buffer into which to write the name</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="refname">the full name of the branch</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will return the currently configured "branch.*.remote" for a given
        /// branch. This branch must be local.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_remote")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_remote(ref libgit2.git_buf buf, libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Retrieve the upstream remote of a local branch
        /// </summary>
        /// <param name="buf">the buffer into which to write the name</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="refname">the full name of the branch</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will return the currently configured "branch.*.remote" for a given
        /// branch. This branch must be local.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_remote")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_remote(ref libgit2.git_buf buf, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refname);
        
        /// <summary>
        /// Retrieve the upstream merge of a local branch
        /// </summary>
        /// <param name="buf">the buffer into which to write the name</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="refname">the full name of the branch</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will return the currently configured "branch.*.merge" for a given
        /// branch. This branch must be local.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_merge")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_merge(ref libgit2.git_buf buf, libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Retrieve the upstream merge of a local branch
        /// </summary>
        /// <param name="buf">the buffer into which to write the name</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="refname">the full name of the branch</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This will return the currently configured "branch.*.merge" for a given
        /// branch. This branch must be local.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_upstream_merge")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_upstream_merge(ref libgit2.git_buf buf, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refname);
        
        /// <summary>
        /// Determine whether a branch name is valid, meaning that (when prefixed
        /// with `refs/heads/`) that it is a valid reference name, and that any
        /// additional branch name restrictions are imposed (eg, it cannot start
        /// with a `-`).
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given branch name</param>
        /// <param name="name">a branch name to test</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_name_is_valid(out int valid, byte* name);
        
        /// <summary>
        /// Determine whether a branch name is valid, meaning that (when prefixed
        /// with `refs/heads/`) that it is a valid reference name, and that any
        /// additional branch name restrictions are imposed (eg, it cannot start
        /// with a `-`).
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given branch name</param>
        /// <param name="name">a branch name to test</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_branch_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_branch_name_is_valid(out int valid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
    }
}
