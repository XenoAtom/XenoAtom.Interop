//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Read the reflog for the given reference
        /// </summary>
        /// <param name="out">pointer to reflog</param>
        /// <param name="repo">the repository</param>
        /// <param name="name">reference to look up</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// If there is no reflog file for the given
        /// reference yet, an empty reflog object will
        /// be returned.The reflog must be freed manually by using
        /// git_reflog_free().
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_read(out libgit2.git_reflog @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Read the reflog for the given reference
        /// </summary>
        /// <param name="out">pointer to reflog</param>
        /// <param name="repo">the repository</param>
        /// <param name="name">reference to look up</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// If there is no reflog file for the given
        /// reference yet, an empty reflog object will
        /// be returned.The reflog must be freed manually by using
        /// git_reflog_free().
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_read")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_read(out libgit2.git_reflog @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Write an existing in-memory reflog object back to disk
        /// using an atomic file lock.
        /// </summary>
        /// <param name="reflog">an existing reflog object</param>
        /// <returns>0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_write")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_write(libgit2.git_reflog reflog);
        
        /// <summary>
        /// Add a new entry to the in-memory reflog.
        /// </summary>
        /// <param name="reflog">an existing reflog object</param>
        /// <param name="id">the OID the reference is now pointing to</param>
        /// <param name="committer">the signature of the committer</param>
        /// <param name="msg">the reflog message</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// `msg` is optional and can be NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_append")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_append(libgit2.git_reflog reflog, in libgit2.git_oid id, in libgit2.git_signature committer, byte* msg);
        
        /// <summary>
        /// Add a new entry to the in-memory reflog.
        /// </summary>
        /// <param name="reflog">an existing reflog object</param>
        /// <param name="id">the OID the reference is now pointing to</param>
        /// <param name="committer">the signature of the committer</param>
        /// <param name="msg">the reflog message</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// `msg` is optional and can be NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_append")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_append(libgit2.git_reflog reflog, in libgit2.git_oid id, in libgit2.git_signature committer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> msg);
        
        /// <summary>
        /// Rename a reflog
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="old_name">the old name of the reference</param>
        /// <param name="name">the new name of the reference</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The reflog to be renamed is expected to already existThe new name will be checked for validity.
        /// See `git_reference_create_symbolic()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_rename(libgit2.git_repository repo, byte* old_name, byte* name);
        
        /// <summary>
        /// Rename a reflog
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="old_name">the old name of the reference</param>
        /// <param name="name">the new name of the reference</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The reflog to be renamed is expected to already existThe new name will be checked for validity.
        /// See `git_reference_create_symbolic()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_rename")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_rename(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> old_name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Delete the reflog for the given reference
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="name">the reflog to delete</param>
        /// <returns>0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_delete(libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Delete the reflog for the given reference
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="name">the reflog to delete</param>
        /// <returns>0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_delete(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the number of log entries in a reflog
        /// </summary>
        /// <param name="reflog">the previously loaded reflog</param>
        /// <returns>the number of log entries</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entrycount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial nuint git_reflog_entrycount(libgit2.git_reflog reflog);
        
        /// <summary>
        /// Lookup an entry by its index
        /// </summary>
        /// <param name="reflog">a previously loaded reflog</param>
        /// <param name="idx">the position of the entry to lookup. Should be greater than or
        /// equal to 0 (zero) and less than `git_reflog_entrycount()`.</param>
        /// <returns>the entry; NULL if not found</returns>
        /// <remarks>
        /// Requesting the reflog entry with an index of 0 (zero) will
        /// return the most recently created entry.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_byindex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_reflog_entry git_reflog_entry_byindex(libgit2.git_reflog reflog, nuint idx);
        
        /// <summary>
        /// Remove an entry from the reflog by its index
        /// </summary>
        /// <param name="reflog">a previously loaded reflog.</param>
        /// <param name="idx">the position of the entry to remove. Should be greater than or
        /// equal to 0 (zero) and less than `git_reflog_entrycount()`.</param>
        /// <param name="rewrite_previous_entry">1 to rewrite the history; 0 otherwise.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if the entry doesn't exist
        /// or an error code.</returns>
        /// <remarks>
        /// To ensure there's no gap in the log history, set `rewrite_previous_entry`
        /// param value to 1. When deleting entry `n`, member old_oid of entry `n-1`
        /// (if any) will be updated with the value of member new_oid of entry `n+1`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_drop")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_reflog_drop(libgit2.git_reflog reflog, nuint idx, int rewrite_previous_entry);
        
        /// <summary>
        /// Get the old oid
        /// </summary>
        /// <param name="entry">a reflog entry</param>
        /// <returns>the old oid</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_id_old")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_reflog_entry_id_old(libgit2.git_reflog_entry entry);
        
        /// <summary>
        /// Get the new oid
        /// </summary>
        /// <param name="entry">a reflog entry</param>
        /// <returns>the new oid at this time</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_id_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_reflog_entry_id_new(libgit2.git_reflog_entry entry);
        
        /// <summary>
        /// Get the committer of this entry
        /// </summary>
        /// <param name="entry">a reflog entry</param>
        /// <returns>the committer</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_committer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_reflog_entry_committer(libgit2.git_reflog_entry entry);
        
        /// <summary>
        /// Get the log message
        /// </summary>
        /// <param name="entry">a reflog entry</param>
        /// <returns>the log msg</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_reflog_entry_message_(libgit2.git_reflog_entry entry);
        
        /// <summary>
        /// Get the log message
        /// </summary>
        /// <param name="entry">a reflog entry</param>
        /// <returns>the log msg</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_entry_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_reflog_entry_message(libgit2.git_reflog_entry entry);
        
        /// <summary>
        /// Free the reflog
        /// </summary>
        /// <param name="reflog">reflog to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_reflog_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_reflog_free(libgit2.git_reflog reflog);
    }
}
