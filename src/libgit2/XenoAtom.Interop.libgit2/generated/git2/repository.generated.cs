//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Option flags for `git_repository_open_ext`.
        /// </summary>
        [Flags]
        public enum git_repository_open_flag_t : uint
        {
            /// <summary>
            /// Only open the repository if it can be immediately found in the
            /// start_path. Do not walk up from the start_path looking at parent
            /// directories.
            /// </summary>
            GIT_REPOSITORY_OPEN_NO_SEARCH = unchecked((uint)1),
            
            /// <summary>
            /// Unless this flag is set, open will not continue searching across
            /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
            /// system call).  For example, searching in a user's home directory at
            /// "/home/user/source/" will not return "/.git/" as the found repo if
            /// "/" is a different filesystem than "/home".
            /// </summary>
            GIT_REPOSITORY_OPEN_CROSS_FS = unchecked((uint)2),
            
            /// <summary>
            /// Open repository as a bare repo regardless of core.bare config, and
            /// defer loading config file for faster setup.
            /// Unlike `git_repository_open_bare`, this can follow gitlinks.
            /// </summary>
            GIT_REPOSITORY_OPEN_BARE = unchecked((uint)4),
            
            /// <summary>
            /// Do not check for a repository by appending /.git to the start_path;
            /// only open the repository if start_path itself points to the git
            /// directory.
            /// </summary>
            GIT_REPOSITORY_OPEN_NO_DOTGIT = unchecked((uint)8),
            
            /// <summary>
            /// Find and open a git repository, respecting the environment variables
            /// used by the git command-line tools.
            /// If set, `git_repository_open_ext` will ignore the other flags and
            /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
            /// `GIT_DIR` or search from the current directory.
            /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
            /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
            /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
            /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
            /// In the future, this flag will also cause `git_repository_open_ext`
            /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
            /// `git_repository_open_ext` with this flag will error out if either
            /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
            /// </summary>
            GIT_REPOSITORY_OPEN_FROM_ENV = unchecked((uint)16),
        }
        
        /// <summary>
        /// Only open the repository if it can be immediately found in the
        /// start_path. Do not walk up from the start_path looking at parent
        /// directories.
        /// </summary>
        public const libgit2.git_repository_open_flag_t GIT_REPOSITORY_OPEN_NO_SEARCH = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_NO_SEARCH;
        
        /// <summary>
        /// Unless this flag is set, open will not continue searching across
        /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
        /// system call).  For example, searching in a user's home directory at
        /// "/home/user/source/" will not return "/.git/" as the found repo if
        /// "/" is a different filesystem than "/home".
        /// </summary>
        public const libgit2.git_repository_open_flag_t GIT_REPOSITORY_OPEN_CROSS_FS = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_CROSS_FS;
        
        /// <summary>
        /// Open repository as a bare repo regardless of core.bare config, and
        /// defer loading config file for faster setup.
        /// Unlike `git_repository_open_bare`, this can follow gitlinks.
        /// </summary>
        public const libgit2.git_repository_open_flag_t GIT_REPOSITORY_OPEN_BARE = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_BARE;
        
        /// <summary>
        /// Do not check for a repository by appending /.git to the start_path;
        /// only open the repository if start_path itself points to the git
        /// directory.
        /// </summary>
        public const libgit2.git_repository_open_flag_t GIT_REPOSITORY_OPEN_NO_DOTGIT = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_NO_DOTGIT;
        
        /// <summary>
        /// Find and open a git repository, respecting the environment variables
        /// used by the git command-line tools.
        /// If set, `git_repository_open_ext` will ignore the other flags and
        /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
        /// `GIT_DIR` or search from the current directory.
        /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
        /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
        /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
        /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
        /// In the future, this flag will also cause `git_repository_open_ext`
        /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
        /// `git_repository_open_ext` with this flag will error out if either
        /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
        /// </summary>
        public const libgit2.git_repository_open_flag_t GIT_REPOSITORY_OPEN_FROM_ENV = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_FROM_ENV;
        
        /// <summary>
        /// Option flags for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// These flags configure extra behaviors to `git_repository_init_ext`.
        /// In every case, the default behavior is the zero value (i.e. flag is
        /// not set). Just OR the flag values together for the `flags` parameter
        /// when initializing a new repo.
        /// </remarks>
        [Flags]
        public enum git_repository_init_flag_t : uint
        {
            /// <summary>
            /// Create a bare repository with no working directory.
            /// </summary>
            GIT_REPOSITORY_INIT_BARE = unchecked((uint)1),
            
            /// <summary>
            /// Return an GIT_EEXISTS error if the repo_path appears to already be
            /// an git repository.
            /// </summary>
            GIT_REPOSITORY_INIT_NO_REINIT = unchecked((uint)2),
            
            /// <summary>
            /// Normally a "/.git/" will be appended to the repo path for
            /// non-bare repos (if it is not already there), but passing this flag
            /// prevents that behavior.
            /// </summary>
            GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = unchecked((uint)4),
            
            /// <summary>
            /// Make the repo_path (and workdir_path) as needed. Init is always willing
            /// to create the ".git" directory even without this flag. This flag tells
            /// init to create the trailing component of the repo and workdir paths
            /// as needed.
            /// </summary>
            GIT_REPOSITORY_INIT_MKDIR = unchecked((uint)8),
            
            /// <summary>
            /// Recursively make all components of the repo and workdir paths as
            /// necessary.
            /// </summary>
            GIT_REPOSITORY_INIT_MKPATH = unchecked((uint)16),
            
            /// <summary>
            /// libgit2 normally uses internal templates to initialize a new repo.
            /// This flags enables external templates, looking the "template_path" from
            /// the options if set, or the `init.templatedir` global config if not,
            /// or falling back on "/usr/share/git-core/templates" if it exists.
            /// </summary>
            GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = unchecked((uint)32),
            
            /// <summary>
            /// If an alternate workdir is specified, use relative paths for the gitdir
            /// and core.worktree.
            /// </summary>
            GIT_REPOSITORY_INIT_RELATIVE_GITLINK = unchecked((uint)64),
        }
        
        /// <summary>
        /// Create a bare repository with no working directory.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_BARE = git_repository_init_flag_t.GIT_REPOSITORY_INIT_BARE;
        
        /// <summary>
        /// Return an GIT_EEXISTS error if the repo_path appears to already be
        /// an git repository.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_NO_REINIT = git_repository_init_flag_t.GIT_REPOSITORY_INIT_NO_REINIT;
        
        /// <summary>
        /// Normally a "/.git/" will be appended to the repo path for
        /// non-bare repos (if it is not already there), but passing this flag
        /// prevents that behavior.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = git_repository_init_flag_t.GIT_REPOSITORY_INIT_NO_DOTGIT_DIR;
        
        /// <summary>
        /// Make the repo_path (and workdir_path) as needed. Init is always willing
        /// to create the ".git" directory even without this flag. This flag tells
        /// init to create the trailing component of the repo and workdir paths
        /// as needed.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_MKDIR = git_repository_init_flag_t.GIT_REPOSITORY_INIT_MKDIR;
        
        /// <summary>
        /// Recursively make all components of the repo and workdir paths as
        /// necessary.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_MKPATH = git_repository_init_flag_t.GIT_REPOSITORY_INIT_MKPATH;
        
        /// <summary>
        /// libgit2 normally uses internal templates to initialize a new repo.
        /// This flags enables external templates, looking the "template_path" from
        /// the options if set, or the `init.templatedir` global config if not,
        /// or falling back on "/usr/share/git-core/templates" if it exists.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = git_repository_init_flag_t.GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE;
        
        /// <summary>
        /// If an alternate workdir is specified, use relative paths for the gitdir
        /// and core.worktree.
        /// </summary>
        public const libgit2.git_repository_init_flag_t GIT_REPOSITORY_INIT_RELATIVE_GITLINK = git_repository_init_flag_t.GIT_REPOSITORY_INIT_RELATIVE_GITLINK;
        
        /// <summary>
        /// Mode options for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// Set the mode field of the `git_repository_init_options` structure
        /// either to the custom mode that you would like, or to one of the
        /// defined modes.
        /// </remarks>
        public enum git_repository_init_mode_t : uint
        {
            /// <summary>
            /// Use permissions configured by umask - the default.
            /// </summary>
            GIT_REPOSITORY_INIT_SHARED_UMASK = unchecked((uint)0),
            
            /// <summary>
            /// Use "--shared=group" behavior, chmod'ing the new repo to be group
            /// writable and "g+sx" for sticky group assignment.
            /// </summary>
            GIT_REPOSITORY_INIT_SHARED_GROUP = unchecked((uint)1533),
            
            /// <summary>
            /// Use "--shared=all" behavior, adding world readability.
            /// </summary>
            GIT_REPOSITORY_INIT_SHARED_ALL = unchecked((uint)1535),
        }
        
        /// <summary>
        /// Use permissions configured by umask - the default.
        /// </summary>
        public const libgit2.git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_UMASK = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_UMASK;
        
        /// <summary>
        /// Use "--shared=group" behavior, chmod'ing the new repo to be group
        /// writable and "g+sx" for sticky group assignment.
        /// </summary>
        public const libgit2.git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_GROUP = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_GROUP;
        
        /// <summary>
        /// Use "--shared=all" behavior, adding world readability.
        /// </summary>
        public const libgit2.git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_ALL = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_ALL;
        
        /// <summary>
        /// List of items which belong to the git repository layout
        /// </summary>
        public enum git_repository_item_t : uint
        {
            GIT_REPOSITORY_ITEM_GITDIR = unchecked((uint)0),
            
            GIT_REPOSITORY_ITEM_WORKDIR = unchecked((uint)1),
            
            GIT_REPOSITORY_ITEM_COMMONDIR = unchecked((uint)2),
            
            GIT_REPOSITORY_ITEM_INDEX = unchecked((uint)3),
            
            GIT_REPOSITORY_ITEM_OBJECTS = unchecked((uint)4),
            
            GIT_REPOSITORY_ITEM_REFS = unchecked((uint)5),
            
            GIT_REPOSITORY_ITEM_PACKED_REFS = unchecked((uint)6),
            
            GIT_REPOSITORY_ITEM_REMOTES = unchecked((uint)7),
            
            GIT_REPOSITORY_ITEM_CONFIG = unchecked((uint)8),
            
            GIT_REPOSITORY_ITEM_INFO = unchecked((uint)9),
            
            GIT_REPOSITORY_ITEM_HOOKS = unchecked((uint)10),
            
            GIT_REPOSITORY_ITEM_LOGS = unchecked((uint)11),
            
            GIT_REPOSITORY_ITEM_MODULES = unchecked((uint)12),
            
            GIT_REPOSITORY_ITEM_WORKTREES = unchecked((uint)13),
            
            GIT_REPOSITORY_ITEM__LAST = unchecked((uint)14),
        }
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_GITDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_GITDIR;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_WORKDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_WORKDIR;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_COMMONDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_COMMONDIR;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_INDEX = git_repository_item_t.GIT_REPOSITORY_ITEM_INDEX;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_OBJECTS = git_repository_item_t.GIT_REPOSITORY_ITEM_OBJECTS;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_REFS = git_repository_item_t.GIT_REPOSITORY_ITEM_REFS;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_PACKED_REFS = git_repository_item_t.GIT_REPOSITORY_ITEM_PACKED_REFS;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_REMOTES = git_repository_item_t.GIT_REPOSITORY_ITEM_REMOTES;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_CONFIG = git_repository_item_t.GIT_REPOSITORY_ITEM_CONFIG;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_INFO = git_repository_item_t.GIT_REPOSITORY_ITEM_INFO;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_HOOKS = git_repository_item_t.GIT_REPOSITORY_ITEM_HOOKS;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_LOGS = git_repository_item_t.GIT_REPOSITORY_ITEM_LOGS;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_MODULES = git_repository_item_t.GIT_REPOSITORY_ITEM_MODULES;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM_WORKTREES = git_repository_item_t.GIT_REPOSITORY_ITEM_WORKTREES;
        
        public const libgit2.git_repository_item_t GIT_REPOSITORY_ITEM__LAST = git_repository_item_t.GIT_REPOSITORY_ITEM__LAST;
        
        /// <summary>
        /// Repository state
        /// </summary>
        /// <remarks>
        /// These values represent possible states for the repository to be in,
        /// based on the current operation which is ongoing.
        /// </remarks>
        public enum git_repository_state_t : uint
        {
            GIT_REPOSITORY_STATE_NONE = unchecked((uint)0),
            
            GIT_REPOSITORY_STATE_MERGE = unchecked((uint)1),
            
            GIT_REPOSITORY_STATE_REVERT = unchecked((uint)2),
            
            GIT_REPOSITORY_STATE_REVERT_SEQUENCE = unchecked((uint)3),
            
            GIT_REPOSITORY_STATE_CHERRYPICK = unchecked((uint)4),
            
            GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = unchecked((uint)5),
            
            GIT_REPOSITORY_STATE_BISECT = unchecked((uint)6),
            
            GIT_REPOSITORY_STATE_REBASE = unchecked((uint)7),
            
            GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = unchecked((uint)8),
            
            GIT_REPOSITORY_STATE_REBASE_MERGE = unchecked((uint)9),
            
            GIT_REPOSITORY_STATE_APPLY_MAILBOX = unchecked((uint)10),
            
            GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = unchecked((uint)11),
        }
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_NONE = git_repository_state_t.GIT_REPOSITORY_STATE_NONE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_MERGE = git_repository_state_t.GIT_REPOSITORY_STATE_MERGE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_REVERT = git_repository_state_t.GIT_REPOSITORY_STATE_REVERT;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_REVERT_SEQUENCE = git_repository_state_t.GIT_REPOSITORY_STATE_REVERT_SEQUENCE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_CHERRYPICK = git_repository_state_t.GIT_REPOSITORY_STATE_CHERRYPICK;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = git_repository_state_t.GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_BISECT = git_repository_state_t.GIT_REPOSITORY_STATE_BISECT;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_REBASE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE_INTERACTIVE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_REBASE_MERGE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE_MERGE;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_APPLY_MAILBOX = git_repository_state_t.GIT_REPOSITORY_STATE_APPLY_MAILBOX;
        
        public const libgit2.git_repository_state_t GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = git_repository_state_t.GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE;
        
        /// <summary>
        /// Extended options structure for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// This contains extra options for `git_repository_init_ext` that enable
        /// additional initialization features.
        /// </remarks>
        public partial struct git_repository_init_options
        {
            public uint version;
            
            /// <summary>
            /// Combination of GIT_REPOSITORY_INIT flags above.
            /// </summary>
            public libgit2.git_repository_init_flag_t flags;
            
            /// <summary>
            /// Set to one of the standard GIT_REPOSITORY_INIT_SHARED_... constants
            /// above, or to a custom value that you would like.
            /// </summary>
            public uint mode;
            
            /// <summary>
            /// The path to the working dir or NULL for default (i.e. repo_path parent
            /// on non-bare repos). IF THIS IS RELATIVE PATH, IT WILL BE EVALUATED
            /// RELATIVE TO THE REPO_PATH. If this is not the "natural" working
            /// directory, a .git gitlink file will be created here linking to the
            /// repo_path.
            /// </summary>
            public byte* workdir_path;
            
            /// <summary>
            /// If set, this will be used to initialize the "description" file in the
            /// repository, instead of using the template content.
            /// </summary>
            public byte* description;
            
            /// <summary>
            /// When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set, this contains
            /// the path to use for the template directory. If this is NULL, the config
            /// or default directory options will be used instead.
            /// </summary>
            public byte* template_path;
            
            /// <summary>
            /// The name of the head to point HEAD at. If NULL, then this will be
            /// treated as "master" and the HEAD ref will be set to "refs/heads/master".
            /// If this begins with "refs/" it will be used verbatim;
            /// otherwise "refs/heads/" will be prefixed.
            /// </summary>
            public byte* initial_head;
            
            /// <summary>
            /// If this is non-NULL, then after the rest of the repository
            /// initialization is completed, an "origin" remote will be added
            /// pointing to this URL.
            /// </summary>
            public byte* origin_url;
        }
        
        /// <summary>
        /// Callback used to iterate over each FETCH_HEAD entry
        /// </summary>
        /// <param name="ref_name">The reference name</param>
        /// <param name="remote_url">The remote URL</param>
        /// <param name="oid">The reference target OID</param>
        /// <param name="is_merge">Was the reference the result of a merge</param>
        /// <param name="payload">Payload passed to git_repository_fetchhead_foreach</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_repository_fetchhead_foreach"/>
        public readonly partial struct git_repository_fetchhead_foreach_cb : IEquatable<git_repository_fetchhead_foreach_cb>
        {
            public git_repository_fetchhead_foreach_cb(delegate*unmanaged[Cdecl]<byte*, byte*, libgit2.git_oid*, uint, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, byte*, libgit2.git_oid*, uint, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_repository_fetchhead_foreach_cb other && Equals(other);
            
            public bool Equals(git_repository_fetchhead_foreach_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, byte*, libgit2.git_oid*, uint, void*, int> (libgit2.git_repository_fetchhead_foreach_cb from) => from.Value;
            
            public static implicit operator libgit2.git_repository_fetchhead_foreach_cb (delegate*unmanaged[Cdecl]<byte*, byte*, libgit2.git_oid*, uint, void*, int> from) => new libgit2.git_repository_fetchhead_foreach_cb(from);
            
            public static bool operator ==(git_repository_fetchhead_foreach_cb left, git_repository_fetchhead_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_repository_fetchhead_foreach_cb left, git_repository_fetchhead_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Callback used to iterate over each MERGE_HEAD entry
        /// </summary>
        /// <param name="oid">The merge OID</param>
        /// <param name="payload">Payload passed to git_repository_mergehead_foreach</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_repository_mergehead_foreach"/>
        public readonly partial struct git_repository_mergehead_foreach_cb : IEquatable<git_repository_mergehead_foreach_cb>
        {
            public git_repository_mergehead_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_oid*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_oid*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_repository_mergehead_foreach_cb other && Equals(other);
            
            public bool Equals(git_repository_mergehead_foreach_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_oid*, void*, int> (libgit2.git_repository_mergehead_foreach_cb from) => from.Value;
            
            public static implicit operator libgit2.git_repository_mergehead_foreach_cb (delegate*unmanaged[Cdecl]<libgit2.git_oid*, void*, int> from) => new libgit2.git_repository_mergehead_foreach_cb(from);
            
            public static bool operator ==(git_repository_mergehead_foreach_cb left, git_repository_mergehead_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_repository_mergehead_foreach_cb left, git_repository_mergehead_foreach_cb right) => !left.Equals(right);
        }
        
        public const uint GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// Open a git repository.
        /// </summary>
        /// <param name="out">pointer to the repo which will be opened</param>
        /// <param name="path">the path to the repository</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The 'path' argument must point to either a git repository
        /// folder, or an existing work dir.The method will automatically detect if 'path' is a normal
        /// or bare repository or fail is 'path' is neither.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open(out libgit2.git_repository @out, byte* path);
        
        /// <summary>
        /// Open a git repository.
        /// </summary>
        /// <param name="out">pointer to the repo which will be opened</param>
        /// <param name="path">the path to the repository</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The 'path' argument must point to either a git repository
        /// folder, or an existing work dir.The method will automatically detect if 'path' is a normal
        /// or bare repository or fail is 'path' is neither.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Open working tree as a repository
        /// </summary>
        /// <param name="out">Output pointer containing opened repository</param>
        /// <param name="wt">Working tree to open</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Open the working directory of the working tree as a normal
        /// repository that can then be worked on.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open_from_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open_from_worktree(out libgit2.git_repository @out, libgit2.git_worktree wt);
        
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_wrap_odb")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_wrap_odb(out libgit2.git_repository @out, libgit2.git_odb odb);
        
        /// <summary>
        /// Look for a git repository and copy its path in the given buffer.
        /// The lookup start from base_path and walk across parent directories
        /// if nothing has been found. The lookup ends when the first repository
        /// is found, or when reaching a directory referenced in ceiling_dirs
        /// or when the filesystem changes (in case across_fs is true).
        /// </summary>
        /// <param name="out">A pointer to a user-allocated git_buf which will contain
        /// the found path.</param>
        /// <param name="start_path">The base path where the lookup starts.</param>
        /// <param name="across_fs">If true, then the lookup will not stop when a
        /// filesystem device change is detected while exploring parent directories.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR separated list of
        /// absolute symbolic link free paths. The lookup will stop when any
        /// of this paths is reached. Note that the lookup always performs on
        /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
        /// might be NULL (which is equivalent to an empty string)</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The method will automatically detect if the repository is bare
        /// (if there is a repository).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_discover")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_discover(out libgit2.git_buf @out, byte* start_path, int across_fs, byte* ceiling_dirs);
        
        /// <summary>
        /// Look for a git repository and copy its path in the given buffer.
        /// The lookup start from base_path and walk across parent directories
        /// if nothing has been found. The lookup ends when the first repository
        /// is found, or when reaching a directory referenced in ceiling_dirs
        /// or when the filesystem changes (in case across_fs is true).
        /// </summary>
        /// <param name="out">A pointer to a user-allocated git_buf which will contain
        /// the found path.</param>
        /// <param name="start_path">The base path where the lookup starts.</param>
        /// <param name="across_fs">If true, then the lookup will not stop when a
        /// filesystem device change is detected while exploring parent directories.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR separated list of
        /// absolute symbolic link free paths. The lookup will stop when any
        /// of this paths is reached. Note that the lookup always performs on
        /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
        /// might be NULL (which is equivalent to an empty string)</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The method will automatically detect if the repository is bare
        /// (if there is a repository).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_discover")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_discover(out libgit2.git_buf @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> start_path, int across_fs, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> ceiling_dirs);
        
        /// <summary>
        /// Find and open a repository with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.  This can
        /// actually be NULL if you only want to use the error code to
        /// see if a repo at this path could be opened.</param>
        /// <param name="path">Path to open as git repository.  If the flags
        /// permit "searching", then this can be a path to a subdirectory
        /// inside the working directory of the repository. May be NULL if
        /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.</param>
        /// <param name="flags">A combination of the GIT_REPOSITORY_OPEN flags above.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR delimited list of path
        /// prefixes at which the search for a containing repository should
        /// terminate.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if no repository could be found,
        /// or -1 if there was a repository but open failed for some reason
        /// (such as repo corruption or system errors).</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open_ext(out libgit2.git_repository @out, byte* path, libgit2.git_repository_open_flag_t flags, byte* ceiling_dirs);
        
        /// <summary>
        /// Find and open a repository with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.  This can
        /// actually be NULL if you only want to use the error code to
        /// see if a repo at this path could be opened.</param>
        /// <param name="path">Path to open as git repository.  If the flags
        /// permit "searching", then this can be a path to a subdirectory
        /// inside the working directory of the repository. May be NULL if
        /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.</param>
        /// <param name="flags">A combination of the GIT_REPOSITORY_OPEN flags above.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR delimited list of path
        /// prefixes at which the search for a containing repository should
        /// terminate.</param>
        /// <returns>@return 0 on success, GIT_ENOTFOUND if no repository could be found,
        /// or -1 if there was a repository but open failed for some reason
        /// (such as repo corruption or system errors).</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open_ext(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_repository_open_flag_t flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> ceiling_dirs);
        
        /// <summary>
        /// Open a bare repository on the serverside.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.</param>
        /// <param name="bare_path">Direct path to the bare repository</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// This is a fast open for bare repositories that will come in handy
        /// if you're e.g. hosting git repositories and need to access them
        /// efficiently
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open_bare")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open_bare(out libgit2.git_repository @out, byte* bare_path);
        
        /// <summary>
        /// Open a bare repository on the serverside.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.</param>
        /// <param name="bare_path">Direct path to the bare repository</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// This is a fast open for bare repositories that will come in handy
        /// if you're e.g. hosting git repositories and need to access them
        /// efficiently
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_open_bare")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_open_bare(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> bare_path);
        
        /// <summary>
        /// Free a previously allocated repository
        /// </summary>
        /// <param name="repo">repository handle to close. If NULL nothing occurs.</param>
        /// <remarks>
        /// Note that after a repository is free'd, all the objects it has spawned
        /// will still exist until they are manually closed by the user
        /// with `git_object_free`, but accessing any of the attributes of
        /// an object without a backing repository will result in undefined
        /// behavior
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_repository_free(libgit2.git_repository repo);
        
        /// <summary>
        /// Creates a new Git repository in the given folder.
        /// </summary>
        /// <param name="out">pointer to the repo which will be created or reinitialized</param>
        /// <param name="path">the path to the repository</param>
        /// <param name="is_bare">if true, a Git repository without a working directory is
        /// created at the pointed path. If false, provided path will be
        /// considered as the working directory into which the .git directory
        /// will be created.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// TODO:
        /// - Reinit the repository
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_init(out libgit2.git_repository @out, byte* path, uint is_bare);
        
        /// <summary>
        /// Creates a new Git repository in the given folder.
        /// </summary>
        /// <param name="out">pointer to the repo which will be created or reinitialized</param>
        /// <param name="path">the path to the repository</param>
        /// <param name="is_bare">if true, a Git repository without a working directory is
        /// created at the pointed path. If false, provided path will be
        /// considered as the working directory into which the .git directory
        /// will be created.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// TODO:
        /// - Reinit the repository
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_init(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, uint is_bare);
        
        /// <summary>
        /// Initialize git_repository_init_options structure
        /// </summary>
        /// <param name="opts">The `git_repository_init_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_repository_init_options` with default values. Equivalent to
        /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_init_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_init_options_init(out libgit2.git_repository_init_options opts, uint version);
        
        /// <summary>
        /// Create a new Git repository in the given folder with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be created or reinitialized.</param>
        /// <param name="repo_path">The path to the repository.</param>
        /// <param name="opts">Pointer to git_repository_init_options struct.</param>
        /// <returns>@return 0 or an error code on failure.</returns>
        /// <remarks>
        /// This will initialize a new git repository (creating the repo_path
        /// if requested by flags) and working directory as needed.  It will
        /// auto-detect the case sensitivity of the file system and if the
        /// file system supports file mode bits correctly.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_init_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_init_ext(out libgit2.git_repository @out, byte* repo_path, in libgit2.git_repository_init_options opts);
        
        /// <summary>
        /// Create a new Git repository in the given folder with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be created or reinitialized.</param>
        /// <param name="repo_path">The path to the repository.</param>
        /// <param name="opts">Pointer to git_repository_init_options struct.</param>
        /// <returns>@return 0 or an error code on failure.</returns>
        /// <remarks>
        /// This will initialize a new git repository (creating the repo_path
        /// if requested by flags) and working directory as needed.  It will
        /// auto-detect the case sensitivity of the file system and if the
        /// file system supports file mode bits correctly.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_init_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_init_ext(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> repo_path, in libgit2.git_repository_init_options opts);
        
        /// <summary>
        /// Retrieve and resolve the reference pointed at by HEAD.
        /// </summary>
        /// <param name="out">pointer to the reference which will be retrieved</param>
        /// <param name="repo">a repository object</param>
        /// <returns>@return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
        /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise</returns>
        /// <remarks>
        /// The returned `git_reference` will be owned by caller and
        /// `git_reference_free()` must be called when done with it to release the
        /// allocated memory and prevent a leak.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head(out libgit2.git_reference @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Retrieve the referenced HEAD for the worktree
        /// </summary>
        /// <param name="out">pointer to the reference which will be retrieved</param>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>@return 0 when successful, error-code otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_for_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_for_worktree(out libgit2.git_reference @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Retrieve the referenced HEAD for the worktree
        /// </summary>
        /// <param name="out">pointer to the reference which will be retrieved</param>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>@return 0 when successful, error-code otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_for_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_for_worktree(out libgit2.git_reference @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Check if a repository's HEAD is detached
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>@return 1 if HEAD is detached, 0 if it's not; error code if there
        /// was an error.</returns>
        /// <remarks>
        /// A repository's HEAD is detached when it points directly to a commit
        /// instead of a branch.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_detached")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_detached(libgit2.git_repository repo);
        
        /// <summary>
        /// Check if a worktree's HEAD is detached
        /// </summary>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>@return 1 if HEAD is detached, 0 if its not; error code if
        /// there was an error</returns>
        /// <remarks>
        /// A worktree's HEAD is detached when it points directly to a
        /// commit instead of a branch.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_detached_for_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_detached_for_worktree(libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Check if a worktree's HEAD is detached
        /// </summary>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>@return 1 if HEAD is detached, 0 if its not; error code if
        /// there was an error</returns>
        /// <remarks>
        /// A worktree's HEAD is detached when it points directly to a
        /// commit instead of a branch.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_detached_for_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_detached_for_worktree(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Check if the current branch is unborn
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>@return 1 if the current branch is unborn, 0 if it's not; error
        /// code if there was an error</returns>
        /// <remarks>
        /// An unborn branch is one named from HEAD but which doesn't exist in
        /// the refs namespace, because it doesn't have any commit to point to.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_head_unborn")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_head_unborn(libgit2.git_repository repo);
        
        /// <summary>
        /// Check if a repository is empty
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>@return 1 if the repository is empty, 0 if it isn't, error code
        /// if the repository is corrupted</returns>
        /// <remarks>
        /// An empty repository has just been initialized and contains no references
        /// apart from HEAD, which must be pointing to the unborn master branch,
        /// or the branch specified for the repository in the `init.defaultBranch`
        /// configuration variable.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_is_empty")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_is_empty(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the location of a specific repository file or directory
        /// </summary>
        /// <param name="out">Buffer to store the path at</param>
        /// <param name="repo">Repository to get path for</param>
        /// <param name="item">The repository item for which to retrieve the path</param>
        /// <returns>@return 0, GIT_ENOTFOUND if the path cannot exist or an error code</returns>
        /// <remarks>
        /// This function will retrieve the path of a specific repository
        /// item. It will thereby honor things like the repository's
        /// common directory, gitdir, etc. In case a file path cannot
        /// exist for a given item (e.g. the working directory of a bare
        /// repository), GIT_ENOTFOUND is returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_item_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_item_path(out libgit2.git_buf @out, libgit2.git_repository repo, libgit2.git_repository_item_t item);
        
        /// <summary>
        /// Get the path of this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the repository</returns>
        /// <remarks>
        /// This is the path of the `.git` folder for normal repositories,
        /// or of the repository itself for bare repositories.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_repository_path(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the path of this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the repository</returns>
        /// <remarks>
        /// This is the path of the `.git` folder for normal repositories,
        /// or of the repository itself for bare repositories.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_repository_path_string(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the path of the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the working dir, if it exists</returns>
        /// <remarks>
        /// If the repository is bare, this function will always return
        /// NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_repository_workdir(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the path of the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the working dir, if it exists</returns>
        /// <remarks>
        /// If the repository is bare, this function will always return
        /// NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_repository_workdir_string(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the path of the shared common directory for this repository.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the common dir</returns>
        /// <remarks>
        /// If the repository is bare, it is the root directory for the repository.
        /// If the repository is a worktree, it is the parent repo's gitdir.
        /// Otherwise, it is the gitdir.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_commondir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_repository_commondir(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the path of the shared common directory for this repository.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return the path to the common dir</returns>
        /// <remarks>
        /// If the repository is bare, it is the root directory for the repository.
        /// If the repository is a worktree, it is the parent repo's gitdir.
        /// Otherwise, it is the gitdir.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_commondir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_repository_commondir_string(libgit2.git_repository repo);
        
        /// <summary>
        /// Set the path to the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="workdir">The path to a working directory</param>
        /// <param name="update_gitlink">Create/update gitlink in workdir and set config
        /// "core.worktree" (if workdir is not the parent of the .git directory)</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// The working directory doesn't need to be the same one
        /// that contains the `.git` folder for this repository.If this repository is bare, setting its working directory
        /// will turn it into a normal repository, capable of performing
        /// all the common workdir operations (checkout, status, index
        /// manipulation, etc).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_workdir(libgit2.git_repository repo, byte* workdir, int update_gitlink);
        
        /// <summary>
        /// Set the path to the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="workdir">The path to a working directory</param>
        /// <param name="update_gitlink">Create/update gitlink in workdir and set config
        /// "core.worktree" (if workdir is not the parent of the .git directory)</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// The working directory doesn't need to be the same one
        /// that contains the `.git` folder for this repository.If this repository is bare, setting its working directory
        /// will turn it into a normal repository, capable of performing
        /// all the common workdir operations (checkout, status, index
        /// manipulation, etc).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_workdir(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> workdir, int update_gitlink);
        
        /// <summary>
        /// Check if a repository is bare
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>@return 1 if the repository is bare, 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_is_bare")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_is_bare(libgit2.git_repository repo);
        
        /// <summary>
        /// Check if a repository is a linked work tree
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>@return 1 if the repository is a linked work tree, 0 otherwise.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_is_worktree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_is_worktree(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the configuration file for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded configuration</param>
        /// <param name="repo">A repository object</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// If a configuration file has not been set, the default
        /// config set for the repository will be returned, including
        /// global and system configurations (if they are available).The configuration file must be freed once it's no longer
        /// being used by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_config")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_config(out libgit2.git_config @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Get a snapshot of the repository's configuration
        /// </summary>
        /// <param name="out">Pointer to store the loaded configuration</param>
        /// <param name="repo">the repository</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// Convenience function to take a snapshot from the repository's
        /// configuration.  The contents of this snapshot will not change,
        /// even if the underlying config files are modified.The configuration file must be freed once it's no longer
        /// being used by the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_config_snapshot")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_config_snapshot(out libgit2.git_config @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Get the Object Database for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded ODB</param>
        /// <param name="repo">A repository object</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// If a custom ODB has not been set, the default
        /// database for the repository will be returned (the one
        /// located in `.git/objects`).The ODB must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_odb")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_odb(out libgit2.git_odb @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Get the Reference Database Backend for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded refdb</param>
        /// <param name="repo">A repository object</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// If a custom refsdb has not been set, the default database for
        /// the repository will be returned (the one that manipulates loose
        /// and packed references in the `.git` directory).The refdb must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_refdb")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_refdb(out libgit2.git_refdb @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Get the Index file for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded index</param>
        /// <param name="repo">A repository object</param>
        /// <returns>@return 0, or an error code</returns>
        /// <remarks>
        /// If a custom index has not been set, the default
        /// index for the repository will be returned (the one
        /// located in `.git/index`).The index must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_index(out libgit2.git_index @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Retrieve git's prepared message
        /// </summary>
        /// <param name="out">git_buf to write data into</param>
        /// <param name="repo">Repository to read prepared message from</param>
        /// <returns>@return 0, GIT_ENOTFOUND if no message exists or an error code</returns>
        /// <remarks>
        /// Operations such as git revert/cherry-pick/merge with the -n option
        /// stop just short of creating a commit with the changes and save
        /// their prepared message in .git/MERGE_MSG so the next git-commit
        /// execution can present it to the user for them to amend if they
        /// wish.Use this function to get the contents of this file. Don't forget to
        /// remove the file after you create the commit.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_message(out libgit2.git_buf @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Remove git's prepared message.
        /// </summary>
        /// <param name="repo">Repository to remove prepared message from.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Remove the message that `git_repository_message` retrieves.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_message_remove")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_message_remove(libgit2.git_repository repo);
        
        /// <summary>
        /// Remove all the metadata associated with an ongoing command like merge,
        /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>@return 0 on success, or error</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_state_cleanup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_state_cleanup(libgit2.git_repository repo);
        
        /// <summary>
        /// Invoke 'callback' for each entry in the given FETCH_HEAD file.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="callback">Callback function</param>
        /// <param name="payload">Pointer to callback data (optional)</param>
        /// <returns>@return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
        /// there is no FETCH_HEAD file, or other error code.</returns>
        /// <remarks>
        /// Return a non-zero value from the callback to stop the loop.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_fetchhead_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_fetchhead_foreach(libgit2.git_repository repo, libgit2.git_repository_fetchhead_foreach_cb callback, void* payload);
        
        /// <summary>
        /// If a merge is in progress, invoke 'callback' for each commit ID in the
        /// MERGE_HEAD file.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="callback">Callback function</param>
        /// <param name="payload">Pointer to callback data (optional)</param>
        /// <returns>@return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
        /// there is no MERGE_HEAD file, or other error code.</returns>
        /// <remarks>
        /// Return a non-zero value from the callback to stop the loop.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_mergehead_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_mergehead_foreach(libgit2.git_repository repo, libgit2.git_repository_mergehead_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Calculate hash of file using repository filtering rules.
        /// </summary>
        /// <param name="out">Output value of calculated SHA</param>
        /// <param name="repo">Repository pointer</param>
        /// <param name="path">Path to file on disk whose contents should be hashed.  This
        /// may be an absolute path or a relative path, in which case it
        /// will be treated as a path within the working directory.</param>
        /// <param name="type">The object type to hash as (e.g. GIT_OBJECT_BLOB)</param>
        /// <param name="as_path">The path to use to look up filtering rules. If this is
        /// an empty string then no filters will be applied when
        /// calculating the hash. If this is `NULL` and the `path`
        /// parameter is a file within the repository's working
        /// directory, then the `path` will be used.</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// If you simply want to calculate the hash of a file on disk with no filters,
        /// you can just use the `git_odb_hashfile()` API.  However, if you want to
        /// hash a file in the repository and you want to apply filtering rules (e.g.
        /// crlf filters) before generating the SHA, then use this function.Note: if the repository has `core.safecrlf` set to fail and the
        /// filtering triggers that failure, then this function will return an
        /// error and not calculate the hash of the file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_hashfile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_hashfile(out libgit2.git_oid @out, libgit2.git_repository repo, byte* path, libgit2.git_object_t type, byte* as_path);
        
        /// <summary>
        /// Calculate hash of file using repository filtering rules.
        /// </summary>
        /// <param name="out">Output value of calculated SHA</param>
        /// <param name="repo">Repository pointer</param>
        /// <param name="path">Path to file on disk whose contents should be hashed.  This
        /// may be an absolute path or a relative path, in which case it
        /// will be treated as a path within the working directory.</param>
        /// <param name="type">The object type to hash as (e.g. GIT_OBJECT_BLOB)</param>
        /// <param name="as_path">The path to use to look up filtering rules. If this is
        /// an empty string then no filters will be applied when
        /// calculating the hash. If this is `NULL` and the `path`
        /// parameter is a file within the repository's working
        /// directory, then the `path` will be used.</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// If you simply want to calculate the hash of a file on disk with no filters,
        /// you can just use the `git_odb_hashfile()` API.  However, if you want to
        /// hash a file in the repository and you want to apply filtering rules (e.g.
        /// crlf filters) before generating the SHA, then use this function.Note: if the repository has `core.safecrlf` set to fail and the
        /// filtering triggers that failure, then this function will return an
        /// error and not calculate the hash of the file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_hashfile")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_hashfile(out libgit2.git_oid @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_object_t type, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> as_path);
        
        /// <summary>
        /// Make the repository HEAD point to the specified reference.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <param name="refname">Canonical name of the reference the HEAD should point at</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// If the provided reference points to a Tree or a Blob, the HEAD is
        /// unaltered and -1 is returned.If the provided reference points to a branch, the HEAD will point
        /// to that branch, staying attached, or become attached if it isn't yet.
        /// If the branch doesn't exist yet, no error will be return. The HEAD
        /// will then be attached to an unborn branch.Otherwise, the HEAD will be detached and will directly point to
        /// the Commit.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_head(libgit2.git_repository repo, byte* refname);
        
        /// <summary>
        /// Make the repository HEAD point to the specified reference.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <param name="refname">Canonical name of the reference the HEAD should point at</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// If the provided reference points to a Tree or a Blob, the HEAD is
        /// unaltered and -1 is returned.If the provided reference points to a branch, the HEAD will point
        /// to that branch, staying attached, or become attached if it isn't yet.
        /// If the branch doesn't exist yet, no error will be return. The HEAD
        /// will then be attached to an unborn branch.Otherwise, the HEAD will be detached and will directly point to
        /// the Commit.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_head(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> refname);
        
        /// <summary>
        /// Make the repository HEAD directly point to the Commit.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <param name="committish">Object id of the Commit the HEAD should point to</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// If the provided committish cannot be found in the repository, the HEAD
        /// is unaltered and GIT_ENOTFOUND is returned.If the provided committish cannot be peeled into a commit, the HEAD
        /// is unaltered and -1 is returned.Otherwise, the HEAD will eventually be detached and will directly point to
        /// the peeled Commit.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_head_detached")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_head_detached(libgit2.git_repository repo, in libgit2.git_oid committish);
        
        /// <summary>
        /// Make the repository HEAD directly point to the Commit.
        /// </summary>
        /// <remarks>
        /// This behaves like `git_repository_set_head_detached()` but takes an
        /// annotated commit, which lets you specify which extended sha syntax
        /// string was specified by a user, allowing for more exact reflog
        /// messages.See the documentation for `git_repository_set_head_detached()`.
        /// </remarks>
        /// <seealso cref="git_repository_set_head_detached"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_head_detached_from_annotated")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_set_head_detached_from_annotated(libgit2.git_repository repo, libgit2.git_annotated_commit committish);
        
        /// <summary>
        /// Detach the HEAD.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <returns>@return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
        /// branch or an error code</returns>
        /// <remarks>
        /// If the HEAD is already detached and points to a Commit, 0 is returned.If the HEAD is already detached and points to a Tag, the HEAD is
        /// updated into making it point to the peeled Commit, and 0 is returned.If the HEAD is already detached and points to a non committish, the HEAD is
        /// unaltered, and -1 is returned.Otherwise, the HEAD will be detached and point to the peeled Commit.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_detach_head")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_detach_head(libgit2.git_repository repo);
        
        /// <summary>
        /// Determines the status of a git repository - ie, whether an operation
        /// (merge, cherry-pick, etc) is in progress.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <returns>@return The state of the repository</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_state")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_state(libgit2.git_repository repo);
        
        /// <summary>
        /// Sets the active namespace for this Git Repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <param name="nmspace">The namespace. This should not include the refs
        /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
        /// use `foo` as the namespace.</param>
        /// <returns>@return 0 on success, -1 on error</returns>
        /// <remarks>
        /// This namespace affects all reference operations for the repo.
        /// See `man gitnamespaces`
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_namespace")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_namespace(libgit2.git_repository repo, byte* nmspace);
        
        /// <summary>
        /// Sets the active namespace for this Git Repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <param name="nmspace">The namespace. This should not include the refs
        /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
        /// use `foo` as the namespace.</param>
        /// <returns>@return 0 on success, -1 on error</returns>
        /// <remarks>
        /// This namespace affects all reference operations for the repo.
        /// See `man gitnamespaces`
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_namespace")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_namespace(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> nmspace);
        
        /// <summary>
        /// Get the currently active namespace for this repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <returns>@return the active namespace, or NULL if there isn't one</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_get_namespace")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_repository_get_namespace(libgit2.git_repository repo);
        
        /// <summary>
        /// Get the currently active namespace for this repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <returns>@return the active namespace, or NULL if there isn't one</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_get_namespace")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_repository_get_namespace_string(libgit2.git_repository repo);
        
        /// <summary>
        /// Determine if the repository was a shallow clone
        /// </summary>
        /// <param name="repo">The repository</param>
        /// <returns>@return 1 if shallow, zero if not</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_is_shallow")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_repository_is_shallow(libgit2.git_repository repo);
        
        /// <summary>
        /// Retrieve the configured identity to use for reflogs
        /// </summary>
        /// <param name="name">where to store the pointer to the name</param>
        /// <param name="email">where to store the pointer to the email</param>
        /// <param name="repo">the repository</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The memory is owned by the repository and must not be freed by the
        /// user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_ident")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_ident(out byte* name, out byte* email, libgit2.git_repository repo);
        
        /// <summary>
        /// Set the identity to be used for writing reflogs
        /// </summary>
        /// <param name="repo">the repository to configure</param>
        /// <param name="name">the name to use for the reflog entries</param>
        /// <param name="email">the email to use for the reflog entries</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// If both are set, this name and email will be used to write to the
        /// reflog. Pass NULL to unset. When unset, the identity will be taken
        /// from the repository's configuration.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_ident")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_ident(libgit2.git_repository repo, byte* name, byte* email);
        
        /// <summary>
        /// Set the identity to be used for writing reflogs
        /// </summary>
        /// <param name="repo">the repository to configure</param>
        /// <param name="name">the name to use for the reflog entries</param>
        /// <param name="email">the email to use for the reflog entries</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// If both are set, this name and email will be used to write to the
        /// reflog. Pass NULL to unset. When unset, the identity will be taken
        /// from the repository's configuration.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_set_ident")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_repository_set_ident(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> email);
        
        /// <summary>
        /// Gets the object type used by this repository.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <returns>@return the object id type</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_repository_oid_type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid_t git_repository_oid_type(libgit2.git_repository repo);
    }
}
