//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Possible states for an attribute
        /// </summary>
        public enum git_attr_value_t : uint
        {
            /// <summary>
            /// The attribute has been left unspecified
            /// </summary>
            GIT_ATTR_VALUE_UNSPECIFIED = unchecked((uint)0),
            
            /// <summary>
            /// The attribute has been set
            /// </summary>
            GIT_ATTR_VALUE_TRUE = unchecked((uint)1),
            
            /// <summary>
            /// The attribute has been unset
            /// </summary>
            GIT_ATTR_VALUE_FALSE = unchecked((uint)2),
            
            /// <summary>
            /// This attribute has a value
            /// </summary>
            GIT_ATTR_VALUE_STRING = unchecked((uint)3),
        }
        
        /// <summary>
        /// The attribute has been left unspecified
        /// </summary>
        public const libgit2.git_attr_value_t GIT_ATTR_VALUE_UNSPECIFIED = git_attr_value_t.GIT_ATTR_VALUE_UNSPECIFIED;
        
        /// <summary>
        /// The attribute has been set
        /// </summary>
        public const libgit2.git_attr_value_t GIT_ATTR_VALUE_TRUE = git_attr_value_t.GIT_ATTR_VALUE_TRUE;
        
        /// <summary>
        /// The attribute has been unset
        /// </summary>
        public const libgit2.git_attr_value_t GIT_ATTR_VALUE_FALSE = git_attr_value_t.GIT_ATTR_VALUE_FALSE;
        
        /// <summary>
        /// This attribute has a value
        /// </summary>
        public const libgit2.git_attr_value_t GIT_ATTR_VALUE_STRING = git_attr_value_t.GIT_ATTR_VALUE_STRING;
        
        /// <summary>
        /// An options structure for querying attributes.
        /// </summary>
        public partial struct git_attr_options
        {
            public uint version;
            
            /// <summary>
            /// A combination of GIT_ATTR_CHECK flags
            /// </summary>
            public uint flags;
            
            public void* reserved;
            
            /// <summary>
            /// The commit to load attributes from, when
            /// `GIT_ATTR_CHECK_INCLUDE_COMMIT` is specified.
            /// </summary>
            public libgit2.git_oid attr_commit_id;
        }
        
        /// <summary>
        /// The callback used with git_attr_foreach.
        /// </summary>
        /// <param name="name">The attribute name.</param>
        /// <param name="value">The attribute value. May be NULL if the attribute is explicitly
        /// set to UNSPECIFIED using the '!' sign.</param>
        /// <param name="payload">A user-specified pointer.</param>
        /// <returns>@return 0 to continue looping, non-zero to stop. This value will be returned
        /// from git_attr_foreach.</returns>
        /// <remarks>
        /// This callback will be invoked only once per attribute name, even if there
        /// are multiple rules for a given file. The highest priority rule will be
        /// used.
        /// </remarks>
        /// <seealso cref="git_attr_foreach."/>
        public readonly partial struct git_attr_foreach_cb : IEquatable<libgit2.git_attr_foreach_cb>
        {
            public git_attr_foreach_cb(delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_attr_foreach_cb other && Equals(other);
            
            public bool Equals(git_attr_foreach_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> (libgit2.git_attr_foreach_cb from) => from.Value;
            
            public static implicit operator libgit2.git_attr_foreach_cb (delegate*unmanaged[Cdecl]<byte*, byte*, void*, int> from) => new libgit2.git_attr_foreach_cb(from);
            
            public static bool operator ==(git_attr_foreach_cb left, git_attr_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_attr_foreach_cb left, git_attr_foreach_cb right) => !left.Equals(right);
        }
        
        public const uint GIT_ATTR_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// Return the value type for a given attribute.
        /// </summary>
        /// <param name="attr">The attribute</param>
        /// <returns>the value type for the attribute</returns>
        /// <remarks>
        /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
        /// was not set at all), or `VALUE`, if the attribute was set to an
        /// actual string.If the attribute has a `VALUE` string, it can be accessed normally
        /// as a NULL-terminated C string.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_value")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_attr_value_t git_attr_value(byte* attr);
        
        /// <summary>
        /// Return the value type for a given attribute.
        /// </summary>
        /// <param name="attr">The attribute</param>
        /// <returns>the value type for the attribute</returns>
        /// <remarks>
        /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
        /// was not set at all), or `VALUE`, if the attribute was set to an
        /// actual string.If the attribute has a `VALUE` string, it can be accessed normally
        /// as a NULL-terminated C string.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_value")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_attr_value_t git_attr_value([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> attr);
        
        /// <summary>
        /// Look up the value of one git attribute for path.
        /// </summary>
        /// <param name="value_out">Output of the value of the attribute.  Use the GIT_ATTR_...
        /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
        /// use the string value for attributes set to a value.  You
        /// should NOT modify or free this value.</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path to check for attributes.  Relative paths are
        /// interpreted relative to the repo root.  The file does
        /// not have to exist, but if it does not, then it will be
        /// treated as a plain file (not a directory).</param>
        /// <param name="name">The name of the attribute to look up.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get(ref byte* value_out, libgit2.git_repository repo, uint flags, byte* path, byte* name);
        
        /// <summary>
        /// Look up the value of one git attribute for path.
        /// </summary>
        /// <param name="value_out">Output of the value of the attribute.  Use the GIT_ATTR_...
        /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
        /// use the string value for attributes set to a value.  You
        /// should NOT modify or free this value.</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path to check for attributes.  Relative paths are
        /// interpreted relative to the repo root.  The file does
        /// not have to exist, but if it does not, then it will be
        /// treated as a plain file (not a directory).</param>
        /// <param name="name">The name of the attribute to look up.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get(ref byte* value_out, libgit2.git_repository repo, uint flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Look up the value of one git attribute for path with extended options.
        /// </summary>
        /// <param name="value_out">Output of the value of the attribute.  Use the GIT_ATTR_...
        /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
        /// use the string value for attributes set to a value.  You
        /// should NOT modify or free this value.</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">The path to check for attributes.  Relative paths are
        /// interpreted relative to the repo root.  The file does
        /// not have to exist, but if it does not, then it will be
        /// treated as a plain file (not a directory).</param>
        /// <param name="name">The name of the attribute to look up.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_ext(ref byte* value_out, libgit2.git_repository repo, ref libgit2.git_attr_options opts, byte* path, byte* name);
        
        /// <summary>
        /// Look up the value of one git attribute for path with extended options.
        /// </summary>
        /// <param name="value_out">Output of the value of the attribute.  Use the GIT_ATTR_...
        /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
        /// use the string value for attributes set to a value.  You
        /// should NOT modify or free this value.</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">The path to check for attributes.  Relative paths are
        /// interpreted relative to the repo root.  The file does
        /// not have to exist, but if it does not, then it will be
        /// treated as a plain file (not a directory).</param>
        /// <param name="name">The name of the attribute to look up.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_ext(ref byte* value_out, libgit2.git_repository repo, ref libgit2.git_attr_options opts, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Look up a list of git attributes for path.
        /// </summary>
        /// <param name="values_out">An array of num_attr entries that will have string
        /// pointers written into it for the values of the attributes.
        /// You should not modify or free the values that are written
        /// into this array (although of course, you should free the
        /// array itself if you allocated it).</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path inside the repo to check attributes.  This
        /// does not have to exist, but if it does not, then
        /// it will be treated as a plain file (i.e. not a directory).</param>
        /// <param name="num_attr">The number of attributes being looked up</param>
        /// <param name="names">An array of num_attr strings containing attribute names.</param>
        /// <returns>0 or an error code.</returns>
        /// <remarks>
        /// Use this if you have a known list of attributes that you want to
        /// look up in a single call.  This is somewhat more efficient than
        /// calling `git_attr_get()` multiple times.For example, you might write:const char *attrs[] = { "crlf", "diff", "foo" };
        /// const char **values[3];
        /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);Then you could loop through the 3 values to get the settings for
        /// the three attributes you asked about.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_many")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_many(ref byte* values_out, libgit2.git_repository repo, uint flags, byte* path, nuint num_attr, ref byte* names);
        
        /// <summary>
        /// Look up a list of git attributes for path.
        /// </summary>
        /// <param name="values_out">An array of num_attr entries that will have string
        /// pointers written into it for the values of the attributes.
        /// You should not modify or free the values that are written
        /// into this array (although of course, you should free the
        /// array itself if you allocated it).</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path inside the repo to check attributes.  This
        /// does not have to exist, but if it does not, then
        /// it will be treated as a plain file (i.e. not a directory).</param>
        /// <param name="num_attr">The number of attributes being looked up</param>
        /// <param name="names">An array of num_attr strings containing attribute names.</param>
        /// <returns>0 or an error code.</returns>
        /// <remarks>
        /// Use this if you have a known list of attributes that you want to
        /// look up in a single call.  This is somewhat more efficient than
        /// calling `git_attr_get()` multiple times.For example, you might write:const char *attrs[] = { "crlf", "diff", "foo" };
        /// const char **values[3];
        /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);Then you could loop through the 3 values to get the settings for
        /// the three attributes you asked about.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_many")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_many(ref byte* values_out, libgit2.git_repository repo, uint flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, nuint num_attr, ref byte* names);
        
        /// <summary>
        /// Look up a list of git attributes for path with extended options.
        /// </summary>
        /// <param name="values_out">An array of num_attr entries that will have string
        /// pointers written into it for the values of the attributes.
        /// You should not modify or free the values that are written
        /// into this array (although of course, you should free the
        /// array itself if you allocated it).</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">The path inside the repo to check attributes.  This
        /// does not have to exist, but if it does not, then
        /// it will be treated as a plain file (i.e. not a directory).</param>
        /// <param name="num_attr">The number of attributes being looked up</param>
        /// <param name="names">An array of num_attr strings containing attribute names.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_many_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_many_ext(ref byte* values_out, libgit2.git_repository repo, ref libgit2.git_attr_options opts, byte* path, nuint num_attr, ref byte* names);
        
        /// <summary>
        /// Look up a list of git attributes for path with extended options.
        /// </summary>
        /// <param name="values_out">An array of num_attr entries that will have string
        /// pointers written into it for the values of the attributes.
        /// You should not modify or free the values that are written
        /// into this array (although of course, you should free the
        /// array itself if you allocated it).</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">The path inside the repo to check attributes.  This
        /// does not have to exist, but if it does not, then
        /// it will be treated as a plain file (i.e. not a directory).</param>
        /// <param name="num_attr">The number of attributes being looked up</param>
        /// <param name="names">An array of num_attr strings containing attribute names.</param>
        /// <returns>0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_get_many_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_get_many_ext(ref byte* values_out, libgit2.git_repository repo, ref libgit2.git_attr_options opts, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, nuint num_attr, ref byte* names);
        
        /// <summary>
        /// Loop over all the git attributes for a path.
        /// </summary>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">Path inside the repo to check attributes.  This does not have
        /// to exist, but if it does not, then it will be treated as a
        /// plain file (i.e. not a directory).</param>
        /// <param name="callback">Function to invoke on each attribute name and value.
        /// See git_attr_foreach_cb.</param>
        /// <param name="payload">Passed on as extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_foreach(libgit2.git_repository repo, uint flags, byte* path, libgit2.git_attr_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Loop over all the git attributes for a path.
        /// </summary>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">Path inside the repo to check attributes.  This does not have
        /// to exist, but if it does not, then it will be treated as a
        /// plain file (i.e. not a directory).</param>
        /// <param name="callback">Function to invoke on each attribute name and value.
        /// See git_attr_foreach_cb.</param>
        /// <param name="payload">Passed on as extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_foreach(libgit2.git_repository repo, uint flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_attr_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Loop over all the git attributes for a path with extended options.
        /// </summary>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">Path inside the repo to check attributes.  This does not have
        /// to exist, but if it does not, then it will be treated as a
        /// plain file (i.e. not a directory).</param>
        /// <param name="callback">Function to invoke on each attribute name and value.
        /// See git_attr_foreach_cb.</param>
        /// <param name="payload">Passed on as extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_foreach_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_foreach_ext(libgit2.git_repository repo, ref libgit2.git_attr_options opts, byte* path, libgit2.git_attr_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Loop over all the git attributes for a path with extended options.
        /// </summary>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="opts">The `git_attr_options` to use when querying these attributes.</param>
        /// <param name="path">Path inside the repo to check attributes.  This does not have
        /// to exist, but if it does not, then it will be treated as a
        /// plain file (i.e. not a directory).</param>
        /// <param name="callback">Function to invoke on each attribute name and value.
        /// See git_attr_foreach_cb.</param>
        /// <param name="payload">Passed on as extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_foreach_ext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_foreach_ext(libgit2.git_repository repo, ref libgit2.git_attr_options opts, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_attr_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Flush the gitattributes cache.
        /// </summary>
        /// <param name="repo">The repository containing the gitattributes cache</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// Call this if you have reason to believe that the attributes files on
        /// disk no longer match the cached contents of memory.  This will cause
        /// the attributes files to be reloaded the next time that an attribute
        /// access function is called.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_cache_flush")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_cache_flush(libgit2.git_repository repo);
        
        /// <summary>
        /// Add a macro definition.
        /// </summary>
        /// <param name="repo">The repository to add the macro in.</param>
        /// <param name="name">The name of the macro.</param>
        /// <param name="values">The value for the macro.</param>
        /// <returns>0 or an error code.</returns>
        /// <remarks>
        /// Macros will automatically be loaded from the top level `.gitattributes`
        /// file of the repository (plus the built-in "binary" macro).  This
        /// function allows you to add others.  For example, to add the default
        /// macro, you would call:git_attr_add_macro(repo, "binary", "-diff -crlf");
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_add_macro")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_add_macro(libgit2.git_repository repo, byte* name, byte* values);
        
        /// <summary>
        /// Add a macro definition.
        /// </summary>
        /// <param name="repo">The repository to add the macro in.</param>
        /// <param name="name">The name of the macro.</param>
        /// <param name="values">The value for the macro.</param>
        /// <returns>0 or an error code.</returns>
        /// <remarks>
        /// Macros will automatically be loaded from the top level `.gitattributes`
        /// file of the repository (plus the built-in "binary" macro).  This
        /// function allows you to add others.  For example, to add the default
        /// macro, you would call:git_attr_add_macro(repo, "binary", "-diff -crlf");
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_attr_add_macro")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_attr_add_macro(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> values);
    }
}
