//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Callback used to iterate over tag names
        /// </summary>
        /// <param name="name">The tag name</param>
        /// <param name="oid">The tag's OID</param>
        /// <param name="payload">Payload passed to git_tag_foreach</param>
        /// <returns>@return non-zero to terminate the iteration</returns>
        /// <seealso cref="git_tag_foreach"/>
        public readonly partial struct git_tag_foreach_cb : IEquatable<git_tag_foreach_cb>
        {
            public git_tag_foreach_cb(delegate*unmanaged[Cdecl]<byte*, libgit2.git_oid*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, libgit2.git_oid*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_tag_foreach_cb other && Equals(other);
            
            public bool Equals(git_tag_foreach_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, libgit2.git_oid*, void*, int> (libgit2.git_tag_foreach_cb from) => from.Value;
            
            public static implicit operator libgit2.git_tag_foreach_cb (delegate*unmanaged[Cdecl]<byte*, libgit2.git_oid*, void*, int> from) => new libgit2.git_tag_foreach_cb(from);
            
            public static bool operator ==(git_tag_foreach_cb left, git_tag_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_tag_foreach_cb left, git_tag_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Lookup a tag object from the repository.
        /// </summary>
        /// <param name="out">pointer to the looked up tag</param>
        /// <param name="repo">the repo to use when locating the tag.</param>
        /// <param name="id">identity of the tag to locate.</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_lookup(out libgit2.git_tag @out, libgit2.git_repository repo, in libgit2.git_oid id);
        
        /// <summary>
        /// Lookup a tag object from the repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <param name="out">pointer to the looked up tag</param>
        /// <param name="repo">the repo to use when locating the tag.</param>
        /// <param name="id">identity of the tag to locate.</param>
        /// <param name="len">the length of the short identifier</param>
        /// <returns>@return 0 or an error code</returns>
        /// <seealso cref="git_object_lookup_prefix"/>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_lookup_prefix")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_lookup_prefix(out libgit2.git_tag @out, libgit2.git_repository repo, in libgit2.git_oid id, nuint len);
        
        /// <summary>
        /// Close an open tag
        /// </summary>
        /// <param name="tag">the tag to close</param>
        /// <remarks>
        /// You can no longer use the git_tag pointer after this call.IMPORTANT: You MUST call this method when you are through with a tag to
        /// release memory. Failure to do so will cause a memory leak.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_tag_free(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the id of a tag.
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return object identity for the tag.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_tag_id(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the repository that contains the tag.
        /// </summary>
        /// <param name="tag">A previously loaded tag.</param>
        /// <returns>@return Repository that contains this tag.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_owner")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_repository git_tag_owner(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the tagged object of a tag
        /// </summary>
        /// <param name="target_out">pointer where to store the target</param>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This method performs a repository lookup for the
        /// given object and returns it
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_target")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_target(out libgit2.git_object target_out, libgit2.git_tag tag);
        
        /// <summary>
        /// Get the OID of the tagged object of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return pointer to the OID</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_target_id")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_oid* git_tag_target_id(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the type of a tag's tagged object
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return type of the tagged object</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_target_type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_object_t git_tag_target_type(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the name of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return name of the tag</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_tag_name_(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the name of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return name of the tag</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_tag_name(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the tagger (author) of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return reference to the tag's author or NULL when unspecified</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_tagger")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_signature* git_tag_tagger(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the message of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return message of the tag or NULL when unspecified</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_tag_message_(libgit2.git_tag tag);
        
        /// <summary>
        /// Get the message of a tag
        /// </summary>
        /// <param name="tag">a previously loaded tag.</param>
        /// <returns>@return message of the tag or NULL when unspecified</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_message")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_tag_message(libgit2.git_tag tag);
        
        /// <summary>
        /// Create a new tag in the repository from an object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the
        /// newly created tag. If the tag already exists, this parameter
        /// will be the oid of the existing tag, and the function will
        /// return a GIT_EEXISTS error code.</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="tag_name">Name for the tag; this name is validated
        /// for consistency. It should also not conflict with an
        /// already existing tag name</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="tagger">Signature of the tagger for this tag, and
        /// of the tagging time</param>
        /// <param name="message">Full message for this tag</param>
        /// <param name="force">Overwrite existing references</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code
        /// A tag object is written to the ODB, and a proper reference
        /// is written in the /refs/tags folder, pointing to it</returns>
        /// <remarks>
        /// A new reference will also be created pointing to
        /// this tag object. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The message will not be cleaned up. This can be achieved
        /// through `git_message_prettify()`.The tag name will be checked for validity. You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create(out libgit2.git_oid oid, libgit2.git_repository repo, byte* tag_name, libgit2.git_object target, in libgit2.git_signature tagger, byte* message, int force);
        
        /// <summary>
        /// Create a new tag in the repository from an object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the
        /// newly created tag. If the tag already exists, this parameter
        /// will be the oid of the existing tag, and the function will
        /// return a GIT_EEXISTS error code.</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="tag_name">Name for the tag; this name is validated
        /// for consistency. It should also not conflict with an
        /// already existing tag name</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="tagger">Signature of the tagger for this tag, and
        /// of the tagging time</param>
        /// <param name="message">Full message for this tag</param>
        /// <param name="force">Overwrite existing references</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code
        /// A tag object is written to the ODB, and a proper reference
        /// is written in the /refs/tags folder, pointing to it</returns>
        /// <remarks>
        /// A new reference will also be created pointing to
        /// this tag object. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The message will not be cleaned up. This can be achieved
        /// through `git_message_prettify()`.The tag name will be checked for validity. You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create(out libgit2.git_oid oid, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tag_name, libgit2.git_object target, in libgit2.git_signature tagger, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, int force);
        
        /// <summary>
        /// Create a new tag in the object database pointing to a git_object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the
        /// newly created tag</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="tag_name">Name for the tag</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="tagger">Signature of the tagger for this tag, and
        /// of the tagging time</param>
        /// <param name="message">Full message for this tag</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// The message will not be cleaned up. This can be achieved
        /// through `git_message_prettify()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_annotation_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_annotation_create(out libgit2.git_oid oid, libgit2.git_repository repo, byte* tag_name, libgit2.git_object target, in libgit2.git_signature tagger, byte* message);
        
        /// <summary>
        /// Create a new tag in the object database pointing to a git_object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the
        /// newly created tag</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="tag_name">Name for the tag</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="tagger">Signature of the tagger for this tag, and
        /// of the tagging time</param>
        /// <param name="message">Full message for this tag</param>
        /// <returns>@return 0 on success or an error code</returns>
        /// <remarks>
        /// The message will not be cleaned up. This can be achieved
        /// through `git_message_prettify()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_annotation_create")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_annotation_create(out libgit2.git_oid oid, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tag_name, libgit2.git_object target, in libgit2.git_signature tagger, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message);
        
        /// <summary>
        /// Create a new tag in the repository from a buffer
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the newly created tag</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="buffer">Raw tag data</param>
        /// <param name="force">Overwrite existing tags</param>
        /// <returns>@return 0 on success; error code otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create_from_buffer(out libgit2.git_oid oid, libgit2.git_repository repo, byte* buffer, int force);
        
        /// <summary>
        /// Create a new tag in the repository from a buffer
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the newly created tag</param>
        /// <param name="repo">Repository where to store the tag</param>
        /// <param name="buffer">Raw tag data</param>
        /// <param name="force">Overwrite existing tags</param>
        /// <returns>@return 0 on success; error code otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create_from_buffer(out libgit2.git_oid oid, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> buffer, int force);
        
        /// <summary>
        /// Create a new lightweight tag pointing at a target object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the provided
        /// target object. If the tag already exists, this parameter
        /// will be filled with the oid of the existing pointed object
        /// and the function will return a GIT_EEXISTS error code.</param>
        /// <param name="repo">Repository where to store the lightweight tag</param>
        /// <param name="tag_name">Name for the tag; this name is validated
        /// for consistency. It should also not conflict with an
        /// already existing tag name</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code
        /// A proper reference is written in the /refs/tags folder,
        /// pointing to the provided target object</returns>
        /// <remarks>
        /// A new direct reference will be created pointing to
        /// this target object. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The tag name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create_lightweight")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create_lightweight(out libgit2.git_oid oid, libgit2.git_repository repo, byte* tag_name, libgit2.git_object target, int force);
        
        /// <summary>
        /// Create a new lightweight tag pointing at a target object
        /// </summary>
        /// <param name="oid">Pointer where to store the OID of the provided
        /// target object. If the tag already exists, this parameter
        /// will be filled with the oid of the existing pointed object
        /// and the function will return a GIT_EEXISTS error code.</param>
        /// <param name="repo">Repository where to store the lightweight tag</param>
        /// <param name="tag_name">Name for the tag; this name is validated
        /// for consistency. It should also not conflict with an
        /// already existing tag name</param>
        /// <param name="target">Object to which this tag points. This object
        /// must belong to the given `repo`.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code
        /// A proper reference is written in the /refs/tags folder,
        /// pointing to the provided target object</returns>
        /// <remarks>
        /// A new direct reference will be created pointing to
        /// this target object. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The tag name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_create_lightweight")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_create_lightweight(out libgit2.git_oid oid, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tag_name, libgit2.git_object target, int force);
        
        /// <summary>
        /// Delete an existing tag reference.
        /// </summary>
        /// <param name="repo">Repository where lives the tag</param>
        /// <param name="tag_name">Name of the tag to be deleted;
        /// this name is validated for consistency.</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The tag name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_delete(libgit2.git_repository repo, byte* tag_name);
        
        /// <summary>
        /// Delete an existing tag reference.
        /// </summary>
        /// <param name="repo">Repository where lives the tag</param>
        /// <param name="tag_name">Name of the tag to be deleted;
        /// this name is validated for consistency.</param>
        /// <returns>@return 0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The tag name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_delete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_delete(libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tag_name);
        
        /// <summary>
        /// Fill a list with all the tags in the Repository
        /// </summary>
        /// <param name="tag_names">Pointer to a git_strarray structure where
        /// the tag names will be stored</param>
        /// <param name="repo">Repository where to find the tags</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The string array will be filled with the names of the
        /// matching tags; these values are owned by the user and
        /// should be free'd manually when no longer needed, using
        /// `git_strarray_free`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_list")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_list(out libgit2.git_strarray tag_names, libgit2.git_repository repo);
        
        /// <summary>
        /// Fill a list with all the tags in the Repository
        /// which name match a defined pattern
        /// </summary>
        /// <param name="tag_names">Pointer to a git_strarray structure where
        /// the tag names will be stored</param>
        /// <param name="pattern">Standard fnmatch pattern</param>
        /// <param name="repo">Repository where to find the tags</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If an empty pattern is provided, all the tags
        /// will be returned.The string array will be filled with the names of the
        /// matching tags; these values are owned by the user and
        /// should be free'd manually when no longer needed, using
        /// `git_strarray_free`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_list_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_list_match(out libgit2.git_strarray tag_names, byte* pattern, libgit2.git_repository repo);
        
        /// <summary>
        /// Fill a list with all the tags in the Repository
        /// which name match a defined pattern
        /// </summary>
        /// <param name="tag_names">Pointer to a git_strarray structure where
        /// the tag names will be stored</param>
        /// <param name="pattern">Standard fnmatch pattern</param>
        /// <param name="repo">Repository where to find the tags</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If an empty pattern is provided, all the tags
        /// will be returned.The string array will be filled with the names of the
        /// matching tags; these values are owned by the user and
        /// should be free'd manually when no longer needed, using
        /// `git_strarray_free`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_list_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_list_match(out libgit2.git_strarray tag_names, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pattern, libgit2.git_repository repo);
        
        /// <summary>
        /// Call callback `cb' for each tag in the repository
        /// </summary>
        /// <param name="repo">Repository</param>
        /// <param name="callback">Callback function</param>
        /// <param name="payload">Pointer to callback data (optional)</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_tag_foreach(libgit2.git_repository repo, libgit2.git_tag_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Recursively peel a tag until a non tag git_object is found
        /// </summary>
        /// <param name="tag_target_out">Pointer to the peeled git_object</param>
        /// <param name="tag">The tag to be processed</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The retrieved `tag_target` object is owned by the repository
        /// and should be closed with the `git_object_free` method.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_peel")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_peel(out libgit2.git_object tag_target_out, libgit2.git_tag tag);
        
        /// <summary>
        /// Create an in-memory copy of a tag. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="out">Pointer to store the copy of the tag</param>
        /// <param name="source">Original tag to copy</param>
        /// <returns>@return 0</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_dup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_tag_dup(out libgit2.git_tag @out, libgit2.git_tag source);
        
        /// <summary>
        /// Determine whether a tag name is valid, meaning that (when prefixed
        /// with `refs/tags/`) that it is a valid reference name, and that any
        /// additional tag name restrictions are imposed (eg, it cannot start
        /// with a `-`).
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given tag name</param>
        /// <param name="name">a tag name to test</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_name_is_valid(out int valid, byte* name);
        
        /// <summary>
        /// Determine whether a tag name is valid, meaning that (when prefixed
        /// with `refs/tags/`) that it is a valid reference name, and that any
        /// additional tag name restrictions are imposed (eg, it cannot start
        /// with a `-`).
        /// </summary>
        /// <param name="valid">output pointer to set with validity of given tag name</param>
        /// <param name="name">a tag name to test</param>
        /// <returns>@return 0 on success or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_tag_name_is_valid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_tag_name_is_valid(out int valid, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
    }
}
