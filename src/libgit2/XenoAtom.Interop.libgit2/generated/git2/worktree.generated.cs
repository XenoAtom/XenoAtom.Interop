//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Flags which can be passed to git_worktree_prune to alter its
        /// behavior.
        /// </summary>
        [Flags]
        public enum git_worktree_prune_t : uint
        {
            /// <summary>
            /// Prune working tree even if working tree is valid
            /// </summary>
            GIT_WORKTREE_PRUNE_VALID = unchecked((uint)1),
            
            /// <summary>
            /// Prune working tree even if it is locked
            /// </summary>
            GIT_WORKTREE_PRUNE_LOCKED = unchecked((uint)2),
            
            /// <summary>
            /// Prune checked out working tree
            /// </summary>
            GIT_WORKTREE_PRUNE_WORKING_TREE = unchecked((uint)4),
        }
        
        /// <summary>
        /// Prune working tree even if working tree is valid
        /// </summary>
        public const libgit2.git_worktree_prune_t GIT_WORKTREE_PRUNE_VALID = git_worktree_prune_t.GIT_WORKTREE_PRUNE_VALID;
        
        /// <summary>
        /// Prune working tree even if it is locked
        /// </summary>
        public const libgit2.git_worktree_prune_t GIT_WORKTREE_PRUNE_LOCKED = git_worktree_prune_t.GIT_WORKTREE_PRUNE_LOCKED;
        
        /// <summary>
        /// Prune checked out working tree
        /// </summary>
        public const libgit2.git_worktree_prune_t GIT_WORKTREE_PRUNE_WORKING_TREE = git_worktree_prune_t.GIT_WORKTREE_PRUNE_WORKING_TREE;
        
        /// <summary>
        /// Worktree add options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_WORKTREE_ADD_OPTIONS_INIT`. Alternatively, you can
        /// use `git_worktree_add_options_init`.
        /// </remarks>
        public partial struct git_worktree_add_options
        {
            public uint version;
            
            /// <summary>
            /// lock newly created worktree
            /// </summary>
            public int @lock;
            
            /// <summary>
            /// reference to use for the new worktree HEAD
            /// </summary>
            public libgit2.git_reference @ref;
            
            /// <summary>
            /// Options for the checkout.
            /// </summary>
            public libgit2.git_checkout_options checkout_options;
        }
        
        /// <summary>
        /// Worktree prune options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_worktree_prune_options_init`.
        /// </remarks>
        public partial struct git_worktree_prune_options
        {
            public uint version;
            
            /// <summary>
            /// A combination of `git_worktree_prune_t`
            /// </summary>
            public libgit2.git_worktree_prune_t flags;
        }
        
        public const uint GIT_WORKTREE_ADD_OPTIONS_VERSION = 1;
        
        public const uint GIT_WORKTREE_PRUNE_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// List names of linked working trees
        /// </summary>
        /// <param name="out">pointer to the array of working tree names</param>
        /// <param name="repo">the repo to use when listing working trees</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The returned list should be released with `git_strarray_free`
        /// when no longer needed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_list")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_list(out libgit2.git_strarray @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Lookup a working tree by its name for a given repository
        /// </summary>
        /// <param name="out">Output pointer to looked up worktree or `NULL`</param>
        /// <param name="repo">The repository containing worktrees</param>
        /// <param name="name">Name of the working tree to look up</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_lookup(out libgit2.git_worktree @out, libgit2.git_repository repo, byte* name);
        
        /// <summary>
        /// Lookup a working tree by its name for a given repository
        /// </summary>
        /// <param name="out">Output pointer to looked up worktree or `NULL`</param>
        /// <param name="repo">The repository containing worktrees</param>
        /// <param name="name">Name of the working tree to look up</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_lookup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_lookup(out libgit2.git_worktree @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Open a worktree of a given repository
        /// </summary>
        /// <param name="out">Out-pointer for the newly allocated worktree</param>
        /// <param name="repo">Repository to look up worktree for</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// If a repository is not the main tree but a worktree, this
        /// function will look up the worktree inside the parent
        /// repository and create a new `git_worktree` structure.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_open_from_repository")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_open_from_repository(out libgit2.git_worktree @out, libgit2.git_repository repo);
        
        /// <summary>
        /// Free a previously allocated worktree
        /// </summary>
        /// <param name="wt">worktree handle to close. If NULL nothing occurs.</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_worktree_free(libgit2.git_worktree wt);
        
        /// <summary>
        /// Check if worktree is valid
        /// </summary>
        /// <param name="wt">Worktree to check</param>
        /// <returns>@return 0 when worktree is valid, error-code otherwise</returns>
        /// <remarks>
        /// A valid worktree requires both the git data structures inside
        /// the linked parent repository and the linked working copy to be
        /// present.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_validate")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_validate(libgit2.git_worktree wt);
        
        /// <summary>
        /// Initialize git_worktree_add_options structure
        /// </summary>
        /// <param name="opts">The `git_worktree_add_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_WORKTREE_ADD_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_worktree_add_options` with default values. Equivalent to
        /// creating an instance with `GIT_WORKTREE_ADD_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_add_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_add_options_init(out libgit2.git_worktree_add_options opts, uint version);
        
        /// <summary>
        /// Add a new working tree
        /// </summary>
        /// <param name="out">Output pointer containing new working tree</param>
        /// <param name="repo">Repository to create working tree for</param>
        /// <param name="name">Name of the working tree</param>
        /// <param name="path">Path to create working tree at</param>
        /// <param name="opts">Options to modify default behavior. May be NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Add a new working tree for the repository, that is create the
        /// required data structures inside the repository and check out
        /// the current HEAD at `path`
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_add(out libgit2.git_worktree @out, libgit2.git_repository repo, byte* name, byte* path, in libgit2.git_worktree_add_options opts);
        
        /// <summary>
        /// Add a new working tree
        /// </summary>
        /// <param name="out">Output pointer containing new working tree</param>
        /// <param name="repo">Repository to create working tree for</param>
        /// <param name="name">Name of the working tree</param>
        /// <param name="path">Path to create working tree at</param>
        /// <param name="opts">Options to modify default behavior. May be NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Add a new working tree for the repository, that is create the
        /// required data structures inside the repository and check out
        /// the current HEAD at `path`
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_add")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_add(out libgit2.git_worktree @out, libgit2.git_repository repo, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, in libgit2.git_worktree_add_options opts);
        
        /// <summary>
        /// Lock worktree if not already locked
        /// </summary>
        /// <param name="wt">Worktree to lock</param>
        /// <param name="reason">Reason why the working tree is being locked</param>
        /// <returns>@return 0 on success, non-zero otherwise</returns>
        /// <remarks>
        /// Lock a worktree, optionally specifying a reason why the linked
        /// working tree is being locked.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_lock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_worktree_lock(libgit2.git_worktree wt, byte* reason);
        
        /// <summary>
        /// Lock worktree if not already locked
        /// </summary>
        /// <param name="wt">Worktree to lock</param>
        /// <param name="reason">Reason why the working tree is being locked</param>
        /// <returns>@return 0 on success, non-zero otherwise</returns>
        /// <remarks>
        /// Lock a worktree, optionally specifying a reason why the linked
        /// working tree is being locked.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_lock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_worktree_lock(libgit2.git_worktree wt, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> reason);
        
        /// <summary>
        /// Unlock a locked worktree
        /// </summary>
        /// <param name="wt">Worktree to unlock</param>
        /// <returns>@return 0 on success, 1 if worktree was not locked, error-code
        /// otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_unlock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_unlock(libgit2.git_worktree wt);
        
        /// <summary>
        /// Check if worktree is locked
        /// </summary>
        /// <param name="reason">Buffer to store reason in. If NULL no reason is stored.</param>
        /// <param name="wt">Worktree to check</param>
        /// <returns>@return 0 when the working tree not locked, a value greater
        /// than zero if it is locked, less than zero if there was an
        /// error</returns>
        /// <remarks>
        /// A worktree may be locked if the linked working tree is stored
        /// on a portable device which is not available.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_is_locked")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_is_locked(ref libgit2.git_buf reason, libgit2.git_worktree wt);
        
        /// <summary>
        /// Retrieve the name of the worktree
        /// </summary>
        /// <param name="wt">Worktree to get the name for</param>
        /// <returns>@return The worktree's name. The pointer returned is valid for the
        /// lifetime of the git_worktree</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_worktree_name_(libgit2.git_worktree wt);
        
        /// <summary>
        /// Retrieve the name of the worktree
        /// </summary>
        /// <param name="wt">Worktree to get the name for</param>
        /// <returns>@return The worktree's name. The pointer returned is valid for the
        /// lifetime of the git_worktree</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_worktree_name(libgit2.git_worktree wt);
        
        /// <summary>
        /// Retrieve the filesystem path for the worktree
        /// </summary>
        /// <param name="wt">Worktree to get the path for</param>
        /// <returns>@return The worktree's filesystem path. The pointer returned
        /// is valid for the lifetime of the git_worktree.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_worktree_path_(libgit2.git_worktree wt);
        
        /// <summary>
        /// Retrieve the filesystem path for the worktree
        /// </summary>
        /// <param name="wt">Worktree to get the path for</param>
        /// <returns>@return The worktree's filesystem path. The pointer returned
        /// is valid for the lifetime of the git_worktree.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_worktree_path(libgit2.git_worktree wt);
        
        /// <summary>
        /// Initialize git_worktree_prune_options structure
        /// </summary>
        /// <param name="opts">The `git_worktree_prune_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_WORKTREE_PRUNE_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_worktree_prune_options` with default values. Equivalent to
        /// creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_prune_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_prune_options_init(out libgit2.git_worktree_prune_options opts, uint version);
        
        /// <summary>
        /// Is the worktree prunable with the given options?
        /// </summary>
        /// <param name="wt">Worktree to check.</param>
        /// <param name="opts">The prunable options.</param>
        /// <returns>@return 1 if the worktree is prunable, 0 otherwise, or an error code.</returns>
        /// <remarks>
        /// A worktree is not prunable in the following scenarios:- the worktree is linking to a valid on-disk worktree. The
        /// `valid` member will cause this check to be ignored.
        /// - the worktree is locked. The `locked` flag will cause this
        /// check to be ignored.If the worktree is not valid and not locked or if the above
        /// flags have been passed in, this function will return a
        /// positive value. If the worktree is not prunable, an error
        /// message will be set (visible in `giterr_last`) with details about
        /// why.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_is_prunable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_worktree_is_prunable(libgit2.git_worktree wt, in libgit2.git_worktree_prune_options opts);
        
        /// <summary>
        /// Prune working tree
        /// </summary>
        /// <param name="wt">Worktree to prune</param>
        /// <param name="opts">Specifies which checks to override. See
        /// `git_worktree_is_prunable`. May be NULL</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Prune the working tree, that is remove the git data
        /// structures on disk. The repository will only be pruned of
        /// `git_worktree_is_prunable` succeeds.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_worktree_prune")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_worktree_prune(libgit2.git_worktree wt, in libgit2.git_worktree_prune_options opts);
    }
}
