//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Supported credential types
        /// </summary>
        /// <remarks>
        /// This represents the various types of authentication methods supported by
        /// the library.
        /// </remarks>
        [Flags]
        public enum git_credential_t : uint
        {
            /// <summary>
            /// A vanilla user/password request
            /// </summary>
            /// <seealso cref="git_credential_userpass_plaintext_new"/>
            GIT_CREDENTIAL_USERPASS_PLAINTEXT = unchecked((uint)1),
            
            /// <summary>
            /// An SSH key-based authentication request
            /// </summary>
            /// <seealso cref="git_credential_ssh_key_new"/>
            GIT_CREDENTIAL_SSH_KEY = unchecked((uint)2),
            
            /// <summary>
            /// An SSH key-based authentication request, with a custom signature
            /// </summary>
            /// <seealso cref="git_credential_ssh_custom_new"/>
            GIT_CREDENTIAL_SSH_CUSTOM = unchecked((uint)4),
            
            /// <summary>
            /// An NTLM/Negotiate-based authentication request.
            /// </summary>
            /// <seealso cref="git_credential_default"/>
            GIT_CREDENTIAL_DEFAULT = unchecked((uint)8),
            
            /// <summary>
            /// An SSH interactive authentication request
            /// </summary>
            /// <seealso cref="git_credential_ssh_interactive_new"/>
            GIT_CREDENTIAL_SSH_INTERACTIVE = unchecked((uint)16),
            
            /// <summary>
            /// Username-only authentication request
            /// </summary>
            /// <remarks>
            /// Used as a pre-authentication step if the underlying transport
            /// (eg. SSH, with no username in its URL) does not know which username
            /// to use.
            /// </remarks>
            /// <seealso cref="git_credential_username_new"/>
            GIT_CREDENTIAL_USERNAME = unchecked((uint)32),
            
            /// <summary>
            /// An SSH key-based authentication request
            /// </summary>
            /// <remarks>
            /// Allows credentials to be read from memory instead of files.
            /// Note that because of differences in crypto backend support, it might
            /// not be functional.
            /// </remarks>
            /// <seealso cref="git_credential_ssh_key_memory_new"/>
            GIT_CREDENTIAL_SSH_MEMORY = unchecked((uint)64),
        }
        
        /// <summary>
        /// A vanilla user/password request
        /// </summary>
        /// <seealso cref="git_credential_userpass_plaintext_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_USERPASS_PLAINTEXT = git_credential_t.GIT_CREDENTIAL_USERPASS_PLAINTEXT;
        
        /// <summary>
        /// An SSH key-based authentication request
        /// </summary>
        /// <seealso cref="git_credential_ssh_key_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_SSH_KEY = git_credential_t.GIT_CREDENTIAL_SSH_KEY;
        
        /// <summary>
        /// An SSH key-based authentication request, with a custom signature
        /// </summary>
        /// <seealso cref="git_credential_ssh_custom_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_SSH_CUSTOM = git_credential_t.GIT_CREDENTIAL_SSH_CUSTOM;
        
        /// <summary>
        /// An NTLM/Negotiate-based authentication request.
        /// </summary>
        /// <seealso cref="git_credential_default"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_DEFAULT = git_credential_t.GIT_CREDENTIAL_DEFAULT;
        
        /// <summary>
        /// An SSH interactive authentication request
        /// </summary>
        /// <seealso cref="git_credential_ssh_interactive_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_SSH_INTERACTIVE = git_credential_t.GIT_CREDENTIAL_SSH_INTERACTIVE;
        
        /// <summary>
        /// Username-only authentication request
        /// </summary>
        /// <remarks>
        /// Used as a pre-authentication step if the underlying transport
        /// (eg. SSH, with no username in its URL) does not know which username
        /// to use.
        /// </remarks>
        /// <seealso cref="git_credential_username_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_USERNAME = git_credential_t.GIT_CREDENTIAL_USERNAME;
        
        /// <summary>
        /// An SSH key-based authentication request
        /// </summary>
        /// <remarks>
        /// Allows credentials to be read from memory instead of files.
        /// Note that because of differences in crypto backend support, it might
        /// not be functional.
        /// </remarks>
        /// <seealso cref="git_credential_ssh_key_memory_new"/>
        public const libgit2.git_credential_t GIT_CREDENTIAL_SSH_MEMORY = git_credential_t.GIT_CREDENTIAL_SSH_MEMORY;
        
        /// <summary>
        /// The base structure for all credential types
        /// </summary>
        public readonly partial struct git_credential : IEquatable<git_credential>
        {
            public git_credential(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential left, git_credential right) => left.Equals(right);
            
            public static bool operator !=(git_credential left, git_credential right) => !left.Equals(right);
        }
        
        public readonly partial struct git_credential_userpass_plaintext : IEquatable<git_credential_userpass_plaintext>
        {
            public git_credential_userpass_plaintext(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential_userpass_plaintext other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential_userpass_plaintext other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential_userpass_plaintext left, git_credential_userpass_plaintext right) => left.Equals(right);
            
            public static bool operator !=(git_credential_userpass_plaintext left, git_credential_userpass_plaintext right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Username-only credential information
        /// </summary>
        public readonly partial struct git_credential_username : IEquatable<git_credential_username>
        {
            public git_credential_username(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential_username other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential_username other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential_username left, git_credential_username right) => left.Equals(right);
            
            public static bool operator !=(git_credential_username left, git_credential_username right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A ssh key from disk
        /// </summary>
        public readonly partial struct git_credential_ssh_key : IEquatable<git_credential_ssh_key>
        {
            public git_credential_ssh_key(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential_ssh_key other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential_ssh_key other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential_ssh_key left, git_credential_ssh_key right) => left.Equals(right);
            
            public static bool operator !=(git_credential_ssh_key left, git_credential_ssh_key right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Keyboard-interactive based ssh authentication
        /// </summary>
        public readonly partial struct git_credential_ssh_interactive : IEquatable<git_credential_ssh_interactive>
        {
            public git_credential_ssh_interactive(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential_ssh_interactive other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential_ssh_interactive other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential_ssh_interactive left, git_credential_ssh_interactive right) => left.Equals(right);
            
            public static bool operator !=(git_credential_ssh_interactive left, git_credential_ssh_interactive right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A key with a custom signature function
        /// </summary>
        public readonly partial struct git_credential_ssh_custom : IEquatable<git_credential_ssh_custom>
        {
            public git_credential_ssh_custom(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_credential_ssh_custom other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_credential_ssh_custom other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_credential_ssh_custom left, git_credential_ssh_custom right) => left.Equals(right);
            
            public static bool operator !=(git_credential_ssh_custom left, git_credential_ssh_custom right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Credential acquisition callback.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="url">The resource for which we are demanding a credential.</param>
        /// <param name="username_from_url">The username that was embedded in a "user\@host"
        /// remote url, or NULL if not included.</param>
        /// <param name="allowed_types">A bitmask stating which credential types are OK to return.</param>
        /// <param name="payload">The payload provided when specifying this callback.</param>
        /// <returns>@return 0 for success, 
        /// &lt;
        /// 0 to indicate an error, &gt; 0 to indicate
        /// no credential was acquired</returns>
        /// <remarks>
        /// This callback is usually involved any time another system might need
        /// authentication. As such, you are expected to provide a valid
        /// git_credential object back, depending on allowed_types (a
        /// git_credential_t bitmask).Note that most authentication details are your responsibility - this
        /// callback will be called until the authentication succeeds, or you report
        /// an error. As such, it's easy to get in a loop if you fail to stop providing
        /// the same incorrect credentials.
        /// </remarks>
        public readonly partial struct git_credential_acquire_cb : IEquatable<git_credential_acquire_cb>
        {
            public git_credential_acquire_cb(delegate*unmanaged[Cdecl]<libgit2.git_credential*, byte*, byte*, uint, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_credential*, byte*, byte*, uint, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_credential_acquire_cb other && Equals(other);
            
            public bool Equals(git_credential_acquire_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_credential*, byte*, byte*, uint, void*, int> (libgit2.git_credential_acquire_cb from) => from.Value;
            
            public static implicit operator libgit2.git_credential_acquire_cb (delegate*unmanaged[Cdecl]<libgit2.git_credential*, byte*, byte*, uint, void*, int> from) => new libgit2.git_credential_acquire_cb(from);
            
            public static bool operator ==(git_credential_acquire_cb left, git_credential_acquire_cb right) => left.Equals(right);
            
            public static bool operator !=(git_credential_acquire_cb left, git_credential_acquire_cb right) => !left.Equals(right);
        }
        
        public readonly partial struct git_credential_ssh_interactive_cb : IEquatable<git_credential_ssh_interactive_cb>
        {
            public git_credential_ssh_interactive_cb(delegate*unmanaged[Cdecl]<byte*, int, byte*, int, int, libgit2._LIBSSH2_USERAUTH_KBDINT_PROMPT, libgit2._LIBSSH2_USERAUTH_KBDINT_RESPONSE, void**, void> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<byte*, int, byte*, int, int, libgit2._LIBSSH2_USERAUTH_KBDINT_PROMPT, libgit2._LIBSSH2_USERAUTH_KBDINT_RESPONSE, void**, void> Value { get; }
            
            public override bool Equals(object obj) => obj is git_credential_ssh_interactive_cb other && Equals(other);
            
            public bool Equals(git_credential_ssh_interactive_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<byte*, int, byte*, int, int, libgit2._LIBSSH2_USERAUTH_KBDINT_PROMPT, libgit2._LIBSSH2_USERAUTH_KBDINT_RESPONSE, void**, void> (libgit2.git_credential_ssh_interactive_cb from) => from.Value;
            
            public static implicit operator libgit2.git_credential_ssh_interactive_cb (delegate*unmanaged[Cdecl]<byte*, int, byte*, int, int, libgit2._LIBSSH2_USERAUTH_KBDINT_PROMPT, libgit2._LIBSSH2_USERAUTH_KBDINT_RESPONSE, void**, void> from) => new libgit2.git_credential_ssh_interactive_cb(from);
            
            public static bool operator ==(git_credential_ssh_interactive_cb left, git_credential_ssh_interactive_cb right) => left.Equals(right);
            
            public static bool operator !=(git_credential_ssh_interactive_cb left, git_credential_ssh_interactive_cb right) => !left.Equals(right);
        }
        
        public readonly partial struct git_credential_sign_cb : IEquatable<git_credential_sign_cb>
        {
            public git_credential_sign_cb(delegate*unmanaged[Cdecl]<libgit2._LIBSSH2_SESSION, byte**, nuint*, byte*, nuint, void**, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2._LIBSSH2_SESSION, byte**, nuint*, byte*, nuint, void**, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_credential_sign_cb other && Equals(other);
            
            public bool Equals(git_credential_sign_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2._LIBSSH2_SESSION, byte**, nuint*, byte*, nuint, void**, int> (libgit2.git_credential_sign_cb from) => from.Value;
            
            public static implicit operator libgit2.git_credential_sign_cb (delegate*unmanaged[Cdecl]<libgit2._LIBSSH2_SESSION, byte**, nuint*, byte*, nuint, void**, int> from) => new libgit2.git_credential_sign_cb(from);
            
            public static bool operator ==(git_credential_sign_cb left, git_credential_sign_cb right) => left.Equals(right);
            
            public static bool operator !=(git_credential_sign_cb left, git_credential_sign_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Free a credential.
        /// </summary>
        /// <param name="cred">the object to free</param>
        /// <remarks>
        /// This is only necessary if you own the object; that is, if you are a
        /// transport.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_credential_free(libgit2.git_credential cred);
        
        /// <summary>
        /// Check whether a credential object contains username information.
        /// </summary>
        /// <param name="cred">object to check</param>
        /// <returns>@return 1 if the credential object has non-NULL username, 0 otherwise</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_has_username")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_credential_has_username(libgit2.git_credential cred);
        
        /// <summary>
        /// Return the username associated with a credential object.
        /// </summary>
        /// <param name="cred">object to check</param>
        /// <returns>@return the credential username, or NULL if not applicable</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_get_username")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_credential_get_username_(libgit2.git_credential cred);
        
        /// <summary>
        /// Return the username associated with a credential object.
        /// </summary>
        /// <param name="cred">object to check</param>
        /// <returns>@return the credential username, or NULL if not applicable</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_get_username")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_credential_get_username(libgit2.git_credential cred);
        
        /// <summary>
        /// Create a new plain-text username and password credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">The username of the credential.</param>
        /// <param name="password">The password of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_userpass_plaintext_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_userpass_plaintext_new(out libgit2.git_credential @out, byte* username, byte* password);
        
        /// <summary>
        /// Create a new plain-text username and password credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">The username of the credential.</param>
        /// <param name="password">The password of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_userpass_plaintext_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_userpass_plaintext_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> password);
        
        /// <summary>
        /// Create a "default" credential usable for Negotiate mechanisms like NTLM
        /// or Kerberos authentication.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_default_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_default_new(out libgit2.git_credential @out);
        
        /// <summary>
        /// Create a credential to specify a username.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">The username to authenticate with</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        /// <remarks>
        /// This is used with ssh authentication to query for the username if
        /// none is specified in the url.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_username_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_username_new(out libgit2.git_credential @out, byte* username);
        
        /// <summary>
        /// Create a credential to specify a username.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">The username to authenticate with</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        /// <remarks>
        /// This is used with ssh authentication to query for the username if
        /// none is specified in the url.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_username_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_username_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username);
        
        /// <summary>
        /// Create a new passphrase-protected ssh key credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <param name="publickey">The path to the public key of the credential.</param>
        /// <param name="privatekey">The path to the private key of the credential.</param>
        /// <param name="passphrase">The passphrase of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_new(out libgit2.git_credential @out, byte* username, byte* publickey, byte* privatekey, byte* passphrase);
        
        /// <summary>
        /// Create a new passphrase-protected ssh key credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <param name="publickey">The path to the public key of the credential.</param>
        /// <param name="privatekey">The path to the private key of the credential.</param>
        /// <param name="passphrase">The passphrase of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> publickey, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> privatekey, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> passphrase);
        
        /// <summary>
        /// Create a new ssh key credential object reading the keys from memory.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate.</param>
        /// <param name="publickey">The public key of the credential.</param>
        /// <param name="privatekey">The private key of the credential.</param>
        /// <param name="passphrase">The passphrase of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_memory_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_memory_new(out libgit2.git_credential @out, byte* username, byte* publickey, byte* privatekey, byte* passphrase);
        
        /// <summary>
        /// Create a new ssh key credential object reading the keys from memory.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate.</param>
        /// <param name="publickey">The public key of the credential.</param>
        /// <param name="privatekey">The private key of the credential.</param>
        /// <param name="passphrase">The passphrase of the credential.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_memory_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_memory_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> publickey, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> privatekey, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> passphrase);
        
        /// <summary>
        /// Create a new ssh keyboard-interactive based credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">Username to use to authenticate.</param>
        /// <param name="prompt_callback">The callback method used for prompts.</param>
        /// <param name="payload">Additional data to pass to the callback.</param>
        /// <returns>@return 0 for success or an error code for failure.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_interactive_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_interactive_new(out libgit2.git_credential @out, byte* username, libgit2.git_credential_ssh_interactive_cb prompt_callback, void* payload);
        
        /// <summary>
        /// Create a new ssh keyboard-interactive based credential object.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">Username to use to authenticate.</param>
        /// <param name="prompt_callback">The callback method used for prompts.</param>
        /// <param name="payload">Additional data to pass to the callback.</param>
        /// <returns>@return 0 for success or an error code for failure.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_interactive_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_interactive_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username, libgit2.git_credential_ssh_interactive_cb prompt_callback, void* payload);
        
        /// <summary>
        /// Create a new ssh key credential object used for querying an ssh-agent.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_from_agent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_from_agent(out libgit2.git_credential @out, byte* username);
        
        /// <summary>
        /// Create a new ssh key credential object used for querying an ssh-agent.
        /// The supplied credential parameter will be internally duplicated.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_key_from_agent")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_key_from_agent(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username);
        
        /// <summary>
        /// Create an ssh key credential with a custom signing function.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <param name="publickey">The bytes of the public key.</param>
        /// <param name="publickey_len">The length of the public key in bytes.</param>
        /// <param name="sign_callback">The callback method to sign the data during the challenge.</param>
        /// <param name="payload">Additional data to pass to the callback.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        /// <remarks>
        /// This lets you use your own function to sign the challenge.This function and its credential type is provided for completeness
        /// and wraps `libssh2_userauth_publickey()`, which is undocumented.The supplied credential parameter will be internally duplicated.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_custom_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_custom_new(out libgit2.git_credential @out, byte* username, byte* publickey, nuint publickey_len, libgit2.git_credential_sign_cb sign_callback, void* payload);
        
        /// <summary>
        /// Create an ssh key credential with a custom signing function.
        /// </summary>
        /// <param name="out">The newly created credential object.</param>
        /// <param name="username">username to use to authenticate</param>
        /// <param name="publickey">The bytes of the public key.</param>
        /// <param name="publickey_len">The length of the public key in bytes.</param>
        /// <param name="sign_callback">The callback method to sign the data during the challenge.</param>
        /// <param name="payload">Additional data to pass to the callback.</param>
        /// <returns>@return 0 for success or an error code for failure</returns>
        /// <remarks>
        /// This lets you use your own function to sign the challenge.This function and its credential type is provided for completeness
        /// and wraps `libssh2_userauth_publickey()`, which is undocumented.The supplied credential parameter will be internally duplicated.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_credential_ssh_custom_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_credential_ssh_custom_new(out libgit2.git_credential @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> username, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> publickey, nuint publickey_len, libgit2.git_credential_sign_cb sign_callback, void* payload);
    }
}
