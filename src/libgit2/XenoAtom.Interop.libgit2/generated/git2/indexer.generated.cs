//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// This structure is used to provide callers information about the
        /// progress of indexing a packfile, either directly or part of a
        /// fetch or clone that downloads a packfile.
        /// </summary>
        public partial struct git_indexer_progress
        {
            /// <summary>
            /// number of objects in the packfile being indexed
            /// </summary>
            public uint total_objects;
            
            /// <summary>
            /// received objects that have been hashed
            /// </summary>
            public uint indexed_objects;
            
            /// <summary>
            /// received_objects: objects which have been downloaded
            /// </summary>
            public uint received_objects;
            
            /// <summary>
            /// locally-available objects that have been injected in order
            /// to fix a thin pack
            /// </summary>
            public uint local_objects;
            
            /// <summary>
            /// number of deltas in the packfile being indexed
            /// </summary>
            public uint total_deltas;
            
            /// <summary>
            /// received deltas that have been indexed
            /// </summary>
            public uint indexed_deltas;
            
            /// <summary>
            /// size of the packfile received up to now
            /// </summary>
            public nuint received_bytes;
        }
        
        /// <summary>
        /// A git indexer object
        /// </summary>
        public readonly partial struct git_indexer : IEquatable<git_indexer>
        {
            public git_indexer(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_indexer other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_indexer other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_indexer left, git_indexer right) => left.Equals(right);
            
            public static bool operator !=(git_indexer left, git_indexer right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Options for indexer configuration
        /// </summary>
        public partial struct git_indexer_options
        {
            public uint version;
            
            /// <summary>
            /// progress_cb function to call with progress information
            /// </summary>
            public libgit2.git_indexer_progress_cb progress_cb;
            
            /// <summary>
            /// progress_cb_payload payload for the progress callback
            /// </summary>
            public void* progress_cb_payload;
            
            /// <summary>
            /// Do connectivity checks for the received pack
            /// </summary>
            public byte verify;
        }
        
        /// <summary>
        /// Type for progress callbacks during indexing.  Return a value less
        /// than zero to cancel the indexing or download.
        /// </summary>
        /// <param name="payload">Payload provided by caller</param>
        /// <param name="stats">Structure containing information about the state of the transfer</param>
        public readonly partial struct git_indexer_progress_cb : IEquatable<git_indexer_progress_cb>
        {
            public git_indexer_progress_cb(delegate*unmanaged[Cdecl]<libgit2.git_indexer_progress*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_indexer_progress*, void*, int> Value { get; }
            
            public override bool Equals(object obj) => obj is git_indexer_progress_cb other && Equals(other);
            
            public bool Equals(git_indexer_progress_cb other) => Value == other.Value;
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_indexer_progress*, void*, int> (libgit2.git_indexer_progress_cb from) => from.Value;
            
            public static implicit operator libgit2.git_indexer_progress_cb (delegate*unmanaged[Cdecl]<libgit2.git_indexer_progress*, void*, int> from) => new libgit2.git_indexer_progress_cb(from);
            
            public static bool operator ==(git_indexer_progress_cb left, git_indexer_progress_cb right) => left.Equals(right);
            
            public static bool operator !=(git_indexer_progress_cb left, git_indexer_progress_cb right) => !left.Equals(right);
        }
        
        public const uint GIT_INDEXER_OPTIONS_VERSION = 1;
        
        /// <summary>
        /// Initializes a `git_indexer_options` with default values. Equivalent to
        /// creating an instance with GIT_INDEXER_OPTIONS_INIT.
        /// </summary>
        /// <param name="opts">the `git_indexer_options` struct to initialize.</param>
        /// <param name="version">Version of struct; pass `GIT_INDEXER_OPTIONS_VERSION`</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_indexer_options_init(out libgit2.git_indexer_options opts, uint version);
        
        /// <summary>
        /// Create a new indexer instance
        /// </summary>
        /// <param name="out">where to store the indexer instance</param>
        /// <param name="path">to the directory where the packfile should be stored</param>
        /// <param name="mode">permissions to use creating packfile or 0 for defaults</param>
        /// <param name="odb">object database from which to read base objects when
        /// fixing thin packs. Pass NULL if no thin pack is expected (an error
        /// will be returned if there are bases missing)</param>
        /// <param name="opts">Optional structure containing additional options. See
        /// `git_indexer_options` above.</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_indexer_new(out libgit2.git_indexer @out, byte* path, uint mode, libgit2.git_odb odb, in libgit2.git_indexer_options opts);
        
        /// <summary>
        /// Create a new indexer instance
        /// </summary>
        /// <param name="out">where to store the indexer instance</param>
        /// <param name="path">to the directory where the packfile should be stored</param>
        /// <param name="mode">permissions to use creating packfile or 0 for defaults</param>
        /// <param name="odb">object database from which to read base objects when
        /// fixing thin packs. Pass NULL if no thin pack is expected (an error
        /// will be returned if there are bases missing)</param>
        /// <param name="opts">Optional structure containing additional options. See
        /// `git_indexer_options` above.</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_indexer_new(out libgit2.git_indexer @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, uint mode, libgit2.git_odb odb, in libgit2.git_indexer_options opts);
        
        /// <summary>
        /// Add data to the indexer
        /// </summary>
        /// <param name="idx">the indexer</param>
        /// <param name="data">the data to add</param>
        /// <param name="size">the size of the data in bytes</param>
        /// <param name="stats">stat storage</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_append")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_indexer_append(libgit2.git_indexer idx, void* data, nuint size, out libgit2.git_indexer_progress stats);
        
        /// <summary>
        /// Finalize the pack and index
        /// </summary>
        /// <param name="idx">the indexer</param>
        /// <param name="stats">Stat storage.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Resolve any pending deltas and write out the index file
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_commit")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_indexer_commit(libgit2.git_indexer idx, out libgit2.git_indexer_progress stats);
        
        /// <summary>
        /// Get the unique name for the resulting packfile.
        /// </summary>
        /// <param name="idx">the indexer instance</param>
        /// <returns>@return a NUL terminated string for the packfile name</returns>
        /// <remarks>
        /// The packfile's name is derived from the packfile's content.
        /// This is only correct after the index has been finalized.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_indexer_name_(libgit2.git_indexer idx);
        
        /// <summary>
        /// Get the unique name for the resulting packfile.
        /// </summary>
        /// <param name="idx">the indexer instance</param>
        /// <returns>@return a NUL terminated string for the packfile name</returns>
        /// <remarks>
        /// The packfile's name is derived from the packfile's content.
        /// This is only correct after the index has been finalized.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_name")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))]
        public static partial string git_indexer_name(libgit2.git_indexer idx);
        
        /// <summary>
        /// Free the indexer and its resources
        /// </summary>
        /// <param name="idx">the indexer to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_indexer_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_indexer_free(libgit2.git_indexer idx);
    }
}
