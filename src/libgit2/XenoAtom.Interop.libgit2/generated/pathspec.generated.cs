//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Options controlling how pathspec match should be executed
        /// </summary>
        [Flags]
        public enum git_pathspec_flag_t : int
        {
            GIT_PATHSPEC_DEFAULT = unchecked((int)0),
            
            /// <summary>
            /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
            /// match will use native case sensitivity of platform filesystem
            /// </summary>
            GIT_PATHSPEC_IGNORE_CASE = unchecked((int)(1u << (int)0)),
            
            /// <summary>
            /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
            /// match will use native case sensitivity of platform filesystem
            /// </summary>
            GIT_PATHSPEC_USE_CASE = unchecked((int)(1u << (int)1)),
            
            /// <summary>
            /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
            /// string comparison for matching
            /// </summary>
            GIT_PATHSPEC_NO_GLOB = unchecked((int)(1u << (int)2)),
            
            /// <summary>
            /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
            /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
            /// still success (return 0) but `git_pathspec_match_list_entrycount`
            /// will indicate 0 matches.
            /// </summary>
            GIT_PATHSPEC_NO_MATCH_ERROR = unchecked((int)(1u << (int)3)),
            
            /// <summary>
            /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
            /// should track which patterns matched which files so that at the end of
            /// the match we can identify patterns that did not match any files.
            /// </summary>
            GIT_PATHSPEC_FIND_FAILURES = unchecked((int)(1u << (int)4)),
            
            /// <summary>
            /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
            /// does not need to keep the actual matching filenames.  Use this to
            /// just test if there were any matches at all or in combination with
            /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
            /// </summary>
            GIT_PATHSPEC_FAILURES_ONLY = unchecked((int)(1u << (int)5)),
        }
        
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_DEFAULT = git_pathspec_flag_t.GIT_PATHSPEC_DEFAULT;
        
        /// <summary>
        /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
        /// match will use native case sensitivity of platform filesystem
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_IGNORE_CASE = git_pathspec_flag_t.GIT_PATHSPEC_IGNORE_CASE;
        
        /// <summary>
        /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
        /// match will use native case sensitivity of platform filesystem
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_USE_CASE = git_pathspec_flag_t.GIT_PATHSPEC_USE_CASE;
        
        /// <summary>
        /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
        /// string comparison for matching
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_NO_GLOB = git_pathspec_flag_t.GIT_PATHSPEC_NO_GLOB;
        
        /// <summary>
        /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
        /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
        /// still success (return 0) but `git_pathspec_match_list_entrycount`
        /// will indicate 0 matches.
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_NO_MATCH_ERROR = git_pathspec_flag_t.GIT_PATHSPEC_NO_MATCH_ERROR;
        
        /// <summary>
        /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
        /// should track which patterns matched which files so that at the end of
        /// the match we can identify patterns that did not match any files.
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_FIND_FAILURES = git_pathspec_flag_t.GIT_PATHSPEC_FIND_FAILURES;
        
        /// <summary>
        /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
        /// does not need to keep the actual matching filenames.  Use this to
        /// just test if there were any matches at all or in combination with
        /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
        /// </summary>
        public const libgit2.git_pathspec_flag_t GIT_PATHSPEC_FAILURES_ONLY = git_pathspec_flag_t.GIT_PATHSPEC_FAILURES_ONLY;
        
        /// <summary>
        /// Compiled pathspec
        /// </summary>
        public readonly partial struct git_pathspec : IEquatable<git_pathspec>
        {
            public git_pathspec(nint handle) => Handle = handle;
            
            public readonly nint Handle;
            
            public bool Equals(git_pathspec other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_pathspec other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_pathspec left, git_pathspec right) => left.Equals(right);
            
            public static bool operator !=(git_pathspec left, git_pathspec right) => !left.Equals(right);
        }
        
        /// <summary>
        /// List of filenames matching a pathspec
        /// </summary>
        public readonly partial struct git_pathspec_match_list : IEquatable<git_pathspec_match_list>
        {
            public git_pathspec_match_list(nint handle) => Handle = handle;
            
            public readonly nint Handle;
            
            public bool Equals(git_pathspec_match_list other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_pathspec_match_list other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_pathspec_match_list left, git_pathspec_match_list right) => left.Equals(right);
            
            public static bool operator !=(git_pathspec_match_list left, git_pathspec_match_list right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Compile a pathspec
        /// </summary>
        /// <param name="out">Output of the compiled pathspec</param>
        /// <param name="pathspec">A git_strarray of the paths to match</param>
        /// <returns>@return 0 on success, 
        /// &lt;
        /// 0 on failure</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_pathspec_new(out libgit2.git_pathspec @out, in libgit2.git_strarray pathspec);
        
        /// <summary>
        /// Free a pathspec
        /// </summary>
        /// <param name="ps">The compiled pathspec</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_pathspec_free(libgit2.git_pathspec ps);
        
        /// <summary>
        /// Try to match a path against a pathspec
        /// </summary>
        /// <param name="ps">The compiled pathspec</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="path">The pathname to attempt to match</param>
        /// <returns>@return 1 is path matches spec, 0 if it does not</returns>
        /// <remarks>
        /// Unlike most of the other pathspec matching functions, this will not
        /// fall back on the native case-sensitivity for your platform.  You must
        /// explicitly pass flags to control case sensitivity or else this will
        /// fall back on being case sensitive.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_matches_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_pathspec_matches_path(libgit2.git_pathspec ps, libgit2.git_pathspec_flag_t flags, byte* path);
        
        /// <summary>
        /// Try to match a path against a pathspec
        /// </summary>
        /// <param name="ps">The compiled pathspec</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="path">The pathname to attempt to match</param>
        /// <returns>@return 1 is path matches spec, 0 if it does not</returns>
        /// <remarks>
        /// Unlike most of the other pathspec matching functions, this will not
        /// fall back on the native case-sensitivity for your platform.  You must
        /// explicitly pass flags to control case sensitivity or else this will
        /// fall back on being case sensitive.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_matches_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_pathspec_matches_path(libgit2.git_pathspec ps, libgit2.git_pathspec_flag_t flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Match a pathspec against the working directory of a repository.
        /// </summary>
        /// <param name="out">Output list of matches; pass NULL to just get return value</param>
        /// <param name="repo">The repository in which to match; bare repo is an error</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="ps">Pathspec to be matched</param>
        /// <returns>@return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
        /// the GIT_PATHSPEC_NO_MATCH_ERROR flag was given</returns>
        /// <remarks>
        /// This matches the pathspec against the current files in the working
        /// directory of the repository.  It is an error to invoke this on a bare
        /// repo.  This handles git ignores (i.e. ignored files will not be
        /// considered to match the `pathspec` unless the file is tracked in the
        /// index).If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
        /// contains the list of all matched filenames (unless you pass the
        /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
        /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
        /// flag).  You must call `git_pathspec_match_list_free()` on this object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_pathspec_match_workdir(out libgit2.git_pathspec_match_list @out, libgit2.git_repository repo, libgit2.git_pathspec_flag_t flags, libgit2.git_pathspec ps);
        
        /// <summary>
        /// Match a pathspec against entries in an index.
        /// </summary>
        /// <param name="out">Output list of matches; pass NULL to just get return value</param>
        /// <param name="index">The index to match against</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="ps">Pathspec to be matched</param>
        /// <returns>@return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
        /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used</returns>
        /// <remarks>
        /// This matches the pathspec against the files in the repository index.NOTE: At the moment, the case sensitivity of this match is controlled
        /// by the current case-sensitivity of the index object itself and the
        /// USE_CASE and IGNORE_CASE flags will have no effect.  This behavior will
        /// be corrected in a future release.If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
        /// contains the list of all matched filenames (unless you pass the
        /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
        /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
        /// flag).  You must call `git_pathspec_match_list_free()` on this object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_pathspec_match_index(out libgit2.git_pathspec_match_list @out, libgit2.git_index index, libgit2.git_pathspec_flag_t flags, libgit2.git_pathspec ps);
        
        /// <summary>
        /// Match a pathspec against files in a tree.
        /// </summary>
        /// <param name="out">Output list of matches; pass NULL to just get return value</param>
        /// <param name="tree">The root-level tree to match against</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="ps">Pathspec to be matched</param>
        /// <returns>@return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
        /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used</returns>
        /// <remarks>
        /// This matches the pathspec against the files in the given tree.If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
        /// contains the list of all matched filenames (unless you pass the
        /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
        /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
        /// flag).  You must call `git_pathspec_match_list_free()` on this object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_pathspec_match_tree(out libgit2.git_pathspec_match_list @out, libgit2.git_tree tree, libgit2.git_pathspec_flag_t flags, libgit2.git_pathspec ps);
        
        /// <summary>
        /// Match a pathspec against files in a diff list.
        /// </summary>
        /// <param name="out">Output list of matches; pass NULL to just get return value</param>
        /// <param name="diff">A generated diff list</param>
        /// <param name="flags">Combination of git_pathspec_flag_t options to control match</param>
        /// <param name="ps">Pathspec to be matched</param>
        /// <returns>@return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
        /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used</returns>
        /// <remarks>
        /// This matches the pathspec against the files in the given diff list.If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
        /// contains the list of all matched filenames (unless you pass the
        /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
        /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
        /// flag).  You must call `git_pathspec_match_list_free()` on this object.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_diff")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_pathspec_match_diff(out libgit2.git_pathspec_match_list @out, libgit2.git_diff diff, libgit2.git_pathspec_flag_t flags, libgit2.git_pathspec ps);
        
        /// <summary>
        /// Free memory associates with a git_pathspec_match_list
        /// </summary>
        /// <param name="m">The git_pathspec_match_list to be freed</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_pathspec_match_list_free(libgit2.git_pathspec_match_list m);
        
        /// <summary>
        /// Get the number of items in a match list.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <returns>@return Number of items in match list</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_entrycount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_pathspec_match_list_entrycount(libgit2.git_pathspec_match_list m);
        
        /// <summary>
        /// Get a matching filename by position.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <param name="pos">The index into the list</param>
        /// <returns>@return The filename of the match</returns>
        /// <remarks>
        /// This routine cannot be used if the match list was generated by
        /// `git_pathspec_match_diff`.  If so, it will always return NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_pathspec_match_list_entry(libgit2.git_pathspec_match_list m, libgit2.size_t pos);
        
        /// <summary>
        /// Get a matching filename by position.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <param name="pos">The index into the list</param>
        /// <returns>@return The filename of the match</returns>
        /// <remarks>
        /// This routine cannot be used if the match list was generated by
        /// `git_pathspec_match_diff`.  If so, it will always return NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))]
        public static partial string git_pathspec_match_list_entry_string(libgit2.git_pathspec_match_list m, libgit2.size_t pos);
        
        /// <summary>
        /// Get a matching diff delta by position.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <param name="pos">The index into the list</param>
        /// <returns>@return The filename of the match</returns>
        /// <remarks>
        /// This routine can only be used if the match list was generated by
        /// `git_pathspec_match_diff`.  Otherwise it will always return NULL.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_diff_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_diff_delta* git_pathspec_match_list_diff_entry(libgit2.git_pathspec_match_list m, libgit2.size_t pos);
        
        /// <summary>
        /// Get the number of pathspec items that did not match.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <returns>@return Number of items in original pathspec that had no matches</returns>
        /// <remarks>
        /// This will be zero unless you passed GIT_PATHSPEC_FIND_FAILURES when
        /// generating the git_pathspec_match_list.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_failed_entrycount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_pathspec_match_list_failed_entrycount(libgit2.git_pathspec_match_list m);
        
        /// <summary>
        /// Get an original pathspec string that had no matches.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <param name="pos">The index into the failed items</param>
        /// <returns>@return The pathspec pattern that didn't match anything</returns>
        /// <remarks>
        /// This will be return NULL for positions out of range.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_failed_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte* git_pathspec_match_list_failed_entry(libgit2.git_pathspec_match_list m, libgit2.size_t pos);
        
        /// <summary>
        /// Get an original pathspec string that had no matches.
        /// </summary>
        /// <param name="m">The git_pathspec_match_list object</param>
        /// <param name="pos">The index into the failed items</param>
        /// <returns>@return The pathspec pattern that didn't match anything</returns>
        /// <remarks>
        /// This will be return NULL for positions out of range.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_pathspec_match_list_failed_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8CustomMarshaller))]
        public static partial string git_pathspec_match_list_failed_entry_string(libgit2.git_pathspec_match_list m, libgit2.size_t pos);
    }
}
