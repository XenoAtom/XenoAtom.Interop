//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Basic type (loose or packed) of any Git object.
        /// </summary>
        public enum git_object_t : int
        {
            /// <summary>
            /// Object can be any of the following
            /// </summary>
            GIT_OBJECT_ANY = unchecked((int)-2),
            
            /// <summary>
            /// Object is invalid.
            /// </summary>
            GIT_OBJECT_INVALID = unchecked((int)-1),
            
            /// <summary>
            /// A commit object.
            /// </summary>
            GIT_OBJECT_COMMIT = unchecked((int)1),
            
            /// <summary>
            /// A tree (directory listing) object.
            /// </summary>
            GIT_OBJECT_TREE = unchecked((int)2),
            
            /// <summary>
            /// A file revision object.
            /// </summary>
            GIT_OBJECT_BLOB = unchecked((int)3),
            
            /// <summary>
            /// An annotated tag object.
            /// </summary>
            GIT_OBJECT_TAG = unchecked((int)4),
            
            /// <summary>
            /// A delta, base is given by an offset.
            /// </summary>
            GIT_OBJECT_OFS_DELTA = unchecked((int)6),
            
            /// <summary>
            /// A delta, base is given by object id.
            /// </summary>
            GIT_OBJECT_REF_DELTA = unchecked((int)7),
        }
        
        /// <summary>
        /// Object can be any of the following
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_ANY = git_object_t.GIT_OBJECT_ANY;
        
        /// <summary>
        /// Object is invalid.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_INVALID = git_object_t.GIT_OBJECT_INVALID;
        
        /// <summary>
        /// A commit object.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_COMMIT = git_object_t.GIT_OBJECT_COMMIT;
        
        /// <summary>
        /// A tree (directory listing) object.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_TREE = git_object_t.GIT_OBJECT_TREE;
        
        /// <summary>
        /// A file revision object.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_BLOB = git_object_t.GIT_OBJECT_BLOB;
        
        /// <summary>
        /// An annotated tag object.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_TAG = git_object_t.GIT_OBJECT_TAG;
        
        /// <summary>
        /// A delta, base is given by an offset.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_OFS_DELTA = git_object_t.GIT_OBJECT_OFS_DELTA;
        
        /// <summary>
        /// A delta, base is given by object id.
        /// </summary>
        public const libgit2.git_object_t GIT_OBJECT_REF_DELTA = git_object_t.GIT_OBJECT_REF_DELTA;
        
        /// <summary>
        /// Basic type of any Git reference.
        /// </summary>
        public enum git_reference_t : uint
        {
            /// <summary>
            /// Invalid reference
            /// </summary>
            GIT_REFERENCE_INVALID = unchecked((uint)0),
            
            /// <summary>
            /// A reference that points at an object id
            /// </summary>
            GIT_REFERENCE_DIRECT = unchecked((uint)1),
            
            /// <summary>
            /// A reference that points at another reference
            /// </summary>
            GIT_REFERENCE_SYMBOLIC = unchecked((uint)2),
            
            GIT_REFERENCE_ALL = unchecked((uint)GIT_REFERENCE_DIRECT|GIT_REFERENCE_SYMBOLIC),
        }
        
        /// <summary>
        /// Invalid reference
        /// </summary>
        public const libgit2.git_reference_t GIT_REFERENCE_INVALID = git_reference_t.GIT_REFERENCE_INVALID;
        
        /// <summary>
        /// A reference that points at an object id
        /// </summary>
        public const libgit2.git_reference_t GIT_REFERENCE_DIRECT = git_reference_t.GIT_REFERENCE_DIRECT;
        
        /// <summary>
        /// A reference that points at another reference
        /// </summary>
        public const libgit2.git_reference_t GIT_REFERENCE_SYMBOLIC = git_reference_t.GIT_REFERENCE_SYMBOLIC;
        
        public const libgit2.git_reference_t GIT_REFERENCE_ALL = git_reference_t.GIT_REFERENCE_ALL;
        
        /// <summary>
        /// Basic type of any Git branch.
        /// </summary>
        public enum git_branch_t : uint
        {
            GIT_BRANCH_LOCAL = unchecked((uint)1),
            
            GIT_BRANCH_REMOTE = unchecked((uint)2),
            
            GIT_BRANCH_ALL = unchecked((uint)GIT_BRANCH_LOCAL|GIT_BRANCH_REMOTE),
        }
        
        public const libgit2.git_branch_t GIT_BRANCH_LOCAL = git_branch_t.GIT_BRANCH_LOCAL;
        
        public const libgit2.git_branch_t GIT_BRANCH_REMOTE = git_branch_t.GIT_BRANCH_REMOTE;
        
        public const libgit2.git_branch_t GIT_BRANCH_ALL = git_branch_t.GIT_BRANCH_ALL;
        
        /// <summary>
        /// Valid modes for index and tree entries.
        /// </summary>
        public enum git_filemode_t : uint
        {
            GIT_FILEMODE_UNREADABLE = unchecked((uint)0000000),
            
            GIT_FILEMODE_TREE = unchecked((uint)0040000),
            
            GIT_FILEMODE_BLOB = unchecked((uint)0100644),
            
            GIT_FILEMODE_BLOB_EXECUTABLE = unchecked((uint)0100755),
            
            GIT_FILEMODE_LINK = unchecked((uint)0120000),
            
            GIT_FILEMODE_COMMIT = unchecked((uint)0160000),
        }
        
        public const libgit2.git_filemode_t GIT_FILEMODE_UNREADABLE = git_filemode_t.GIT_FILEMODE_UNREADABLE;
        
        public const libgit2.git_filemode_t GIT_FILEMODE_TREE = git_filemode_t.GIT_FILEMODE_TREE;
        
        public const libgit2.git_filemode_t GIT_FILEMODE_BLOB = git_filemode_t.GIT_FILEMODE_BLOB;
        
        public const libgit2.git_filemode_t GIT_FILEMODE_BLOB_EXECUTABLE = git_filemode_t.GIT_FILEMODE_BLOB_EXECUTABLE;
        
        public const libgit2.git_filemode_t GIT_FILEMODE_LINK = git_filemode_t.GIT_FILEMODE_LINK;
        
        public const libgit2.git_filemode_t GIT_FILEMODE_COMMIT = git_filemode_t.GIT_FILEMODE_COMMIT;
        
        /// <summary>
        /// Submodule update values
        /// </summary>
        /// <remarks>
        /// These values represent settings for the `submodule.$name.update`
        /// configuration value which says how to handle `git submodule update` for
        /// this submodule.  The value is usually set in the ".gitmodules" file and
        /// copied to ".git/config" when the submodule is initialized.You can override this setting on a per-submodule basis with
        /// `git_submodule_set_update()` and write the changed value to disk using
        /// `git_submodule_save()`.  If you have overwritten the value, you can
        /// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.The values are:- GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
        /// updated, checkout the new detached HEAD to the submodule directory.
        /// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
        /// out branch onto the commit from the superproject.
        /// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
        /// superproject into the current checkout out branch of the submodule.
        /// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
        /// the commit in the superproject is updated.
        /// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
        /// when we don't want any particular update rule to be specified.
        /// </remarks>
        public enum git_submodule_update_t : uint
        {
            GIT_SUBMODULE_UPDATE_CHECKOUT = unchecked((uint)1),
            
            GIT_SUBMODULE_UPDATE_REBASE = unchecked((uint)2),
            
            GIT_SUBMODULE_UPDATE_MERGE = unchecked((uint)3),
            
            GIT_SUBMODULE_UPDATE_NONE = unchecked((uint)4),
            
            GIT_SUBMODULE_UPDATE_DEFAULT = unchecked((uint)0),
        }
        
        public const libgit2.git_submodule_update_t GIT_SUBMODULE_UPDATE_CHECKOUT = git_submodule_update_t.GIT_SUBMODULE_UPDATE_CHECKOUT;
        
        public const libgit2.git_submodule_update_t GIT_SUBMODULE_UPDATE_REBASE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_REBASE;
        
        public const libgit2.git_submodule_update_t GIT_SUBMODULE_UPDATE_MERGE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_MERGE;
        
        public const libgit2.git_submodule_update_t GIT_SUBMODULE_UPDATE_NONE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_NONE;
        
        public const libgit2.git_submodule_update_t GIT_SUBMODULE_UPDATE_DEFAULT = git_submodule_update_t.GIT_SUBMODULE_UPDATE_DEFAULT;
        
        /// <summary>
        /// Submodule ignore values
        /// </summary>
        /// <remarks>
        /// These values represent settings for the `submodule.$name.ignore`
        /// configuration value which says how deeply to look at the working
        /// directory when getting submodule status.You can override this value in memory on a per-submodule basis with
        /// `git_submodule_set_ignore()` and can write the changed value to disk
        /// with `git_submodule_save()`.  If you have overwritten the value, you
        /// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.The values are:- GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
        /// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
        /// untracked file, will mark the submodule as dirty.  Ignored files are
        /// still ignored, of course.
        /// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
        /// to tracked files, or the index or the HEAD commit will matter.
        /// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
        /// only considering changes if the HEAD of submodule has moved from the
        /// value in the superproject.
        /// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
        /// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
        /// when we don't want any particular ignore rule to be specified.
        /// </remarks>
        public enum git_submodule_ignore_t : int
        {
            /// <summary>
            /// use the submodule's configuration
            /// </summary>
            GIT_SUBMODULE_IGNORE_UNSPECIFIED = unchecked((int)-1),
            
            /// <summary>
            /// any change or untracked == dirty
            /// </summary>
            GIT_SUBMODULE_IGNORE_NONE = unchecked((int)1),
            
            /// <summary>
            /// dirty if tracked files change
            /// </summary>
            GIT_SUBMODULE_IGNORE_UNTRACKED = unchecked((int)2),
            
            /// <summary>
            /// only dirty if HEAD moved
            /// </summary>
            GIT_SUBMODULE_IGNORE_DIRTY = unchecked((int)3),
            
            /// <summary>
            /// never dirty
            /// </summary>
            GIT_SUBMODULE_IGNORE_ALL = unchecked((int)4),
        }
        
        /// <summary>
        /// use the submodule's configuration
        /// </summary>
        public const libgit2.git_submodule_ignore_t GIT_SUBMODULE_IGNORE_UNSPECIFIED = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_UNSPECIFIED;
        
        /// <summary>
        /// any change or untracked == dirty
        /// </summary>
        public const libgit2.git_submodule_ignore_t GIT_SUBMODULE_IGNORE_NONE = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_NONE;
        
        /// <summary>
        /// dirty if tracked files change
        /// </summary>
        public const libgit2.git_submodule_ignore_t GIT_SUBMODULE_IGNORE_UNTRACKED = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_UNTRACKED;
        
        /// <summary>
        /// only dirty if HEAD moved
        /// </summary>
        public const libgit2.git_submodule_ignore_t GIT_SUBMODULE_IGNORE_DIRTY = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_DIRTY;
        
        /// <summary>
        /// never dirty
        /// </summary>
        public const libgit2.git_submodule_ignore_t GIT_SUBMODULE_IGNORE_ALL = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_ALL;
        
        /// <summary>
        /// Options for submodule recurse.
        /// </summary>
        /// <remarks>
        /// Represent the value of `submodule.$name.fetchRecurseSubmodules`* GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
        /// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
        /// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
        /// commit not already in local clone
        /// </remarks>
        public enum git_submodule_recurse_t : uint
        {
            GIT_SUBMODULE_RECURSE_NO = unchecked((uint)0),
            
            GIT_SUBMODULE_RECURSE_YES = unchecked((uint)1),
            
            GIT_SUBMODULE_RECURSE_ONDEMAND = unchecked((uint)2),
        }
        
        public const libgit2.git_submodule_recurse_t GIT_SUBMODULE_RECURSE_NO = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_NO;
        
        public const libgit2.git_submodule_recurse_t GIT_SUBMODULE_RECURSE_YES = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_YES;
        
        public const libgit2.git_submodule_recurse_t GIT_SUBMODULE_RECURSE_ONDEMAND = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_ONDEMAND;
        
        /// <summary>
        /// An open object database handle.
        /// </summary>
        public readonly partial struct git_odb : IEquatable<git_odb>
        {
            public git_odb(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_odb other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_odb other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_odb left, git_odb right) => left.Equals(right);
            
            public static bool operator !=(git_odb left, git_odb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A custom backend in an ODB
        /// </summary>
        public readonly partial struct git_odb_backend : IEquatable<git_odb_backend>
        {
            public git_odb_backend(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_odb_backend other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_odb_backend other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_odb_backend left, git_odb_backend right) => left.Equals(right);
            
            public static bool operator !=(git_odb_backend left, git_odb_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An object read from the ODB
        /// </summary>
        public readonly partial struct git_odb_object : IEquatable<git_odb_object>
        {
            public git_odb_object(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_odb_object other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_odb_object other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_odb_object left, git_odb_object right) => left.Equals(right);
            
            public static bool operator !=(git_odb_object left, git_odb_object right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A stream to read/write from a backend.
        /// </summary>
        /// <remarks>
        /// This represents a stream of data being written to or read from a
        /// backend. When writing, the frontend functions take care of
        /// calculating the object's id and all `finalize_write` needs to do is
        /// store the object with the id it is passed.
        /// </remarks>
        public partial struct git_odb_stream
        {
            public libgit2.git_odb_backend backend;
            
            public uint mode;
            
            public void* hash_ctx;
            
            public libgit2.git_object_size_t declared_size;
            
            public libgit2.git_object_size_t received_bytes;
            
            /// <summary>
            /// Write at most `len` bytes into `buffer` and advance the stream.
            /// </summary>
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_stream*, byte*, libgit2.size_t, int> read;
            
            /// <summary>
            /// Write `len` bytes from `buffer` into the stream.
            /// </summary>
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_stream*, byte*, libgit2.size_t, int> write;
            
            /// <summary>
            /// Store the contents of the stream as an object with the id
            /// specified in `oid`.
            /// </summary>
            /// <remarks>
            /// This method might not be invoked if:
            /// - an error occurs earlier with the `write` callback,
            /// - the object referred to by `oid` already exists in any backend, or
            /// - the final number of received bytes differs from the size declared
            /// with `git_odb_open_wstream()`
            /// </remarks>
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_stream*, libgit2.git_oid*, int> finalize_write;
            
            /// <summary>
            /// Free the stream's memory.
            /// </summary>
            /// <remarks>
            /// This method might be called without a call to `finalize_write` if
            /// an error occurs or if the object is already present in the ODB.
            /// </remarks>
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_stream*, void> free;
        }
        
        /// <summary>
        /// The maximum size of an object
        /// </summary>
        public readonly partial struct git_object_size_t : IEquatable<git_object_size_t>
        {
            public git_object_size_t(ulong value) => this.Value = value;
            
            public ulong Value { get; }
            
            public bool Equals(git_object_size_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is git_object_size_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(git_object_size_t from) => from.Value;
            
            public static implicit operator git_object_size_t(ulong from) => new git_object_size_t(from);
            
            public static bool operator ==(git_object_size_t left, git_object_size_t right) => left.Equals(right);
            
            public static bool operator !=(git_object_size_t left, git_object_size_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A stream to write a pack file to the ODB
        /// </summary>
        public partial struct git_odb_writepack
        {
            public libgit2.git_odb_backend backend;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_writepack*, void*, libgit2.size_t, libgit2.git_indexer_progress*, int> append;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_writepack*, libgit2.git_indexer_progress*, int> commit;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_odb_writepack*, void> free;
        }
        
        /// <summary>
        /// a writer for multi-pack-index files.
        /// </summary>
        public readonly partial struct git_midx_writer : IEquatable<git_midx_writer>
        {
            public git_midx_writer(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_midx_writer other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_midx_writer other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_midx_writer left, git_midx_writer right) => left.Equals(right);
            
            public static bool operator !=(git_midx_writer left, git_midx_writer right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An open refs database handle.
        /// </summary>
        public readonly partial struct git_refdb : IEquatable<git_refdb>
        {
            public git_refdb(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_refdb other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_refdb other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_refdb left, git_refdb right) => left.Equals(right);
            
            public static bool operator !=(git_refdb left, git_refdb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A custom backend for refs
        /// </summary>
        public readonly partial struct git_refdb_backend : IEquatable<git_refdb_backend>
        {
            public git_refdb_backend(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_refdb_backend other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_refdb_backend other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_refdb_backend left, git_refdb_backend right) => left.Equals(right);
            
            public static bool operator !=(git_refdb_backend left, git_refdb_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A git commit-graph
        /// </summary>
        public readonly partial struct git_commit_graph : IEquatable<git_commit_graph>
        {
            public git_commit_graph(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_commit_graph other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_commit_graph other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_commit_graph left, git_commit_graph right) => left.Equals(right);
            
            public static bool operator !=(git_commit_graph left, git_commit_graph right) => !left.Equals(right);
        }
        
        /// <summary>
        /// a writer for commit-graph files.
        /// </summary>
        public readonly partial struct git_commit_graph_writer : IEquatable<git_commit_graph_writer>
        {
            public git_commit_graph_writer(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_commit_graph_writer other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_commit_graph_writer other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_commit_graph_writer left, git_commit_graph_writer right) => left.Equals(right);
            
            public static bool operator !=(git_commit_graph_writer left, git_commit_graph_writer right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of an existing git repository,
        /// including all its object contents
        /// </summary>
        public readonly partial struct git_repository : IEquatable<git_repository>
        {
            public git_repository(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_repository other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_repository other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_repository left, git_repository right) => left.Equals(right);
            
            public static bool operator !=(git_repository left, git_repository right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a working tree
        /// </summary>
        public readonly partial struct git_worktree : IEquatable<git_worktree>
        {
            public git_worktree(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_worktree other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_worktree other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_worktree left, git_worktree right) => left.Equals(right);
            
            public static bool operator !=(git_worktree left, git_worktree right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a generic object in a repository
        /// </summary>
        public readonly partial struct git_object : IEquatable<git_object>
        {
            public git_object(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_object other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_object other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_object left, git_object right) => left.Equals(right);
            
            public static bool operator !=(git_object left, git_object right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of an in-progress walk through the commits in a repo
        /// </summary>
        public readonly partial struct git_revwalk : IEquatable<git_revwalk>
        {
            public git_revwalk(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_revwalk other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_revwalk other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_revwalk left, git_revwalk right) => left.Equals(right);
            
            public static bool operator !=(git_revwalk left, git_revwalk right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Parsed representation of a tag object.
        /// </summary>
        public readonly partial struct git_tag : IEquatable<git_tag>
        {
            public git_tag(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_tag other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_tag other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_tag left, git_tag right) => left.Equals(right);
            
            public static bool operator !=(git_tag left, git_tag right) => !left.Equals(right);
        }
        
        /// <summary>
        /// In-memory representation of a blob object.
        /// </summary>
        public readonly partial struct git_blob : IEquatable<git_blob>
        {
            public git_blob(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_blob other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_blob other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_blob left, git_blob right) => left.Equals(right);
            
            public static bool operator !=(git_blob left, git_blob right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Parsed representation of a commit object.
        /// </summary>
        public readonly partial struct git_commit : IEquatable<git_commit>
        {
            public git_commit(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_commit other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_commit other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_commit left, git_commit right) => left.Equals(right);
            
            public static bool operator !=(git_commit left, git_commit right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of each one of the entries in a tree object.
        /// </summary>
        public readonly partial struct git_tree_entry : IEquatable<git_tree_entry>
        {
            public git_tree_entry(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_tree_entry other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_tree_entry other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_tree_entry left, git_tree_entry right) => left.Equals(right);
            
            public static bool operator !=(git_tree_entry left, git_tree_entry right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a tree object.
        /// </summary>
        public readonly partial struct git_tree : IEquatable<git_tree>
        {
            public git_tree(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_tree other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_tree other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_tree left, git_tree right) => left.Equals(right);
            
            public static bool operator !=(git_tree left, git_tree right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Constructor for in-memory trees
        /// </summary>
        public readonly partial struct git_treebuilder : IEquatable<git_treebuilder>
        {
            public git_treebuilder(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_treebuilder other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_treebuilder other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_treebuilder left, git_treebuilder right) => left.Equals(right);
            
            public static bool operator !=(git_treebuilder left, git_treebuilder right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Memory representation of an index file.
        /// </summary>
        public readonly partial struct git_index : IEquatable<git_index>
        {
            public git_index(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_index other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_index other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_index left, git_index right) => left.Equals(right);
            
            public static bool operator !=(git_index left, git_index right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An iterator for entries in the index.
        /// </summary>
        public readonly partial struct git_index_iterator : IEquatable<git_index_iterator>
        {
            public git_index_iterator(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_index_iterator other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_index_iterator other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_index_iterator left, git_index_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_index_iterator left, git_index_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An iterator for conflicts in the index.
        /// </summary>
        public readonly partial struct git_index_conflict_iterator : IEquatable<git_index_conflict_iterator>
        {
            public git_index_conflict_iterator(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_index_conflict_iterator other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_index_conflict_iterator other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_index_conflict_iterator left, git_index_conflict_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_index_conflict_iterator left, git_index_conflict_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Memory representation of a set of config files
        /// </summary>
        public readonly partial struct git_config : IEquatable<git_config>
        {
            public git_config(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_config other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_config other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_config left, git_config right) => left.Equals(right);
            
            public static bool operator !=(git_config left, git_config right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Interface to access a configuration file
        /// </summary>
        public readonly partial struct git_config_backend : IEquatable<git_config_backend>
        {
            public git_config_backend(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_config_backend other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_config_backend other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_config_backend left, git_config_backend right) => left.Equals(right);
            
            public static bool operator !=(git_config_backend left, git_config_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a reference log entry
        /// </summary>
        public readonly partial struct git_reflog_entry : IEquatable<git_reflog_entry>
        {
            public git_reflog_entry(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_reflog_entry other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_reflog_entry other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_reflog_entry left, git_reflog_entry right) => left.Equals(right);
            
            public static bool operator !=(git_reflog_entry left, git_reflog_entry right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a reference log
        /// </summary>
        public readonly partial struct git_reflog : IEquatable<git_reflog>
        {
            public git_reflog(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_reflog other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_reflog other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_reflog left, git_reflog right) => left.Equals(right);
            
            public static bool operator !=(git_reflog left, git_reflog right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a git note
        /// </summary>
        public readonly partial struct git_note : IEquatable<git_note>
        {
            public git_note(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_note other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_note other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_note left, git_note right) => left.Equals(right);
            
            public static bool operator !=(git_note left, git_note right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a git packbuilder
        /// </summary>
        public readonly partial struct git_packbuilder : IEquatable<git_packbuilder>
        {
            public git_packbuilder(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_packbuilder other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_packbuilder other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_packbuilder left, git_packbuilder right) => left.Equals(right);
            
            public static bool operator !=(git_packbuilder left, git_packbuilder right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Time in a signature
        /// </summary>
        public partial struct git_time
        {
            /// <summary>
            /// time in seconds from epoch
            /// </summary>
            public libgit2.git_time_t time;
            
            /// <summary>
            /// timezone offset, in minutes
            /// </summary>
            public int offset;
            
            /// <summary>
            /// indicator for questionable '-0000' offsets in signature
            /// </summary>
            public byte sign;
        }
        
        public readonly partial struct git_time_t : IEquatable<git_time_t>
        {
            public git_time_t(int value) => this.Value = value;
            
            public int Value { get; }
            
            public bool Equals(git_time_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is git_time_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator int(git_time_t from) => from.Value;
            
            public static implicit operator git_time_t(int from) => new git_time_t(from);
            
            public static bool operator ==(git_time_t left, git_time_t right) => left.Equals(right);
            
            public static bool operator !=(git_time_t left, git_time_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An action signature (e.g. for committers, taggers, etc)
        /// </summary>
        public partial struct git_signature
        {
            /// <summary>
            /// full name of the author
            /// </summary>
            public byte* name;
            
            /// <summary>
            /// email of the author
            /// </summary>
            public byte* email;
            
            /// <summary>
            /// time when the action happened
            /// </summary>
            public libgit2.git_time when;
        }
        
        /// <summary>
        /// In-memory representation of a reference.
        /// </summary>
        public readonly partial struct git_reference : IEquatable<git_reference>
        {
            public git_reference(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_reference other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_reference other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_reference left, git_reference right) => left.Equals(right);
            
            public static bool operator !=(git_reference left, git_reference right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Iterator for references
        /// </summary>
        public readonly partial struct git_reference_iterator : IEquatable<git_reference_iterator>
        {
            public git_reference_iterator(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_reference_iterator other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_reference_iterator other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_reference_iterator left, git_reference_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_reference_iterator left, git_reference_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Transactional interface to references
        /// </summary>
        public readonly partial struct git_transaction : IEquatable<git_transaction>
        {
            public git_transaction(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_transaction other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_transaction other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_transaction left, git_transaction right) => left.Equals(right);
            
            public static bool operator !=(git_transaction left, git_transaction right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Annotated commits, the input to merge and rebase.
        /// </summary>
        public readonly partial struct git_annotated_commit : IEquatable<git_annotated_commit>
        {
            public git_annotated_commit(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_annotated_commit other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_annotated_commit other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_annotated_commit left, git_annotated_commit right) => left.Equals(right);
            
            public static bool operator !=(git_annotated_commit left, git_annotated_commit right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a status collection
        /// </summary>
        public readonly partial struct git_status_list : IEquatable<git_status_list>
        {
            public git_status_list(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_status_list other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_status_list other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_status_list left, git_status_list right) => left.Equals(right);
            
            public static bool operator !=(git_status_list left, git_status_list right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a rebase
        /// </summary>
        public readonly partial struct git_rebase : IEquatable<git_rebase>
        {
            public git_rebase(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_rebase other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_rebase other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_rebase left, git_rebase right) => left.Equals(right);
            
            public static bool operator !=(git_rebase left, git_rebase right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A refspec specifies the mapping between remote and local reference
        /// names when fetch or pushing.
        /// </summary>
        public readonly partial struct git_refspec : IEquatable<git_refspec>
        {
            public git_refspec(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_refspec other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_refspec other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_refspec left, git_refspec right) => left.Equals(right);
            
            public static bool operator !=(git_refspec left, git_refspec right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Git's idea of a remote repository. A remote can be anonymous (in
        /// which case it does not have backing configuration entries).
        /// </summary>
        public readonly partial struct git_remote : IEquatable<git_remote>
        {
            public git_remote(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_remote other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_remote other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_remote left, git_remote right) => left.Equals(right);
            
            public static bool operator !=(git_remote left, git_remote right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Interface which represents a transport to communicate with a
        /// remote.
        /// </summary>
        public readonly partial struct git_transport : IEquatable<git_transport>
        {
            public git_transport(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_transport other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_transport other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_transport left, git_transport right) => left.Equals(right);
            
            public static bool operator !=(git_transport left, git_transport right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Preparation for a push operation. Can be used to configure what to
        /// push and the level of parallelism of the packfile builder.
        /// </summary>
        public readonly partial struct git_push : IEquatable<git_push>
        {
            public git_push(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_push other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_push other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_push left, git_push right) => left.Equals(right);
            
            public static bool operator !=(git_push left, git_push right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Description of a reference advertised by a remote server, given out
        /// on `ls` calls.
        /// </summary>
        public partial struct git_remote_head
        {
            /// <summary>
            /// available locally
            /// </summary>
            public int local;
            
            public libgit2.git_oid oid;
            
            public libgit2.git_oid loid;
            
            public byte* name;
            
            /// <summary>
            /// If the server send a symref mapping for this ref, this will
            /// point to the target.
            /// </summary>
            public byte* symref_target;
        }
        
        /// <summary>
        /// The callback settings structure
        /// </summary>
        /// <remarks>
        /// Set the callbacks to be called by the remote when informing the user
        /// about the progress of the network operations.
        /// </remarks>
        public partial struct git_remote_callbacks
        {
            /// <summary>
            /// The version
            /// </summary>
            public uint version;
            
            /// <summary>
            /// Textual progress from the remote. Text send over the
            /// progress side-band will be passed to this function (this is
            /// the 'counting objects' output).
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> sideband_progress;
            
            /// <summary>
            /// Completion is called when different parts of the download
            /// process are done (currently unused).
            /// </summary>
            public delegate*unmanaged[Cdecl]<libgit2.git_remote_completion_t, void*, int> completion;
            
            /// <summary>
            /// This will be called if the remote host requires
            /// authentication in order to connect to it.
            /// </summary>
            /// <remarks>
            /// Returning GIT_PASSTHROUGH will make libgit2 behave as
            /// though this field isn't set.
            /// </remarks>
            public delegate*unmanaged[Cdecl]<int> credentials;
            
            /// <summary>
            /// If cert verification fails, this will be called to let the
            /// user make the final decision of whether to allow the
            /// connection to proceed. Returns 0 to allow the connection
            /// or a negative value to indicate an error.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> certificate_check;
            
            /// <summary>
            /// During the download of new data, this will be regularly
            /// called with the current count of progress done by the
            /// indexer.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> transfer_progress;
            
            /// <summary>
            /// Each time a reference is updated locally, this function
            /// will be called with information about it.
            /// </summary>
            public delegate*unmanaged[Cdecl]<byte*, libgit2.git_oid*, libgit2.git_oid*, void*, int> update_tips;
            
            /// <summary>
            /// Function to call with progress information during pack
            /// building. Be aware that this is called inline with pack
            /// building operations, so performance may be affected.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> pack_progress;
            
            /// <summary>
            /// Function to call with progress information during the
            /// upload portion of a push. Be aware that this is called
            /// inline with pack building operations, so performance may be
            /// affected.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> push_transfer_progress;
            
            /// <summary>
            /// See documentation of git_push_update_reference_cb
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> push_update_reference;
            
            /// <summary>
            /// Called once between the negotiation step and the upload. It
            /// provides information about what updates will be performed.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> push_negotiation;
            
            /// <summary>
            /// Create the transport to use for this operation. Leave NULL
            /// to auto-detect.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> transport;
            
            /// <summary>
            /// Callback when the remote is ready to connect.
            /// </summary>
            public delegate*unmanaged[Cdecl]<int> remote_ready;
            
            /// <summary>
            /// This will be passed to each of the callbacks in this struct
            /// as the last parameter.
            /// </summary>
            public void* payload;
            
            public void* reserved;
        }
        
        /// <summary>
        /// Parent type for `git_cert_hostkey` and `git_cert_x509`.
        /// </summary>
        public partial struct git_cert
        {
            /// <summary>
            /// Type of certificate. A `GIT_CERT_` value.
            /// </summary>
            public libgit2.git_cert_t cert_type;
        }
        
        /// <summary>
        /// Opaque structure representing a submodule.
        /// </summary>
        public readonly partial struct git_submodule : IEquatable<git_submodule>
        {
            public git_submodule(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_submodule other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_submodule other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_submodule left, git_submodule right) => left.Equals(right);
            
            public static bool operator !=(git_submodule left, git_submodule right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A type to write in a streaming fashion, for example, for filters.
        /// </summary>
        public partial struct git_writestream
        {
            public delegate*unmanaged[Cdecl]<libgit2.git_writestream*, byte*, libgit2.size_t, int> write;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_writestream*, int> close;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_writestream*, void> free;
        }
        
        /// <summary>
        /// Representation of .mailmap file state.
        /// </summary>
        public readonly partial struct git_mailmap : IEquatable<git_mailmap>
        {
            public git_mailmap(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_mailmap other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_mailmap other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_mailmap left, git_mailmap right) => left.Equals(right);
            
            public static bool operator !=(git_mailmap left, git_mailmap right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Note: Can't use off_t since if a client program includes 
        /// &lt;sys
        /// /types.h&gt;
        /// before us (directly or indirectly), they'll get 32 bit off_t in their client
        /// app, even though /we/ define _FILE_OFFSET_BITS=64.
        /// </summary>
        public readonly partial struct git_off_t : IEquatable<git_off_t>
        {
            public git_off_t(int value) => this.Value = value;
            
            public int Value { get; }
            
            public bool Equals(git_off_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is git_off_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator int(git_off_t from) => from.Value;
            
            public static implicit operator git_off_t(int from) => new git_off_t(from);
            
            public static bool operator ==(git_off_t left, git_off_t right) => left.Equals(right);
            
            public static bool operator !=(git_off_t left, git_off_t right) => !left.Equals(right);
        }
    }
}
