//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Priority level of a config file.
        /// These priority levels correspond to the natural escalation logic
        /// (from higher to lower) when searching for config entries in git.git.
        /// </summary>
        /// <remarks>
        /// git_config_open_default() and git_repository_config() honor those
        /// priority levels as well.
        /// </remarks>
        public enum git_config_level_t : int
        {
            /// <summary>
            /// System-wide on Windows, for compatibility with portable git
            /// </summary>
            GIT_CONFIG_LEVEL_PROGRAMDATA = unchecked((int)1),
            
            /// <summary>
            /// System-wide configuration file; /etc/gitconfig on Linux systems
            /// </summary>
            GIT_CONFIG_LEVEL_SYSTEM = unchecked((int)2),
            
            /// <summary>
            /// XDG compatible configuration file; typically ~/.config/git/config
            /// </summary>
            GIT_CONFIG_LEVEL_XDG = unchecked((int)3),
            
            /// <summary>
            /// User-specific configuration file (also called Global configuration
            /// file); typically ~/.gitconfig
            /// </summary>
            GIT_CONFIG_LEVEL_GLOBAL = unchecked((int)4),
            
            /// <summary>
            /// Repository specific configuration file; $WORK_DIR/.git/config on
            /// non-bare repos
            /// </summary>
            GIT_CONFIG_LEVEL_LOCAL = unchecked((int)5),
            
            /// <summary>
            /// Application specific configuration file; freely defined by applications
            /// </summary>
            GIT_CONFIG_LEVEL_APP = unchecked((int)6),
            
            /// <summary>
            /// Represents the highest level available config file (i.e. the most
            /// specific config file available that actually is loaded)
            /// </summary>
            GIT_CONFIG_HIGHEST_LEVEL = unchecked((int)-1),
        }
        
        /// <summary>
        /// System-wide on Windows, for compatibility with portable git
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_PROGRAMDATA = git_config_level_t.GIT_CONFIG_LEVEL_PROGRAMDATA;
        
        /// <summary>
        /// System-wide configuration file; /etc/gitconfig on Linux systems
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_SYSTEM = git_config_level_t.GIT_CONFIG_LEVEL_SYSTEM;
        
        /// <summary>
        /// XDG compatible configuration file; typically ~/.config/git/config
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_XDG = git_config_level_t.GIT_CONFIG_LEVEL_XDG;
        
        /// <summary>
        /// User-specific configuration file (also called Global configuration
        /// file); typically ~/.gitconfig
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_GLOBAL = git_config_level_t.GIT_CONFIG_LEVEL_GLOBAL;
        
        /// <summary>
        /// Repository specific configuration file; $WORK_DIR/.git/config on
        /// non-bare repos
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_LOCAL = git_config_level_t.GIT_CONFIG_LEVEL_LOCAL;
        
        /// <summary>
        /// Application specific configuration file; freely defined by applications
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_LEVEL_APP = git_config_level_t.GIT_CONFIG_LEVEL_APP;
        
        /// <summary>
        /// Represents the highest level available config file (i.e. the most
        /// specific config file available that actually is loaded)
        /// </summary>
        public const libgit2.git_config_level_t GIT_CONFIG_HIGHEST_LEVEL = git_config_level_t.GIT_CONFIG_HIGHEST_LEVEL;
        
        /// <summary>
        /// Config var type
        /// </summary>
        public enum git_configmap_t : uint
        {
            GIT_CONFIGMAP_FALSE = unchecked((uint)0),
            
            GIT_CONFIGMAP_TRUE = unchecked((uint)1),
            
            GIT_CONFIGMAP_INT32,
            
            GIT_CONFIGMAP_STRING,
        }
        
        public const libgit2.git_configmap_t GIT_CONFIGMAP_FALSE = git_configmap_t.GIT_CONFIGMAP_FALSE;
        
        public const libgit2.git_configmap_t GIT_CONFIGMAP_TRUE = git_configmap_t.GIT_CONFIGMAP_TRUE;
        
        public const libgit2.git_configmap_t GIT_CONFIGMAP_INT32 = git_configmap_t.GIT_CONFIGMAP_INT32;
        
        public const libgit2.git_configmap_t GIT_CONFIGMAP_STRING = git_configmap_t.GIT_CONFIGMAP_STRING;
        
        /// <summary>
        /// An entry in a configuration file
        /// </summary>
        public partial struct git_config_entry
        {
            /// <summary>
            /// Name of the entry (normalised)
            /// </summary>
            public byte* name;
            
            /// <summary>
            /// String value of the entry
            /// </summary>
            public byte* value;
            
            /// <summary>
            /// Depth of includes where this variable was found
            /// </summary>
            public uint include_depth;
            
            /// <summary>
            /// Which config file this was found in
            /// </summary>
            public libgit2.git_config_level_t level;
            
            /// <summary>
            /// Free function for this entry
            /// </summary>
            public delegate*unmanaged[Cdecl]<libgit2.git_config_entry*, void> free;
            
            /// <summary>
            /// Opaque value for the free function. Do not read or write
            /// </summary>
            public void* payload;
        }
        
        /// <summary>
        /// An opaque structure for a configuration iterator
        /// </summary>
        public readonly partial struct git_config_iterator : IEquatable<git_config_iterator>
        {
            public git_config_iterator(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_config_iterator other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_config_iterator other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_config_iterator left, git_config_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_config_iterator left, git_config_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Mapping from config variables to values.
        /// </summary>
        public partial struct git_configmap
        {
            public libgit2.git_configmap_t type;
            
            public byte* str_match;
            
            public int map_value;
        }
        
        /// <summary>
        /// A config enumeration callback
        /// </summary>
        /// <param name="entry">the entry currently being enumerated</param>
        /// <param name="payload">a user-specified pointer</param>
        /// <returns>@return non-zero to terminate the iteration.</returns>
        public readonly partial struct git_config_foreach_cb : IEquatable<git_config_foreach_cb>
        {
            public git_config_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_config_entry*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_config_entry*, void*, int> Value { get; }
            
            public bool Equals(git_config_foreach_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_config_foreach_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_config_entry*, void*, int>(git_config_foreach_cb from) => from.Value;
            
            public static implicit operator git_config_foreach_cb(delegate*unmanaged[Cdecl]<libgit2.git_config_entry*, void*, int> from) => new git_config_foreach_cb(from);
            
            public static bool operator ==(git_config_foreach_cb left, git_config_foreach_cb right) => left.Equals(right);
            
            public static bool operator !=(git_config_foreach_cb left, git_config_foreach_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Free a config entry
        /// </summary>
        /// <param name="entry">The entry to free.</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_entry_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_config_entry_free(libgit2.git_config_entry* entry);
        
        /// <summary>
        /// Locate the path to the global configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>@return 0 if a global configuration file has been found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// The user or global configuration file is usually
        /// located in `$HOME/.gitconfig`.This method will try to guess the full path to that
        /// file, if the file exists. The returned path
        /// may be used on any `git_config` call to load the
        /// global configuration file.This method will not guess the path to the xdg compatible
        /// config file (`.config/git/config`).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_find_global")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_find_global(out libgit2.git_buf @out);
        
        /// <summary>
        /// Locate the path to the global xdg compatible configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>@return 0 if a xdg compatible configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// The xdg compatible configuration file is usually
        /// located in `$HOME/.config/git/config`.This method will try to guess the full path to that
        /// file, if the file exists. The returned path
        /// may be used on any `git_config` call to load the
        /// xdg compatible configuration file.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_find_xdg")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_find_xdg(out libgit2.git_buf @out);
        
        /// <summary>
        /// Locate the path to the system configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>@return 0 if a system configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// If `/etc/gitconfig` doesn't exist, it will look for
        /// `%PROGRAMFILES%@Git @etc @gitconfig `.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_find_system")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_find_system(out libgit2.git_buf @out);
        
        /// <summary>
        /// Locate the path to the configuration file in ProgramData
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>@return 0 if a ProgramData configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// Look for the file in `%PROGRAMDATA%@Git @config ` used by portable git.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_find_programdata")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_find_programdata(out libgit2.git_buf @out);
        
        /// <summary>
        /// Open the global, XDG and system configuration files
        /// </summary>
        /// <param name="out">Pointer to store the config instance</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Utility wrapper that finds the global, XDG and system configuration files
        /// and opens them into a single prioritized config object that can be
        /// used when accessing default config data outside a repository.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_open_default")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_open_default(out libgit2.git_config @out);
        
        /// <summary>
        /// Allocate a new configuration object
        /// </summary>
        /// <param name="out">pointer to the new configuration</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This object is empty, so you have to add a file to it before you
        /// can do anything with it.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_new(out libgit2.git_config @out);
        
        /// <summary>
        /// Add an on-disk config file instance to an existing config
        /// </summary>
        /// <param name="cfg">the configuration to add the file to</param>
        /// <param name="path">path to the configuration file to add</param>
        /// <param name="level">the priority level of the backend</param>
        /// <param name="force">replace config file at the given priority level</param>
        /// <param name="repo">optional repository to allow parsing of
        /// conditional includes</param>
        /// <returns>@return 0 on success, GIT_EEXISTS when adding more than one file
        /// for a given priority level (and force_replace set to 0),
        /// GIT_ENOTFOUND when the file doesn't exist or error code</returns>
        /// <remarks>
        /// The on-disk file pointed at by `path` will be opened and
        /// parsed; it's expected to be a native Git config file following
        /// the default Git config syntax (see man git-config).If the file does not exist, the file will still be added and it
        /// will be created the first time we write to it.Note that the configuration object will free the file
        /// automatically.Further queries on this config object will access each
        /// of the config file instances in order (instances with
        /// a higher priority level will be accessed first).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_add_file_ondisk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_add_file_ondisk(libgit2.git_config cfg, byte* path, libgit2.git_config_level_t level, libgit2.git_repository repo, int force);
        
        /// <summary>
        /// Add an on-disk config file instance to an existing config
        /// </summary>
        /// <param name="cfg">the configuration to add the file to</param>
        /// <param name="path">path to the configuration file to add</param>
        /// <param name="level">the priority level of the backend</param>
        /// <param name="force">replace config file at the given priority level</param>
        /// <param name="repo">optional repository to allow parsing of
        /// conditional includes</param>
        /// <returns>@return 0 on success, GIT_EEXISTS when adding more than one file
        /// for a given priority level (and force_replace set to 0),
        /// GIT_ENOTFOUND when the file doesn't exist or error code</returns>
        /// <remarks>
        /// The on-disk file pointed at by `path` will be opened and
        /// parsed; it's expected to be a native Git config file following
        /// the default Git config syntax (see man git-config).If the file does not exist, the file will still be added and it
        /// will be created the first time we write to it.Note that the configuration object will free the file
        /// automatically.Further queries on this config object will access each
        /// of the config file instances in order (instances with
        /// a higher priority level will be accessed first).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_add_file_ondisk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_add_file_ondisk(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, libgit2.git_config_level_t level, libgit2.git_repository repo, int force);
        
        /// <summary>
        /// Create a new config instance containing a single on-disk file
        /// </summary>
        /// <param name="out">The configuration instance to create</param>
        /// <param name="path">Path to the on-disk file to open</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// This method is a simple utility wrapper for the following sequence
        /// of calls:
        /// - git_config_new
        /// - git_config_add_file_ondisk
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_open_ondisk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_open_ondisk(out libgit2.git_config @out, byte* path);
        
        /// <summary>
        /// Create a new config instance containing a single on-disk file
        /// </summary>
        /// <param name="out">The configuration instance to create</param>
        /// <param name="path">Path to the on-disk file to open</param>
        /// <returns>@return 0 on success, or an error code</returns>
        /// <remarks>
        /// This method is a simple utility wrapper for the following sequence
        /// of calls:
        /// - git_config_new
        /// - git_config_add_file_ondisk
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_open_ondisk")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_open_ondisk(out libgit2.git_config @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);
        
        /// <summary>
        /// Build a single-level focused config object from a multi-level one.
        /// </summary>
        /// <param name="out">The configuration instance to create</param>
        /// <param name="parent">Multi-level config to search for the given level</param>
        /// <param name="level">Configuration level to search for</param>
        /// <returns>@return 0, GIT_ENOTFOUND if the passed level cannot be found in the
        /// multi-level parent config, or an error code</returns>
        /// <remarks>
        /// The returned config object can be used to perform get/set/delete operations
        /// on a single specific level.Getting several times the same level from the same parent multi-level config
        /// will return different config instances, but containing the same config_file
        /// instance.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_open_level")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_open_level(out libgit2.git_config @out, libgit2.git_config parent, libgit2.git_config_level_t level);
        
        /// <summary>
        /// Open the global/XDG configuration file according to git's rules
        /// </summary>
        /// <param name="out">pointer in which to store the config object</param>
        /// <param name="config">the config object in which to look</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Git allows you to store your global configuration at
        /// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
        /// compatibility, the XDG file shouldn't be used unless the use has
        /// created it explicitly. With this function you'll open the correct
        /// one to write to.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_open_global")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_open_global(out libgit2.git_config @out, libgit2.git_config config);
        
        /// <summary>
        /// Create a snapshot of the configuration
        /// </summary>
        /// <param name="out">pointer in which to store the snapshot config object</param>
        /// <param name="config">configuration to snapshot</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Create a snapshot of the current state of a configuration, which
        /// allows you to look into a consistent view of the configuration for
        /// looking up complex values (e.g. a remote, submodule).The string returned when querying such a config object is valid
        /// until it is freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_snapshot")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_snapshot(out libgit2.git_config @out, libgit2.git_config config);
        
        /// <summary>
        /// Free the configuration and its associated memory and files
        /// </summary>
        /// <param name="cfg">the configuration to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_config_free(libgit2.git_config cfg);
        
        /// <summary>
        /// Get the git_config_entry of a config variable.
        /// </summary>
        /// <param name="out">pointer to the variable git_config_entry</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Free the git_config_entry after use with `git_config_entry_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_entry(out libgit2.git_config_entry* @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the git_config_entry of a config variable.
        /// </summary>
        /// <param name="out">pointer to the variable git_config_entry</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Free the git_config_entry after use with `git_config_entry_free()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_entry(out libgit2.git_config_entry* @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of an integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_int32(out int @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of an integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_int32(out int @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of a long integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_int64(out int @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of a long integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_int64(out int @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of a boolean config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function uses the usual C convention of 0 being false and
        /// anything else true.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_bool(out int @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of a boolean config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function uses the usual C convention of 0 being false and
        /// anything else true.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_bool(out int @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of a path config variable.
        /// </summary>
        /// <param name="out">the buffer in which to store the result</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_path(out libgit2.git_buf @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of a path config variable.
        /// </summary>
        /// <param name="out">the buffer in which to store the result</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_path(out libgit2.git_buf @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">pointer to the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function can only be used on snapshot config objects. The
        /// string is owned by the config and should not be freed by the
        /// user. The pointer will be valid until the config is freed.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_string(out byte* @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">pointer to the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// This function can only be used on snapshot config objects. The
        /// string is owned by the config and should not be freed by the
        /// user. The pointer will be valid until the config is freed.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_string(out byte* @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">buffer in which to store the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The value of the config will be copied into the buffer.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_string_buf")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_string_buf(out libgit2.git_buf @out, libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">buffer in which to store the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The value of the config will be copied into the buffer.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_string_buf")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_string_buf(out libgit2.git_buf @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Get each value of a multivar in a foreach callback
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <param name="callback">the function to be called on each value of the variable</param>
        /// <param name="payload">opaque pointer to pass to the callback</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The callback will be called on each variable foundThe regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_multivar_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_multivar_foreach(libgit2.git_config cfg, byte* name, byte* regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Get each value of a multivar in a foreach callback
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <param name="callback">the function to be called on each value of the variable</param>
        /// <param name="payload">opaque pointer to pass to the callback</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The callback will be called on each variable foundThe regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_multivar_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_multivar_foreach(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Get each value of a multivar
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_multivar_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_multivar_iterator_new(out libgit2.git_config_iterator @out, libgit2.git_config cfg, byte* name, byte* regexp);
        
        /// <summary>
        /// Get each value of a multivar
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_multivar_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_multivar_iterator_new(out libgit2.git_config_iterator @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp);
        
        /// <summary>
        /// Return the current entry and advance the iterator
        /// </summary>
        /// <param name="entry">pointer to store the entry</param>
        /// <param name="iter">the iterator</param>
        /// <returns>@return 0 or an error code. GIT_ITEROVER if the iteration has completed</returns>
        /// <remarks>
        /// The pointers returned by this function are valid until the next call
        /// to `git_config_next` or until the iterator is freed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_next")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_next(out libgit2.git_config_entry* entry, libgit2.git_config_iterator iter);
        
        /// <summary>
        /// Free a config iterator
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_iterator_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_config_iterator_free(libgit2.git_config_iterator iter);
        
        /// <summary>
        /// Set the value of an integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Integer value for the variable</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_int32(libgit2.git_config cfg, byte* name, int value);
        
        /// <summary>
        /// Set the value of an integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Integer value for the variable</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_int32(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, int value);
        
        /// <summary>
        /// Set the value of a long integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Long integer value for the variable</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_int64(libgit2.git_config cfg, byte* name, int value);
        
        /// <summary>
        /// Set the value of a long integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Long integer value for the variable</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_int64(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, int value);
        
        /// <summary>
        /// Set the value of a boolean config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the value to store</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_bool(libgit2.git_config cfg, byte* name, int value);
        
        /// <summary>
        /// Set the value of a boolean config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the value to store</param>
        /// <returns>@return 0 or an error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_bool(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, int value);
        
        /// <summary>
        /// Set the value of a string config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the string to store.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// A copy of the string is made and the user is free to use it
        /// afterwards.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_string(libgit2.git_config cfg, byte* name, byte* value);
        
        /// <summary>
        /// Set the value of a string config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the string to store.</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// A copy of the string is made and the user is free to use it
        /// afterwards.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_string")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_string(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Set a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to replace</param>
        /// <param name="value">the new value.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_multivar")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_multivar(libgit2.git_config cfg, byte* name, byte* regexp, byte* value);
        
        /// <summary>
        /// Set a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to replace</param>
        /// <param name="value">the new value.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_set_multivar")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_set_multivar(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Delete a config variable from the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">the configuration</param>
        /// <param name="name">the variable to delete</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_delete_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_delete_entry(libgit2.git_config cfg, byte* name);
        
        /// <summary>
        /// Delete a config variable from the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">the configuration</param>
        /// <param name="name">the variable to delete</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_delete_entry")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_delete_entry(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);
        
        /// <summary>
        /// Deletes one or several entries from a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variables</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to delete</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_delete_multivar")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_delete_multivar(libgit2.git_config cfg, byte* name, byte* regexp);
        
        /// <summary>
        /// Deletes one or several entries from a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variables</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to delete</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_delete_multivar")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_delete_multivar(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp);
        
        /// <summary>
        /// Perform an operation on each config variable.
        /// </summary>
        /// <param name="cfg">where to get the variables from</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The callback receives the normalized name and value of each variable
        /// in the config backend, and the data pointer passed to this function.
        /// If the callback returns a non-zero value, the function stops iterating
        /// and returns that value to the caller.The pointers passed to the callback are only valid as long as the
        /// iteration is ongoing.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_foreach(libgit2.git_config cfg, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Iterate over all the config variables
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to get the variables from</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Use `git_config_next` to advance the iteration and
        /// `git_config_iterator_free` when done.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_iterator_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_iterator_new(out libgit2.git_config_iterator @out, libgit2.git_config cfg);
        
        /// <summary>
        /// Iterate over all the config variables whose name matches a pattern
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to ge the variables from</param>
        /// <param name="regexp">regular expression to match the names</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Use `git_config_next` to advance the iteration and
        /// `git_config_iterator_free` when done.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_iterator_glob_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_iterator_glob_new(out libgit2.git_config_iterator @out, libgit2.git_config cfg, byte* regexp);
        
        /// <summary>
        /// Iterate over all the config variables whose name matches a pattern
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to ge the variables from</param>
        /// <param name="regexp">regular expression to match the names</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Use `git_config_next` to advance the iteration and
        /// `git_config_iterator_free` when done.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_iterator_glob_new")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_iterator_glob_new(out libgit2.git_config_iterator @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp);
        
        /// <summary>
        /// Perform an operation on each config variable matching a regular expression.
        /// </summary>
        /// <param name="cfg">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>@return 0 or the return value of the callback which didn't return 0</returns>
        /// <remarks>
        /// This behaves like `git_config_foreach` with an additional filter of a
        /// regular expression that filters which config keys are passed to the
        /// callback.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the case-insensitive parts are lower-case.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_foreach_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_config_foreach_match(libgit2.git_config cfg, byte* regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Perform an operation on each config variable matching a regular expression.
        /// </summary>
        /// <param name="cfg">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>@return 0 or the return value of the callback which didn't return 0</returns>
        /// <remarks>
        /// This behaves like `git_config_foreach` with an additional filter of a
        /// regular expression that filters which config keys are passed to the
        /// callback.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the case-insensitive parts are lower-case.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_foreach_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_config_foreach_match(libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Query the value of a config variable and return it mapped to
        /// an integer constant.
        /// </summary>
        /// <param name="out">place to store the result of the mapping</param>
        /// <param name="cfg">config file to get the variables from</param>
        /// <param name="name">name of the config variable to lookup</param>
        /// <param name="maps">array of `git_configmap` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <returns>@return 0 on success, error code otherwise</returns>
        /// <remarks>
        /// This is a helper method to easily map different possible values
        /// to a variable to integer constants that easily identify them.A mapping array looks as follows:git_configmap autocrlf_mapping[] = {
        /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
        /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
        /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
        /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
        /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.The same thing applies for any "true" value such as "true", "yes" or "1", storing
        /// the `GIT_AUTO_CRLF_TRUE` variable.Otherwise, if the value matches the string "input" (with case insensitive comparison),
        /// the given constant will be stored in `out`, and likewise for "default".If not a single match can be made to store in `out`, an error code will be
        /// returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_mapped")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_mapped(out int @out, libgit2.git_config cfg, byte* name, libgit2.git_configmap* maps, libgit2.size_t map_n);
        
        /// <summary>
        /// Query the value of a config variable and return it mapped to
        /// an integer constant.
        /// </summary>
        /// <param name="out">place to store the result of the mapping</param>
        /// <param name="cfg">config file to get the variables from</param>
        /// <param name="name">name of the config variable to lookup</param>
        /// <param name="maps">array of `git_configmap` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <returns>@return 0 on success, error code otherwise</returns>
        /// <remarks>
        /// This is a helper method to easily map different possible values
        /// to a variable to integer constants that easily identify them.A mapping array looks as follows:git_configmap autocrlf_mapping[] = {
        /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
        /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
        /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
        /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
        /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.The same thing applies for any "true" value such as "true", "yes" or "1", storing
        /// the `GIT_AUTO_CRLF_TRUE` variable.Otherwise, if the value matches the string "input" (with case insensitive comparison),
        /// the given constant will be stored in `out`, and likewise for "default".If not a single match can be made to store in `out`, an error code will be
        /// returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_get_mapped")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_get_mapped(out int @out, libgit2.git_config cfg, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, libgit2.git_configmap* maps, libgit2.size_t map_n);
        
        /// <summary>
        /// Maps a string value to an integer constant
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="maps">array of `git_configmap` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_lookup_map_value")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_lookup_map_value(out int @out, libgit2.git_configmap* maps, libgit2.size_t map_n, byte* value);
        
        /// <summary>
        /// Maps a string value to an integer constant
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="maps">array of `git_configmap` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_lookup_map_value")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_lookup_map_value(out int @out, libgit2.git_configmap* maps, libgit2.size_t map_n, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Parse a string value as a bool.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Valid values for true are: 'true', 'yes', 'on', 1 or any
        /// number different from 0
        /// Valid values for false are: 'false', 'no', 'off', 0
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_bool(out int @out, byte* value);
        
        /// <summary>
        /// Parse a string value as a bool.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// Valid values for true are: 'true', 'yes', 'on', 1 or any
        /// number different from 0
        /// Valid values for false are: 'false', 'no', 'off', 0
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_bool")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_bool(out int @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Parse a string value as an int32.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_int32(out int @out, byte* value);
        
        /// <summary>
        /// Parse a string value as an int32.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_int32")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_int32(out int @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Parse a string value as an int64.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_int64(out int @out, byte* value);
        
        /// <summary>
        /// Parse a string value as an int64.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_int64")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_int64(out int @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Parse a string value as a path.
        /// </summary>
        /// <param name="out">placae to store the result of parsing</param>
        /// <param name="value">the path to evaluate</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.If the value does not begin with a tilde, the input will be
        /// returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_path(out libgit2.git_buf @out, byte* value);
        
        /// <summary>
        /// Parse a string value as a path.
        /// </summary>
        /// <param name="out">placae to store the result of parsing</param>
        /// <param name="value">the path to evaluate</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.If the value does not begin with a tilde, the input will be
        /// returned.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_parse_path")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_parse_path(out libgit2.git_buf @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);
        
        /// <summary>
        /// Perform an operation on each config variable in a given config backend,
        /// matching a regular expression.
        /// </summary>
        /// <param name="backend">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names (can be NULL)</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This behaves like `git_config_foreach_match` except that only config
        /// entries from the given backend entry are enumerated.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_backend_foreach_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_backend_foreach_match(libgit2.git_config_backend backend, byte* regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Perform an operation on each config variable in a given config backend,
        /// matching a regular expression.
        /// </summary>
        /// <param name="backend">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names (can be NULL)</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This behaves like `git_config_foreach_match` except that only config
        /// entries from the given backend entry are enumerated.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_backend_foreach_match")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_backend_foreach_match(libgit2.git_config_backend backend, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> regexp, libgit2.git_config_foreach_cb callback, void* payload);
        
        /// <summary>
        /// Lock the backend with the highest priority
        /// </summary>
        /// <param name="tx">the resulting transaction, use this to commit or undo the
        /// changes</param>
        /// <param name="cfg">the configuration in which to lock</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// Locking disallows anybody else from writing to that backend. Any
        /// updates made after locking will not be visible to a reader until
        /// the file is unlocked.You can apply the changes by calling `git_transaction_commit()`
        /// before freeing the transaction. Either of these actions will unlock
        /// the config.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_config_lock")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_config_lock(out libgit2.git_transaction tx, libgit2.git_config cfg);
    }
}
