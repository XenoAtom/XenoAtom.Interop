//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Options for bypassing the git-aware transport on clone. Bypassing
        /// it means that instead of a fetch, libgit2 will copy the object
        /// database directory instead of figuring out what it needs, which is
        /// faster. If possible, it will hardlink the files to save space.
        /// </summary>
        public enum git_clone_local_t : int
        {
            /// <summary>
            /// Auto-detect (default), libgit2 will bypass the git-aware
            /// transport for local paths, but use a normal fetch for
            /// `file://` urls.
            /// </summary>
            GIT_CLONE_LOCAL_AUTO,
            
            /// <summary>
            /// Bypass the git-aware transport even for a `file://` url.
            /// </summary>
            GIT_CLONE_LOCAL,
            
            /// <summary>
            /// Do no bypass the git-aware transport
            /// </summary>
            GIT_CLONE_NO_LOCAL,
            
            /// <summary>
            /// Bypass the git-aware transport, but do not try to use
            /// hardlinks.
            /// </summary>
            GIT_CLONE_LOCAL_NO_LINKS,
        }
        
        /// <summary>
        /// Auto-detect (default), libgit2 will bypass the git-aware
        /// transport for local paths, but use a normal fetch for
        /// `file://` urls.
        /// </summary>
        public const libgit2.git_clone_local_t GIT_CLONE_LOCAL_AUTO = git_clone_local_t.GIT_CLONE_LOCAL_AUTO;
        
        /// <summary>
        /// Bypass the git-aware transport even for a `file://` url.
        /// </summary>
        public const libgit2.git_clone_local_t GIT_CLONE_LOCAL = git_clone_local_t.GIT_CLONE_LOCAL;
        
        /// <summary>
        /// Do no bypass the git-aware transport
        /// </summary>
        public const libgit2.git_clone_local_t GIT_CLONE_NO_LOCAL = git_clone_local_t.GIT_CLONE_NO_LOCAL;
        
        /// <summary>
        /// Bypass the git-aware transport, but do not try to use
        /// hardlinks.
        /// </summary>
        public const libgit2.git_clone_local_t GIT_CLONE_LOCAL_NO_LINKS = git_clone_local_t.GIT_CLONE_LOCAL_NO_LINKS;
        
        /// <summary>
        /// Clone options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_clone_options_init`.
        /// </remarks>
        public partial struct git_clone_options
        {
            public uint version;
            
            /// <summary>
            /// These options are passed to the checkout step. To disable
            /// checkout, set the `checkout_strategy` to
            /// `GIT_CHECKOUT_NONE`.
            /// </summary>
            public libgit2.git_checkout_options checkout_opts;
            
            /// <summary>
            /// Options which control the fetch, including callbacks.
            /// </summary>
            /// <remarks>
            /// The callbacks are used for reporting fetch progress, and for acquiring
            /// credentials in the event they are needed.
            /// </remarks>
            public libgit2.git_fetch_options fetch_opts;
            
            /// <summary>
            /// Set to zero (false) to create a standard repo, or non-zero
            /// for a bare repo
            /// </summary>
            public int bare;
            
            /// <summary>
            /// Whether to use a fetch or copy the object database.
            /// </summary>
            public libgit2.git_clone_local_t local;
            
            /// <summary>
            /// The name of the branch to checkout. NULL means use the
            /// remote's default branch.
            /// </summary>
            public readonly byte* checkout_branch;
            
            /// <summary>
            /// A callback used to create the new repository into which to
            /// clone. If NULL, the 'bare' field will be used to determine
            /// whether to create a bare repository.
            /// </summary>
            public libgit2.git_repository_create_cb repository_cb;
            
            /// <summary>
            /// An opaque payload to pass to the git_repository creation callback.
            /// This parameter is ignored unless repository_cb is non-NULL.
            /// </summary>
            public void* repository_cb_payload;
            
            /// <summary>
            /// A callback used to create the git_remote, prior to its being
            /// used to perform the clone operation. See the documentation for
            /// git_remote_create_cb for details. This parameter may be NULL,
            /// indicating that git_clone should provide default behavior.
            /// </summary>
            public libgit2.git_remote_create_cb remote_cb;
            
            /// <summary>
            /// An opaque payload to pass to the git_remote creation callback.
            /// This parameter is ignored unless remote_cb is non-NULL.
            /// </summary>
            public void* remote_cb_payload;
        }
        
        /// <summary>
        /// The signature of a function matching git_repository_init, with an
        /// additional void * as callback payload.
        /// </summary>
        /// <param name="out">the resulting repository</param>
        /// <param name="path">path in which to create the repository</param>
        /// <param name="bare">whether the repository is bare. This is the value from the clone options</param>
        /// <param name="payload">payload specified by the options</param>
        /// <returns>@return 0, or a negative value to indicate error</returns>
        /// <remarks>
        /// Callers of git_clone my provide a function matching this signature
        /// to override the repository creation and customization process
        /// during a clone operation.
        /// </remarks>
        public readonly partial struct git_repository_create_cb : IEquatable<git_repository_create_cb>
        {
            public git_repository_create_cb(delegate*unmanaged[Cdecl]<libgit2.git_repository*, byte*, int, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.git_repository*, byte*, int, void*, int>* Value;
            
            public bool Equals(git_repository_create_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_repository_create_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_repository*, byte*, int, void*, int>*(git_repository_create_cb from) => from.Value;
            
            public static implicit operator git_repository_create_cb(delegate*unmanaged[Cdecl]<libgit2.git_repository*, byte*, int, void*, int>* from) => new git_repository_create_cb(from);
            
            public static bool operator ==(git_repository_create_cb left, git_repository_create_cb right) => left.Equals(right);
            
            public static bool operator !=(git_repository_create_cb left, git_repository_create_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// The signature of a function matching git_remote_create, with an additional
        /// void* as a callback payload.
        /// </summary>
        /// <param name="out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <param name="payload">an opaque payload</param>
        /// <returns>@return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// Callers of git_clone may provide a function matching this signature to override
        /// the remote creation and customization process during a clone operation.
        /// </remarks>
        public readonly partial struct git_remote_create_cb : IEquatable<git_remote_create_cb>
        {
            public git_remote_create_cb(delegate*unmanaged[Cdecl]<libgit2.git_remote*, libgit2.git_repository, byte*, byte*, void*, int>* value) => this.Value = value;
            
            public readonly delegate*unmanaged[Cdecl]<libgit2.git_remote*, libgit2.git_repository, byte*, byte*, void*, int>* Value;
            
            public bool Equals(git_remote_create_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_remote_create_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_remote*, libgit2.git_repository, byte*, byte*, void*, int>*(git_remote_create_cb from) => from.Value;
            
            public static implicit operator git_remote_create_cb(delegate*unmanaged[Cdecl]<libgit2.git_remote*, libgit2.git_repository, byte*, byte*, void*, int>* from) => new git_remote_create_cb(from);
            
            public static bool operator ==(git_remote_create_cb left, git_remote_create_cb right) => left.Equals(right);
            
            public static bool operator !=(git_remote_create_cb left, git_remote_create_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Initialize git_clone_options structure
        /// </summary>
        /// <param name="opts">The `git_clone_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_clone_options` with default values. Equivalent to creating
        /// an instance with GIT_CLONE_OPTIONS_INIT.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_clone_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_clone_options_init(out libgit2.git_clone_options opts, uint version);
        
        /// <summary>
        /// Clone a remote repository.
        /// </summary>
        /// <param name="out">pointer that will receive the resulting repository object</param>
        /// <param name="url">the remote repository to clone</param>
        /// <param name="local_path">local directory to clone to</param>
        /// <param name="options">configuration options for the clone.  If NULL, the
        /// function works as though GIT_OPTIONS_INIT were passed.</param>
        /// <returns>@return 0 on success, any non-zero return value from a callback
        /// function, or a negative value to indicate an error (use
        /// `git_error_last` for a detailed error message)</returns>
        /// <remarks>
        /// By default this creates its repository and initial remote to match
        /// git's defaults. You can use the options in the callback to
        /// customize how these are created.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_clone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_clone(out libgit2.git_repository @out, byte* url, byte* local_path, in libgit2.git_clone_options options);
        
        /// <summary>
        /// Clone a remote repository.
        /// </summary>
        /// <param name="out">pointer that will receive the resulting repository object</param>
        /// <param name="url">the remote repository to clone</param>
        /// <param name="local_path">local directory to clone to</param>
        /// <param name="options">configuration options for the clone.  If NULL, the
        /// function works as though GIT_OPTIONS_INIT were passed.</param>
        /// <returns>@return 0 on success, any non-zero return value from a callback
        /// function, or a negative value to indicate an error (use
        /// `git_error_last` for a detailed error message)</returns>
        /// <remarks>
        /// By default this creates its repository and initial remote to match
        /// git's defaults. You can use the options in the callback to
        /// customize how these are created.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_clone")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_clone(out libgit2.git_repository @out, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string url, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(UTF8MarshallerRelaxedNoCleanup))] string local_path, in libgit2.git_clone_options options);
    }
}
