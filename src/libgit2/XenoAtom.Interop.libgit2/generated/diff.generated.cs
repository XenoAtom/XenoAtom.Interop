//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XenoAtom.Interop
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class libgit2
    {
        /// <summary>
        /// Flags for diff options.  A combination of these flags can be passed
        /// in via the `flags` value in the `git_diff_options`.
        /// </summary>
        [Flags]
        public enum git_diff_option_t : uint
        {
            /// <summary>
            /// Normal diff, the default
            /// </summary>
            GIT_DIFF_NORMAL = unchecked((uint)0),
            
            /// <summary>
            /// Reverse the sides of the diff
            /// </summary>
            GIT_DIFF_REVERSE = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// Include ignored files in the diff
            /// </summary>
            GIT_DIFF_INCLUDE_IGNORED = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
            /// will be marked with only a single entry in the diff; this flag
            /// adds all files under the directory as IGNORED entries, too.
            /// </summary>
            GIT_DIFF_RECURSE_IGNORED_DIRS = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// Include untracked files in the diff
            /// </summary>
            GIT_DIFF_INCLUDE_UNTRACKED = unchecked((uint)(1u << 3)),
            
            /// <summary>
            /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
            /// directory will be marked with only a single entry in the diff
            /// (a la what core Git does in `git status`); this flag adds *all*
            /// files under untracked directories as UNTRACKED entries, too.
            /// </summary>
            GIT_DIFF_RECURSE_UNTRACKED_DIRS = unchecked((uint)(1u << 4)),
            
            /// <summary>
            /// Include unmodified files in the diff
            /// </summary>
            GIT_DIFF_INCLUDE_UNMODIFIED = unchecked((uint)(1u << 5)),
            
            /// <summary>
            /// Normally, a type change between files will be converted into a
            /// DELETED record for the old and an ADDED record for the new; this
            /// options enabled the generation of TYPECHANGE delta records.
            /// </summary>
            GIT_DIFF_INCLUDE_TYPECHANGE = unchecked((uint)(1u << 6)),
            
            /// <summary>
            /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob-&gt;tree changes still
            /// generally show as a DELETED blob.  This flag tries to correctly
            /// label blob-&gt;tree transitions as TYPECHANGE records with new_file's
            /// mode set to tree.  Note: the tree SHA will not be available.
            /// </summary>
            GIT_DIFF_INCLUDE_TYPECHANGE_TREES = unchecked((uint)(1u << 7)),
            
            /// <summary>
            /// Ignore file mode changes
            /// </summary>
            GIT_DIFF_IGNORE_FILEMODE = unchecked((uint)(1u << 8)),
            
            /// <summary>
            /// Treat all submodules as unmodified
            /// </summary>
            GIT_DIFF_IGNORE_SUBMODULES = unchecked((uint)(1u << 9)),
            
            /// <summary>
            /// Use case insensitive filename comparisons
            /// </summary>
            GIT_DIFF_IGNORE_CASE = unchecked((uint)(1u << 10)),
            
            /// <summary>
            /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
            /// that has changed case will be returned as an add/delete pair.
            /// </summary>
            GIT_DIFF_INCLUDE_CASECHANGE = unchecked((uint)(1u << 11)),
            
            /// <summary>
            /// If the pathspec is set in the diff options, this flags indicates
            /// that the paths will be treated as literal paths instead of
            /// fnmatch patterns.  Each path in the list must either be a full
            /// path to a file or a directory.  (A trailing slash indicates that
            /// the path will _only_ match a directory).  If a directory is
            /// specified, all children will be included.
            /// </summary>
            GIT_DIFF_DISABLE_PATHSPEC_MATCH = unchecked((uint)(1u << 12)),
            
            /// <summary>
            /// Disable updating of the `binary` flag in delta records.  This is
            /// useful when iterating over a diff if you don't need hunk and data
            /// callbacks and want to avoid having to load file completely.
            /// </summary>
            GIT_DIFF_SKIP_BINARY_CHECK = unchecked((uint)(1u << 13)),
            
            /// <summary>
            /// When diff finds an untracked directory, to match the behavior of
            /// core Git, it scans the contents for IGNORED and UNTRACKED files.
            /// If *all* contents are IGNORED, then the directory is IGNORED; if
            /// any contents are not IGNORED, then the directory is UNTRACKED.
            /// This is extra work that may not matter in many cases.  This flag
            /// turns off that scan and immediately labels an untracked directory
            /// as UNTRACKED (changing the behavior to not match core Git).
            /// </summary>
            GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = unchecked((uint)(1u << 14)),
            
            /// <summary>
            /// When diff finds a file in the working directory with stat
            /// information different from the index, but the OID ends up being the
            /// same, write the correct stat information into the index.  Note:
            /// without this flag, diff will always leave the index untouched.
            /// </summary>
            GIT_DIFF_UPDATE_INDEX = unchecked((uint)(1u << 15)),
            
            /// <summary>
            /// Include unreadable files in the diff
            /// </summary>
            GIT_DIFF_INCLUDE_UNREADABLE = unchecked((uint)(1u << 16)),
            
            /// <summary>
            /// Include unreadable files in the diff
            /// </summary>
            GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = unchecked((uint)(1u << 17)),
            
            /// <summary>
            /// Use a heuristic that takes indentation and whitespace into account
            /// which generally can produce better diffs when dealing with ambiguous
            /// diff hunks.
            /// </summary>
            GIT_DIFF_INDENT_HEURISTIC = unchecked((uint)(1u << 18)),
            
            /// <summary>
            /// Ignore blank lines
            /// </summary>
            GIT_DIFF_IGNORE_BLANK_LINES = unchecked((uint)(1u << 19)),
            
            /// <summary>
            /// Treat all files as text, disabling binary attributes 
            /// &amp;
            /// detection
            /// </summary>
            GIT_DIFF_FORCE_TEXT = unchecked((uint)(1u << 20)),
            
            /// <summary>
            /// Treat all files as binary, disabling text diffs
            /// </summary>
            GIT_DIFF_FORCE_BINARY = unchecked((uint)(1u << 21)),
            
            /// <summary>
            /// Ignore all whitespace
            /// </summary>
            GIT_DIFF_IGNORE_WHITESPACE = unchecked((uint)(1u << 22)),
            
            /// <summary>
            /// Ignore changes in amount of whitespace
            /// </summary>
            GIT_DIFF_IGNORE_WHITESPACE_CHANGE = unchecked((uint)(1u << 23)),
            
            /// <summary>
            /// Ignore whitespace at end of line
            /// </summary>
            GIT_DIFF_IGNORE_WHITESPACE_EOL = unchecked((uint)(1u << 24)),
            
            /// <summary>
            /// When generating patch text, include the content of untracked
            /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
            /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
            /// flag if you want the content of every single UNTRACKED file.
            /// </summary>
            GIT_DIFF_SHOW_UNTRACKED_CONTENT = unchecked((uint)(1u << 25)),
            
            /// <summary>
            /// When generating output, include the names of unmodified files if
            /// they are included in the git_diff.  Normally these are skipped in
            /// the formats that list files (e.g. name-only, name-status, raw).
            /// Even with this, these will not be included in patch format.
            /// </summary>
            GIT_DIFF_SHOW_UNMODIFIED = unchecked((uint)(1u << 26)),
            
            /// <summary>
            /// Use the "patience diff" algorithm
            /// </summary>
            GIT_DIFF_PATIENCE = unchecked((uint)(1u << 28)),
            
            /// <summary>
            /// Take extra time to find minimal diff
            /// </summary>
            GIT_DIFF_MINIMAL = unchecked((uint)(1u << 29)),
            
            /// <summary>
            /// Include the necessary deflate / delta information so that `git-apply`
            /// can apply given diff information to binary files.
            /// </summary>
            GIT_DIFF_SHOW_BINARY = unchecked((uint)(1u << 30)),
        }
        
        /// <summary>
        /// Normal diff, the default
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_NORMAL = git_diff_option_t.GIT_DIFF_NORMAL;
        
        /// <summary>
        /// Reverse the sides of the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_REVERSE = git_diff_option_t.GIT_DIFF_REVERSE;
        
        /// <summary>
        /// Include ignored files in the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_IGNORED = git_diff_option_t.GIT_DIFF_INCLUDE_IGNORED;
        
        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
        /// will be marked with only a single entry in the diff; this flag
        /// adds all files under the directory as IGNORED entries, too.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_RECURSE_IGNORED_DIRS = git_diff_option_t.GIT_DIFF_RECURSE_IGNORED_DIRS;
        
        /// <summary>
        /// Include untracked files in the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_UNTRACKED = git_diff_option_t.GIT_DIFF_INCLUDE_UNTRACKED;
        
        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
        /// directory will be marked with only a single entry in the diff
        /// (a la what core Git does in `git status`); this flag adds *all*
        /// files under untracked directories as UNTRACKED entries, too.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_RECURSE_UNTRACKED_DIRS = git_diff_option_t.GIT_DIFF_RECURSE_UNTRACKED_DIRS;
        
        /// <summary>
        /// Include unmodified files in the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_UNMODIFIED = git_diff_option_t.GIT_DIFF_INCLUDE_UNMODIFIED;
        
        /// <summary>
        /// Normally, a type change between files will be converted into a
        /// DELETED record for the old and an ADDED record for the new; this
        /// options enabled the generation of TYPECHANGE delta records.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_TYPECHANGE = git_diff_option_t.GIT_DIFF_INCLUDE_TYPECHANGE;
        
        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob-&gt;tree changes still
        /// generally show as a DELETED blob.  This flag tries to correctly
        /// label blob-&gt;tree transitions as TYPECHANGE records with new_file's
        /// mode set to tree.  Note: the tree SHA will not be available.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_TYPECHANGE_TREES = git_diff_option_t.GIT_DIFF_INCLUDE_TYPECHANGE_TREES;
        
        /// <summary>
        /// Ignore file mode changes
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_FILEMODE = git_diff_option_t.GIT_DIFF_IGNORE_FILEMODE;
        
        /// <summary>
        /// Treat all submodules as unmodified
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_SUBMODULES = git_diff_option_t.GIT_DIFF_IGNORE_SUBMODULES;
        
        /// <summary>
        /// Use case insensitive filename comparisons
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_CASE = git_diff_option_t.GIT_DIFF_IGNORE_CASE;
        
        /// <summary>
        /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
        /// that has changed case will be returned as an add/delete pair.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_CASECHANGE = git_diff_option_t.GIT_DIFF_INCLUDE_CASECHANGE;
        
        /// <summary>
        /// If the pathspec is set in the diff options, this flags indicates
        /// that the paths will be treated as literal paths instead of
        /// fnmatch patterns.  Each path in the list must either be a full
        /// path to a file or a directory.  (A trailing slash indicates that
        /// the path will _only_ match a directory).  If a directory is
        /// specified, all children will be included.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_DISABLE_PATHSPEC_MATCH = git_diff_option_t.GIT_DIFF_DISABLE_PATHSPEC_MATCH;
        
        /// <summary>
        /// Disable updating of the `binary` flag in delta records.  This is
        /// useful when iterating over a diff if you don't need hunk and data
        /// callbacks and want to avoid having to load file completely.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_SKIP_BINARY_CHECK = git_diff_option_t.GIT_DIFF_SKIP_BINARY_CHECK;
        
        /// <summary>
        /// When diff finds an untracked directory, to match the behavior of
        /// core Git, it scans the contents for IGNORED and UNTRACKED files.
        /// If *all* contents are IGNORED, then the directory is IGNORED; if
        /// any contents are not IGNORED, then the directory is UNTRACKED.
        /// This is extra work that may not matter in many cases.  This flag
        /// turns off that scan and immediately labels an untracked directory
        /// as UNTRACKED (changing the behavior to not match core Git).
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = git_diff_option_t.GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS;
        
        /// <summary>
        /// When diff finds a file in the working directory with stat
        /// information different from the index, but the OID ends up being the
        /// same, write the correct stat information into the index.  Note:
        /// without this flag, diff will always leave the index untouched.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_UPDATE_INDEX = git_diff_option_t.GIT_DIFF_UPDATE_INDEX;
        
        /// <summary>
        /// Include unreadable files in the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_UNREADABLE = git_diff_option_t.GIT_DIFF_INCLUDE_UNREADABLE;
        
        /// <summary>
        /// Include unreadable files in the diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = git_diff_option_t.GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;
        
        /// <summary>
        /// Use a heuristic that takes indentation and whitespace into account
        /// which generally can produce better diffs when dealing with ambiguous
        /// diff hunks.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_INDENT_HEURISTIC = git_diff_option_t.GIT_DIFF_INDENT_HEURISTIC;
        
        /// <summary>
        /// Ignore blank lines
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_BLANK_LINES = git_diff_option_t.GIT_DIFF_IGNORE_BLANK_LINES;
        
        /// <summary>
        /// Treat all files as text, disabling binary attributes 
        /// &amp;
        /// detection
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_FORCE_TEXT = git_diff_option_t.GIT_DIFF_FORCE_TEXT;
        
        /// <summary>
        /// Treat all files as binary, disabling text diffs
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_FORCE_BINARY = git_diff_option_t.GIT_DIFF_FORCE_BINARY;
        
        /// <summary>
        /// Ignore all whitespace
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_WHITESPACE = git_diff_option_t.GIT_DIFF_IGNORE_WHITESPACE;
        
        /// <summary>
        /// Ignore changes in amount of whitespace
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_WHITESPACE_CHANGE = git_diff_option_t.GIT_DIFF_IGNORE_WHITESPACE_CHANGE;
        
        /// <summary>
        /// Ignore whitespace at end of line
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_IGNORE_WHITESPACE_EOL = git_diff_option_t.GIT_DIFF_IGNORE_WHITESPACE_EOL;
        
        /// <summary>
        /// When generating patch text, include the content of untracked
        /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
        /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
        /// flag if you want the content of every single UNTRACKED file.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_SHOW_UNTRACKED_CONTENT = git_diff_option_t.GIT_DIFF_SHOW_UNTRACKED_CONTENT;
        
        /// <summary>
        /// When generating output, include the names of unmodified files if
        /// they are included in the git_diff.  Normally these are skipped in
        /// the formats that list files (e.g. name-only, name-status, raw).
        /// Even with this, these will not be included in patch format.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_SHOW_UNMODIFIED = git_diff_option_t.GIT_DIFF_SHOW_UNMODIFIED;
        
        /// <summary>
        /// Use the "patience diff" algorithm
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_PATIENCE = git_diff_option_t.GIT_DIFF_PATIENCE;
        
        /// <summary>
        /// Take extra time to find minimal diff
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_MINIMAL = git_diff_option_t.GIT_DIFF_MINIMAL;
        
        /// <summary>
        /// Include the necessary deflate / delta information so that `git-apply`
        /// can apply given diff information to binary files.
        /// </summary>
        public const libgit2.git_diff_option_t GIT_DIFF_SHOW_BINARY = git_diff_option_t.GIT_DIFF_SHOW_BINARY;
        
        /// <summary>
        /// Flags for the delta object and the file objects on each side.
        /// </summary>
        /// <remarks>
        /// These flags are used for both the `flags` value of the `git_diff_delta`
        /// and the flags for the `git_diff_file` objects representing the old and
        /// new sides of the delta.  Values outside of this public range should be
        /// considered reserved for internal or future use.
        /// </remarks>
        [Flags]
        public enum git_diff_flag_t : uint
        {
            /// <summary>
            /// file(s) treated as binary data
            /// </summary>
            GIT_DIFF_FLAG_BINARY = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// file(s) treated as text data
            /// </summary>
            GIT_DIFF_FLAG_NOT_BINARY = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// `id` value is known correct
            /// </summary>
            GIT_DIFF_FLAG_VALID_ID = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// file exists at this side of the delta
            /// </summary>
            GIT_DIFF_FLAG_EXISTS = unchecked((uint)(1u << 3)),
            
            /// <summary>
            /// file size value is known correct
            /// </summary>
            GIT_DIFF_FLAG_VALID_SIZE = unchecked((uint)(1u << 4)),
        }
        
        /// <summary>
        /// file(s) treated as binary data
        /// </summary>
        public const libgit2.git_diff_flag_t GIT_DIFF_FLAG_BINARY = git_diff_flag_t.GIT_DIFF_FLAG_BINARY;
        
        /// <summary>
        /// file(s) treated as text data
        /// </summary>
        public const libgit2.git_diff_flag_t GIT_DIFF_FLAG_NOT_BINARY = git_diff_flag_t.GIT_DIFF_FLAG_NOT_BINARY;
        
        /// <summary>
        /// `id` value is known correct
        /// </summary>
        public const libgit2.git_diff_flag_t GIT_DIFF_FLAG_VALID_ID = git_diff_flag_t.GIT_DIFF_FLAG_VALID_ID;
        
        /// <summary>
        /// file exists at this side of the delta
        /// </summary>
        public const libgit2.git_diff_flag_t GIT_DIFF_FLAG_EXISTS = git_diff_flag_t.GIT_DIFF_FLAG_EXISTS;
        
        /// <summary>
        /// file size value is known correct
        /// </summary>
        public const libgit2.git_diff_flag_t GIT_DIFF_FLAG_VALID_SIZE = git_diff_flag_t.GIT_DIFF_FLAG_VALID_SIZE;
        
        /// <summary>
        /// What type of change is described by a git_diff_delta?
        /// </summary>
        /// <remarks>
        /// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
        /// `git_diff_find_similar()` on the diff object.`GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
        /// in the option flags (otherwise type changes will be split into ADDED /
        /// DELETED pairs).
        /// </remarks>
        public enum git_delta_t : uint
        {
            /// <summary>
            /// no changes
            /// </summary>
            GIT_DELTA_UNMODIFIED = unchecked((uint)0),
            
            /// <summary>
            /// entry does not exist in old version
            /// </summary>
            GIT_DELTA_ADDED = unchecked((uint)1),
            
            /// <summary>
            /// entry does not exist in new version
            /// </summary>
            GIT_DELTA_DELETED = unchecked((uint)2),
            
            /// <summary>
            /// entry content changed between old and new
            /// </summary>
            GIT_DELTA_MODIFIED = unchecked((uint)3),
            
            /// <summary>
            /// entry was renamed between old and new
            /// </summary>
            GIT_DELTA_RENAMED = unchecked((uint)4),
            
            /// <summary>
            /// entry was copied from another old entry
            /// </summary>
            GIT_DELTA_COPIED = unchecked((uint)5),
            
            /// <summary>
            /// entry is ignored item in workdir
            /// </summary>
            GIT_DELTA_IGNORED = unchecked((uint)6),
            
            /// <summary>
            /// entry is untracked item in workdir
            /// </summary>
            GIT_DELTA_UNTRACKED = unchecked((uint)7),
            
            /// <summary>
            /// type of entry changed between old and new
            /// </summary>
            GIT_DELTA_TYPECHANGE = unchecked((uint)8),
            
            /// <summary>
            /// entry is unreadable
            /// </summary>
            GIT_DELTA_UNREADABLE = unchecked((uint)9),
            
            /// <summary>
            /// entry in the index is conflicted
            /// </summary>
            GIT_DELTA_CONFLICTED = unchecked((uint)10),
        }
        
        /// <summary>
        /// no changes
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_UNMODIFIED = git_delta_t.GIT_DELTA_UNMODIFIED;
        
        /// <summary>
        /// entry does not exist in old version
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_ADDED = git_delta_t.GIT_DELTA_ADDED;
        
        /// <summary>
        /// entry does not exist in new version
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_DELETED = git_delta_t.GIT_DELTA_DELETED;
        
        /// <summary>
        /// entry content changed between old and new
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_MODIFIED = git_delta_t.GIT_DELTA_MODIFIED;
        
        /// <summary>
        /// entry was renamed between old and new
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_RENAMED = git_delta_t.GIT_DELTA_RENAMED;
        
        /// <summary>
        /// entry was copied from another old entry
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_COPIED = git_delta_t.GIT_DELTA_COPIED;
        
        /// <summary>
        /// entry is ignored item in workdir
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_IGNORED = git_delta_t.GIT_DELTA_IGNORED;
        
        /// <summary>
        /// entry is untracked item in workdir
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_UNTRACKED = git_delta_t.GIT_DELTA_UNTRACKED;
        
        /// <summary>
        /// type of entry changed between old and new
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_TYPECHANGE = git_delta_t.GIT_DELTA_TYPECHANGE;
        
        /// <summary>
        /// entry is unreadable
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_UNREADABLE = git_delta_t.GIT_DELTA_UNREADABLE;
        
        /// <summary>
        /// entry in the index is conflicted
        /// </summary>
        public const libgit2.git_delta_t GIT_DELTA_CONFLICTED = git_delta_t.GIT_DELTA_CONFLICTED;
        
        /// <summary>
        /// When producing a binary diff, the binary data returned will be
        /// either the deflated full ("literal") contents of the file, or
        /// the deflated binary delta between the two sides (whichever is
        /// smaller).
        /// </summary>
        public enum git_diff_binary_t : uint
        {
            /// <summary>
            /// There is no binary delta.
            /// </summary>
            GIT_DIFF_BINARY_NONE,
            
            /// <summary>
            /// The binary data is the literal contents of the file.
            /// </summary>
            GIT_DIFF_BINARY_LITERAL,
            
            /// <summary>
            /// The binary data is the delta from one side to the other.
            /// </summary>
            GIT_DIFF_BINARY_DELTA,
        }
        
        /// <summary>
        /// There is no binary delta.
        /// </summary>
        public const libgit2.git_diff_binary_t GIT_DIFF_BINARY_NONE = git_diff_binary_t.GIT_DIFF_BINARY_NONE;
        
        /// <summary>
        /// The binary data is the literal contents of the file.
        /// </summary>
        public const libgit2.git_diff_binary_t GIT_DIFF_BINARY_LITERAL = git_diff_binary_t.GIT_DIFF_BINARY_LITERAL;
        
        /// <summary>
        /// The binary data is the delta from one side to the other.
        /// </summary>
        public const libgit2.git_diff_binary_t GIT_DIFF_BINARY_DELTA = git_diff_binary_t.GIT_DIFF_BINARY_DELTA;
        
        /// <summary>
        /// Line origin constants.
        /// </summary>
        /// <remarks>
        /// These values describe where a line came from and will be passed to
        /// the git_diff_line_cb when iterating over a diff.  There are some
        /// special origin constants at the end that are used for the text
        /// output callbacks to demarcate lines that are actually part of
        /// the file or hunk headers.
        /// </remarks>
        public enum git_diff_line_t : uint
        {
            /// <summary>
            /// These values will be sent to `git_diff_line_cb` along with the line
            /// </summary>
            GIT_DIFF_LINE_CONTEXT = unchecked((uint)' '),
            
            /// <summary>
            /// These values will be sent to `git_diff_line_cb` along with the line
            /// </summary>
            GIT_DIFF_LINE_ADDITION = unchecked((uint)'+'),
            
            /// <summary>
            /// These values will be sent to `git_diff_line_cb` along with the line
            /// </summary>
            GIT_DIFF_LINE_DELETION = unchecked((uint)'-'),
            
            /// <summary>
            /// Both files have no LF at end
            /// </summary>
            GIT_DIFF_LINE_CONTEXT_EOFNL = unchecked((uint)'='),
            
            /// <summary>
            /// Old has no LF at end, new does
            /// </summary>
            GIT_DIFF_LINE_ADD_EOFNL = unchecked((uint)'>'),
            
            /// <summary>
            /// Old has LF at end, new does not
            /// </summary>
            GIT_DIFF_LINE_DEL_EOFNL = unchecked((uint)'<'),
            
            /// <summary>
            /// The following values will only be sent to a `git_diff_line_cb` when
            /// the content of a diff is being formatted through `git_diff_print`.
            /// </summary>
            GIT_DIFF_LINE_FILE_HDR = unchecked((uint)'F'),
            
            /// <summary>
            /// The following values will only be sent to a `git_diff_line_cb` when
            /// the content of a diff is being formatted through `git_diff_print`.
            /// </summary>
            GIT_DIFF_LINE_HUNK_HDR = unchecked((uint)'H'),
            
            /// <summary>
            /// For "Binary files x and y differ"
            /// </summary>
            GIT_DIFF_LINE_BINARY = unchecked((uint)'B'),
        }
        
        /// <summary>
        /// These values will be sent to `git_diff_line_cb` along with the line
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_CONTEXT = git_diff_line_t.GIT_DIFF_LINE_CONTEXT;
        
        /// <summary>
        /// These values will be sent to `git_diff_line_cb` along with the line
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_ADDITION = git_diff_line_t.GIT_DIFF_LINE_ADDITION;
        
        /// <summary>
        /// These values will be sent to `git_diff_line_cb` along with the line
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_DELETION = git_diff_line_t.GIT_DIFF_LINE_DELETION;
        
        /// <summary>
        /// Both files have no LF at end
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_CONTEXT_EOFNL = git_diff_line_t.GIT_DIFF_LINE_CONTEXT_EOFNL;
        
        /// <summary>
        /// Old has no LF at end, new does
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_ADD_EOFNL = git_diff_line_t.GIT_DIFF_LINE_ADD_EOFNL;
        
        /// <summary>
        /// Old has LF at end, new does not
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_DEL_EOFNL = git_diff_line_t.GIT_DIFF_LINE_DEL_EOFNL;
        
        /// <summary>
        /// The following values will only be sent to a `git_diff_line_cb` when
        /// the content of a diff is being formatted through `git_diff_print`.
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_FILE_HDR = git_diff_line_t.GIT_DIFF_LINE_FILE_HDR;
        
        /// <summary>
        /// The following values will only be sent to a `git_diff_line_cb` when
        /// the content of a diff is being formatted through `git_diff_print`.
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_HUNK_HDR = git_diff_line_t.GIT_DIFF_LINE_HUNK_HDR;
        
        /// <summary>
        /// For "Binary files x and y differ"
        /// </summary>
        public const libgit2.git_diff_line_t GIT_DIFF_LINE_BINARY = git_diff_line_t.GIT_DIFF_LINE_BINARY;
        
        /// <summary>
        /// Flags to control the behavior of diff rename/copy detection.
        /// </summary>
        [Flags]
        public enum git_diff_find_t : uint
        {
            /// <summary>
            /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
            /// </summary>
            GIT_DIFF_FIND_BY_CONFIG = unchecked((uint)0),
            
            /// <summary>
            /// Look for renames? (`--find-renames`)
            /// </summary>
            GIT_DIFF_FIND_RENAMES = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
            /// </summary>
            GIT_DIFF_FIND_RENAMES_FROM_REWRITES = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// Look for copies? (a la `--find-copies`).
            /// </summary>
            GIT_DIFF_FIND_COPIES = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
            /// </summary>
            /// <remarks>
            /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
            /// the initial `git_diff` is being generated.
            /// </remarks>
            GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = unchecked((uint)(1u << 3)),
            
            /// <summary>
            /// Mark significant rewrites for split (`--break-rewrites=/M`)
            /// </summary>
            GIT_DIFF_FIND_REWRITES = unchecked((uint)(1u << 4)),
            
            /// <summary>
            /// Actually split large rewrites into delete/add pairs
            /// </summary>
            GIT_DIFF_BREAK_REWRITES = unchecked((uint)(1u << 5)),
            
            /// <summary>
            /// Mark rewrites for split and break into delete/add pairs
            /// </summary>
            GIT_DIFF_FIND_AND_BREAK_REWRITES = unchecked((uint)(GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES)),
            
            /// <summary>
            /// Find renames/copies for UNTRACKED items in working directory.
            /// </summary>
            /// <remarks>
            /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
            /// initial `git_diff` is being generated (and obviously the diff must
            /// be against the working directory for this to make sense).
            /// </remarks>
            GIT_DIFF_FIND_FOR_UNTRACKED = unchecked((uint)(1u << 6)),
            
            /// <summary>
            /// Turn on all finding features.
            /// </summary>
            GIT_DIFF_FIND_ALL = unchecked((uint)(0x0ff)),
            
            /// <summary>
            /// Measure similarity ignoring leading whitespace (default)
            /// </summary>
            GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = unchecked((uint)0),
            
            /// <summary>
            /// Measure similarity ignoring all whitespace
            /// </summary>
            GIT_DIFF_FIND_IGNORE_WHITESPACE = unchecked((uint)(1u << 12)),
            
            /// <summary>
            /// Measure similarity including all data
            /// </summary>
            GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = unchecked((uint)(1u << 13)),
            
            /// <summary>
            /// Measure similarity only by comparing SHAs (fast and cheap)
            /// </summary>
            GIT_DIFF_FIND_EXACT_MATCH_ONLY = unchecked((uint)(1u << 14)),
            
            /// <summary>
            /// Do not break rewrites unless they contribute to a rename.
            /// </summary>
            /// <remarks>
            /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
            /// similarity of modified files and split the ones that have changed a
            /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
            /// considered candidates for rename and copy detection.If you add this flag in and the split pair is *not* used for an
            /// actual rename or copy, then the modified record will be restored to
            /// a regular MODIFIED record instead of being split.
            /// </remarks>
            GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = unchecked((uint)(1u << 15)),
            
            /// <summary>
            /// Remove any UNMODIFIED deltas after find_similar is done.
            /// </summary>
            /// <remarks>
            /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
            /// --find-copies-harder behavior requires building a diff with the
            /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
            /// records in the final result, pass this flag to have them removed.
            /// </remarks>
            GIT_DIFF_FIND_REMOVE_UNMODIFIED = unchecked((uint)(1u << 16)),
        }
        
        /// <summary>
        /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_BY_CONFIG = git_diff_find_t.GIT_DIFF_FIND_BY_CONFIG;
        
        /// <summary>
        /// Look for renames? (`--find-renames`)
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_RENAMES = git_diff_find_t.GIT_DIFF_FIND_RENAMES;
        
        /// <summary>
        /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_RENAMES_FROM_REWRITES = git_diff_find_t.GIT_DIFF_FIND_RENAMES_FROM_REWRITES;
        
        /// <summary>
        /// Look for copies? (a la `--find-copies`).
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_COPIES = git_diff_find_t.GIT_DIFF_FIND_COPIES;
        
        /// <summary>
        /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
        /// </summary>
        /// <remarks>
        /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
        /// the initial `git_diff` is being generated.
        /// </remarks>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = git_diff_find_t.GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED;
        
        /// <summary>
        /// Mark significant rewrites for split (`--break-rewrites=/M`)
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_REWRITES = git_diff_find_t.GIT_DIFF_FIND_REWRITES;
        
        /// <summary>
        /// Actually split large rewrites into delete/add pairs
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_BREAK_REWRITES = git_diff_find_t.GIT_DIFF_BREAK_REWRITES;
        
        /// <summary>
        /// Mark rewrites for split and break into delete/add pairs
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_AND_BREAK_REWRITES = git_diff_find_t.GIT_DIFF_FIND_AND_BREAK_REWRITES;
        
        /// <summary>
        /// Find renames/copies for UNTRACKED items in working directory.
        /// </summary>
        /// <remarks>
        /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
        /// initial `git_diff` is being generated (and obviously the diff must
        /// be against the working directory for this to make sense).
        /// </remarks>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_FOR_UNTRACKED = git_diff_find_t.GIT_DIFF_FIND_FOR_UNTRACKED;
        
        /// <summary>
        /// Turn on all finding features.
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_ALL = git_diff_find_t.GIT_DIFF_FIND_ALL;
        
        /// <summary>
        /// Measure similarity ignoring leading whitespace (default)
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = git_diff_find_t.GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE;
        
        /// <summary>
        /// Measure similarity ignoring all whitespace
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_IGNORE_WHITESPACE = git_diff_find_t.GIT_DIFF_FIND_IGNORE_WHITESPACE;
        
        /// <summary>
        /// Measure similarity including all data
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = git_diff_find_t.GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE;
        
        /// <summary>
        /// Measure similarity only by comparing SHAs (fast and cheap)
        /// </summary>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_EXACT_MATCH_ONLY = git_diff_find_t.GIT_DIFF_FIND_EXACT_MATCH_ONLY;
        
        /// <summary>
        /// Do not break rewrites unless they contribute to a rename.
        /// </summary>
        /// <remarks>
        /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
        /// similarity of modified files and split the ones that have changed a
        /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
        /// considered candidates for rename and copy detection.If you add this flag in and the split pair is *not* used for an
        /// actual rename or copy, then the modified record will be restored to
        /// a regular MODIFIED record instead of being split.
        /// </remarks>
        public const libgit2.git_diff_find_t GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = git_diff_find_t.GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;
        
        /// <summary>
        /// Remove any UNMODIFIED deltas after find_similar is done.
        /// </summary>
        /// <remarks>
        /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
        /// --find-copies-harder behavior requires building a diff with the
        /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
        /// records in the final result, pass this flag to have them removed.
        /// </remarks>
        public const libgit2.git_diff_find_t GIT_DIFF_FIND_REMOVE_UNMODIFIED = git_diff_find_t.GIT_DIFF_FIND_REMOVE_UNMODIFIED;
        
        /// <summary>
        /// Possible output formats for diff data
        /// </summary>
        public enum git_diff_format_t : uint
        {
            /// <summary>
            /// full git diff
            /// </summary>
            GIT_DIFF_FORMAT_PATCH = unchecked((uint)1u),
            
            /// <summary>
            /// just the file headers of patch
            /// </summary>
            GIT_DIFF_FORMAT_PATCH_HEADER = unchecked((uint)2u),
            
            /// <summary>
            /// like git diff --raw
            /// </summary>
            GIT_DIFF_FORMAT_RAW = unchecked((uint)3u),
            
            /// <summary>
            /// like git diff --name-only
            /// </summary>
            GIT_DIFF_FORMAT_NAME_ONLY = unchecked((uint)4u),
            
            /// <summary>
            /// like git diff --name-status
            /// </summary>
            GIT_DIFF_FORMAT_NAME_STATUS = unchecked((uint)5u),
            
            /// <summary>
            /// git diff as used by git patch-id
            /// </summary>
            GIT_DIFF_FORMAT_PATCH_ID = unchecked((uint)6u),
        }
        
        /// <summary>
        /// full git diff
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_PATCH = git_diff_format_t.GIT_DIFF_FORMAT_PATCH;
        
        /// <summary>
        /// just the file headers of patch
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_PATCH_HEADER = git_diff_format_t.GIT_DIFF_FORMAT_PATCH_HEADER;
        
        /// <summary>
        /// like git diff --raw
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_RAW = git_diff_format_t.GIT_DIFF_FORMAT_RAW;
        
        /// <summary>
        /// like git diff --name-only
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_NAME_ONLY = git_diff_format_t.GIT_DIFF_FORMAT_NAME_ONLY;
        
        /// <summary>
        /// like git diff --name-status
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_NAME_STATUS = git_diff_format_t.GIT_DIFF_FORMAT_NAME_STATUS;
        
        /// <summary>
        /// git diff as used by git patch-id
        /// </summary>
        public const libgit2.git_diff_format_t GIT_DIFF_FORMAT_PATCH_ID = git_diff_format_t.GIT_DIFF_FORMAT_PATCH_ID;
        
        /// <summary>
        /// Formatting options for diff stats
        /// </summary>
        [Flags]
        public enum git_diff_stats_format_t : uint
        {
            /// <summary>
            /// No stats
            /// </summary>
            GIT_DIFF_STATS_NONE = unchecked((uint)0),
            
            /// <summary>
            /// Full statistics, equivalent of `--stat`
            /// </summary>
            GIT_DIFF_STATS_FULL = unchecked((uint)(1u << 0)),
            
            /// <summary>
            /// Short statistics, equivalent of `--shortstat`
            /// </summary>
            GIT_DIFF_STATS_SHORT = unchecked((uint)(1u << 1)),
            
            /// <summary>
            /// Number statistics, equivalent of `--numstat`
            /// </summary>
            GIT_DIFF_STATS_NUMBER = unchecked((uint)(1u << 2)),
            
            /// <summary>
            /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
            /// </summary>
            GIT_DIFF_STATS_INCLUDE_SUMMARY = unchecked((uint)(1u << 3)),
        }
        
        /// <summary>
        /// No stats
        /// </summary>
        public const libgit2.git_diff_stats_format_t GIT_DIFF_STATS_NONE = git_diff_stats_format_t.GIT_DIFF_STATS_NONE;
        
        /// <summary>
        /// Full statistics, equivalent of `--stat`
        /// </summary>
        public const libgit2.git_diff_stats_format_t GIT_DIFF_STATS_FULL = git_diff_stats_format_t.GIT_DIFF_STATS_FULL;
        
        /// <summary>
        /// Short statistics, equivalent of `--shortstat`
        /// </summary>
        public const libgit2.git_diff_stats_format_t GIT_DIFF_STATS_SHORT = git_diff_stats_format_t.GIT_DIFF_STATS_SHORT;
        
        /// <summary>
        /// Number statistics, equivalent of `--numstat`
        /// </summary>
        public const libgit2.git_diff_stats_format_t GIT_DIFF_STATS_NUMBER = git_diff_stats_format_t.GIT_DIFF_STATS_NUMBER;
        
        /// <summary>
        /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
        /// </summary>
        public const libgit2.git_diff_stats_format_t GIT_DIFF_STATS_INCLUDE_SUMMARY = git_diff_stats_format_t.GIT_DIFF_STATS_INCLUDE_SUMMARY;
        
        /// <summary>
        /// The diff object that contains all individual file deltas.
        /// </summary>
        /// <remarks>
        /// A `diff` represents the cumulative list of differences between two
        /// snapshots of a repository (possibly filtered by a set of file name
        /// patterns).Calculating diffs is generally done in two phases: building a list of
        /// diffs then traversing it. This makes is easier to share logic across
        /// the various types of diffs (tree vs tree, workdir vs index, etc.), and
        /// also allows you to insert optional diff post-processing phases,
        /// such as rename detection, in between the steps. When you are done with
        /// a diff object, it must be freed.This is an opaque structure which will be allocated by one of the diff
        /// generator functions below (such as `git_diff_tree_to_tree`). You are
        /// responsible for releasing the object memory when done, using the
        /// `git_diff_free()` function.
        /// </remarks>
        public readonly partial struct git_diff : IEquatable<git_diff>
        {
            public git_diff(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_diff other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_diff other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_diff left, git_diff right) => left.Equals(right);
            
            public static bool operator !=(git_diff left, git_diff right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Description of one side of a delta.
        /// </summary>
        /// <remarks>
        /// Although this is called a "file", it could represent a file, a symbolic
        /// link, a submodule commit id, or even a tree (although that only if you
        /// are tracking type changes or ignored/untracked directories).
        /// </remarks>
        public partial struct git_diff_file
        {
            /// <summary>
            /// The `git_oid` of the item.  If the entry represents an
            /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
            /// then the oid will be zeroes.
            /// </summary>
            public libgit2.git_oid id;
            
            /// <summary>
            /// The NUL-terminated path to the entry relative to the working
            /// directory of the repository.
            /// </summary>
            public byte* path;
            
            /// <summary>
            /// The size of the entry in bytes.
            /// </summary>
            public libgit2.git_object_size_t size;
            
            /// <summary>
            /// A combination of the `git_diff_flag_t` types
            /// </summary>
            public libgit2.git_diff_flag_t flags;
            
            /// <summary>
            /// Roughly, the stat() `st_mode` value for the item.  This will
            /// be restricted to one of the `git_filemode_t` values.
            /// </summary>
            public libgit2.git_filemode_t mode;
            
            /// <summary>
            /// Represents the known length of the `id` field, when
            /// converted to a hex string.  It is generally `GIT_OID_SHA1_HEXSIZE`, unless this
            /// delta was created from reading a patch file, in which case it may be
            /// abbreviated to something reasonable, like 7 characters.
            /// </summary>
            public ushort id_abbrev;
        }
        
        /// <summary>
        /// Description of changes to one entry.
        /// </summary>
        /// <remarks>
        /// A `delta` is a file pair with an old and new revision.  The old version
        /// may be absent if the file was just created and the new version may be
        /// absent if the file was deleted.  A diff is mostly just a list of deltas.When iterating over a diff, this will be passed to most callbacks and
        /// you can use the contents to understand exactly what has changed.The `old_file` represents the "from" side of the diff and the `new_file`
        /// represents to "to" side of the diff.  What those means depend on the
        /// function that was used to generate the diff and will be documented below.
        /// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.Although the two sides of the delta are named "old_file" and "new_file",
        /// they actually may correspond to entries that represent a file, a symbolic
        /// link, a submodule commit id, or even a tree (if you are tracking type
        /// changes or ignored/untracked directories).Under some circumstances, in the name of efficiency, not all fields will
        /// be filled in, but we generally try to fill in as much as possible.  One
        /// example is that the "flags" field may not have either the `BINARY` or the
        /// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
        /// in hunk and/or line callbacks to the diff foreach iteration function.  It
        /// will just use the git attributes for those files.The similarity score is zero unless you call `git_diff_find_similar()`
        /// which does a similarity analysis of files in the diff.  Use that
        /// function to do rename and copy detection, and to split heavily modified
        /// files in add/delete pairs.  After that call, deltas with a status of
        /// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
        /// between 0 and 100 indicating how similar the old and new sides are.If you ask `git_diff_find_similar` to find heavily modified files to
        /// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
        /// records may have a non-zero similarity score if the self-similarity is
        /// below the split threshold.  To display this value like core Git, invert
        /// the score (a la `printf("M%03d", 100 - delta-&gt;similarity)`).
        /// </remarks>
        public partial struct git_diff_delta
        {
            public libgit2.git_delta_t status;
            
            /// <summary>
            /// git_diff_flag_t values
            /// </summary>
            public libgit2.git_diff_flag_t flags;
            
            /// <summary>
            /// for RENAMED and COPIED, value 0-100
            /// </summary>
            public ushort similarity;
            
            /// <summary>
            /// number of files in this delta
            /// </summary>
            public ushort nfiles;
            
            public libgit2.git_diff_file old_file;
            
            public libgit2.git_diff_file new_file;
        }
        
        /// <summary>
        /// Structure describing options about how the diff should be executed.
        /// </summary>
        /// <remarks>
        /// Setting all values of the structure to zero will yield the default
        /// values.  Similarly, passing NULL for the options structure will
        /// give the defaults.  The default values are marked below.
        /// </remarks>
        public partial struct git_diff_options
        {
            /// <summary>
            /// version for the struct
            /// </summary>
            public uint version;
            
            /// <summary>
            /// A combination of `git_diff_option_t` values above.
            /// Defaults to GIT_DIFF_NORMAL
            /// </summary>
            public libgit2.git_diff_option_t flags;
            
            /// <summary>
            /// Overrides the submodule ignore setting for all submodules in the diff.
            /// </summary>
            public libgit2.git_submodule_ignore_t ignore_submodules;
            
            /// <summary>
            /// An array of paths / fnmatch patterns to constrain diff.
            /// All paths are included by default.
            /// </summary>
            public libgit2.git_strarray pathspec;
            
            /// <summary>
            /// An optional callback function, notifying the consumer of changes to
            /// the diff as new deltas are added.
            /// </summary>
            public libgit2.git_diff_notify_cb notify_cb;
            
            /// <summary>
            /// An optional callback function, notifying the consumer of which files
            /// are being examined as the diff is generated.
            /// </summary>
            public libgit2.git_diff_progress_cb progress_cb;
            
            /// <summary>
            /// The payload to pass to the callback functions.
            /// </summary>
            public void* payload;
            
            /// <summary>
            /// The number of unchanged lines that define the boundary of a hunk
            /// (and to display before and after). Defaults to 3.
            /// </summary>
            public uint context_lines;
            
            /// <summary>
            /// The maximum number of unchanged lines between hunk boundaries before
            /// the hunks will be merged into one. Defaults to 0.
            /// </summary>
            public uint interhunk_lines;
            
            /// <summary>
            /// The object ID type to emit in diffs; this is used by functions
            /// that operate without a repository - namely `git_diff_buffers`,
            /// or `git_diff_blobs` and `git_diff_blob_to_buffer` when one blob
            /// is `NULL`.
            /// </summary>
            /// <remarks>
            /// This may be omitted (set to `0`). If a repository is available,
            /// the object ID format of the repository will be used. If no
            /// repository is available then the default is `GIT_OID_SHA`.If this is specified and a repository is available, then the
            /// specified `oid_type` must match the repository's object ID
            /// format.
            /// </remarks>
            public libgit2.git_oid_t oid_type;
            
            /// <summary>
            /// The abbreviation length to use when formatting object ids.
            /// Defaults to the value of 'core.abbrev' from the config, or 7 if unset.
            /// </summary>
            public ushort id_abbrev;
            
            /// <summary>
            /// A size (in bytes) above which a blob will be marked as binary
            /// automatically; pass a negative value to disable.
            /// Defaults to 512MB.
            /// </summary>
            public libgit2.git_off_t max_size;
            
            /// <summary>
            /// The virtual "directory" prefix for old file names in hunk headers.
            /// Default is "a".
            /// </summary>
            public byte* old_prefix;
            
            /// <summary>
            /// The virtual "directory" prefix for new file names in hunk headers.
            /// Defaults to "b".
            /// </summary>
            public byte* new_prefix;
        }
        
        /// <summary>
        /// Diff notification callback function.
        /// </summary>
        /// <remarks>
        /// The callback will be called for each file, just before the `git_diff_delta`
        /// gets inserted into the diff.When the callback:
        /// - returns 
        /// &lt;
        /// 0, the diff process will be aborted.
        /// - returns &gt; 0, the delta will not be inserted into the diff, but the
        /// diff process continues.
        /// - returns 0, the delta is inserted into the diff, and the diff process
        /// continues.
        /// </remarks>
        public readonly partial struct git_diff_notify_cb : IEquatable<git_diff_notify_cb>
        {
            public git_diff_notify_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff, libgit2.git_diff_delta*, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff, libgit2.git_diff_delta*, byte*, void*, int> Value { get; }
            
            public bool Equals(git_diff_notify_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_notify_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff, libgit2.git_diff_delta*, byte*, void*, int>(git_diff_notify_cb from) => from.Value;
            
            public static implicit operator git_diff_notify_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff, libgit2.git_diff_delta*, byte*, void*, int> from) => new git_diff_notify_cb(from);
            
            public static bool operator ==(git_diff_notify_cb left, git_diff_notify_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_notify_cb left, git_diff_notify_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Diff progress callback.
        /// </summary>
        /// <param name="diff_so_far">The diff being generated.</param>
        /// <param name="old_path">The path to the old file or NULL.</param>
        /// <param name="new_path">The path to the new file or NULL.</param>
        /// <returns>@return Non-zero to abort the diff.</returns>
        /// <remarks>
        /// Called before each file comparison.
        /// </remarks>
        public readonly partial struct git_diff_progress_cb : IEquatable<git_diff_progress_cb>
        {
            public git_diff_progress_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff, byte*, byte*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff, byte*, byte*, void*, int> Value { get; }
            
            public bool Equals(git_diff_progress_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_progress_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff, byte*, byte*, void*, int>(git_diff_progress_cb from) => from.Value;
            
            public static implicit operator git_diff_progress_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff, byte*, byte*, void*, int> from) => new git_diff_progress_cb(from);
            
            public static bool operator ==(git_diff_progress_cb left, git_diff_progress_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_progress_cb left, git_diff_progress_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// The contents of one of the files in a binary diff.
        /// </summary>
        public partial struct git_diff_binary_file
        {
            /// <summary>
            /// The type of binary data for this file.
            /// </summary>
            public libgit2.git_diff_binary_t type;
            
            /// <summary>
            /// The binary data, deflated.
            /// </summary>
            public byte* data;
            
            /// <summary>
            /// The length of the binary data.
            /// </summary>
            public libgit2.size_t datalen;
            
            /// <summary>
            /// The length of the binary data after inflation.
            /// </summary>
            public libgit2.size_t inflatedlen;
        }
        
        /// <summary>
        /// Structure describing the binary contents of a diff.
        /// </summary>
        /// <remarks>
        /// A `binary` file / delta is a file (or pair) for which no text diffs
        /// should be generated. A diff can contain delta entries that are
        /// binary, but no diff content will be output for those files. There is
        /// a base heuristic for binary detection and you can further tune the
        /// behavior with git attributes or diff flags and option settings.
        /// </remarks>
        public partial struct git_diff_binary
        {
            /// <summary>
            /// Whether there is data in this binary structure or not.
            /// </summary>
            /// <remarks>
            /// If this is `1`, then this was produced and included binary content.
            /// If this is `0` then this was generated knowing only that a binary
            /// file changed but without providing the data, probably from a patch
            /// that said `Binary files a/file.txt and b/file.txt differ`.
            /// </remarks>
            public uint contains_data;
            
            /// <summary>
            /// The contents of the old file.
            /// </summary>
            public libgit2.git_diff_binary_file old_file;
            
            /// <summary>
            /// The contents of the new file.
            /// </summary>
            public libgit2.git_diff_binary_file new_file;
        }
        
        /// <summary>
        /// Structure describing a hunk of a diff.
        /// </summary>
        /// <remarks>
        /// A `hunk` is a span of modified lines in a delta along with some stable
        /// surrounding context. You can configure the amount of context and other
        /// properties of how hunks are generated. Each hunk also comes with a
        /// header that described where it starts and ends in both the old and new
        /// versions in the delta.
        /// </remarks>
        public unsafe partial struct git_diff_hunk
        {
            /// <summary>
            /// Starting line number in old_file
            /// </summary>
            public int old_start;
            
            /// <summary>
            /// Number of lines in old_file
            /// </summary>
            public int old_lines;
            
            /// <summary>
            /// Starting line number in new_file
            /// </summary>
            public int new_start;
            
            /// <summary>
            /// Number of lines in new_file
            /// </summary>
            public int new_lines;
            
            /// <summary>
            /// Number of bytes in header text
            /// </summary>
            public libgit2.size_t header_len;
            
            /// <summary>
            /// Header text, NUL-byte terminated
            /// </summary>
            public fixed byte header[128];
        }
        
        /// <summary>
        /// Structure describing a line (or data span) of a diff.
        /// </summary>
        /// <remarks>
        /// A `line` is a range of characters inside a hunk.  It could be a context
        /// line (i.e. in both old and new versions), an added line (i.e. only in
        /// the new version), or a removed line (i.e. only in the old version).
        /// Unfortunately, we don't know anything about the encoding of data in the
        /// file being diffed, so we cannot tell you much about the line content.
        /// Line data will not be NUL-byte terminated, however, because it will be
        /// just a span of bytes inside the larger file.
        /// </remarks>
        public partial struct git_diff_line
        {
            /// <summary>
            /// A git_diff_line_t value
            /// </summary>
            public byte origin;
            
            /// <summary>
            /// Line number in old file or -1 for added line
            /// </summary>
            public int old_lineno;
            
            /// <summary>
            /// Line number in new file or -1 for deleted line
            /// </summary>
            public int new_lineno;
            
            /// <summary>
            /// Number of newline characters in content
            /// </summary>
            public int num_lines;
            
            /// <summary>
            /// Number of bytes of data
            /// </summary>
            public libgit2.size_t content_len;
            
            /// <summary>
            /// Offset in the original file to the content
            /// </summary>
            public libgit2.git_off_t content_offset;
            
            /// <summary>
            /// Pointer to diff text, not NUL-byte terminated
            /// </summary>
            public byte* content;
        }
        
        /// <summary>
        /// Pluggable similarity metric
        /// </summary>
        public partial struct git_diff_similarity_metric
        {
            public delegate*unmanaged[Cdecl]<void**, libgit2.git_diff_file*, byte*, void*, int> file_signature;
            
            public delegate*unmanaged[Cdecl]<void**, libgit2.git_diff_file*, byte*, libgit2.size_t, void*, int> buffer_signature;
            
            public delegate*unmanaged[Cdecl]<void*, void*, void> free_signature;
            
            public delegate*unmanaged[Cdecl]<int*, void*, void*, void*, int> similarity;
            
            public void* payload;
        }
        
        /// <summary>
        /// Control behavior of rename and copy detection
        /// </summary>
        /// <remarks>
        /// These options mostly mimic parameters that can be passed to git-diff.
        /// </remarks>
        public partial struct git_diff_find_options
        {
            public uint version;
            
            /// <summary>
            /// Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
            /// NOTE: if you don't explicitly set this, `diff.renames` could be set
            /// to false, resulting in `git_diff_find_similar` doing nothing.
            /// </summary>
            public libgit2.git_diff_find_t flags;
            
            /// <summary>
            /// Threshold above which similar files will be considered renames.
            /// This is equivalent to the -M option. Defaults to 50.
            /// </summary>
            public ushort rename_threshold;
            
            /// <summary>
            /// Threshold below which similar files will be eligible to be a rename source.
            /// This is equivalent to the first part of the -B option. Defaults to 50.
            /// </summary>
            public ushort rename_from_rewrite_threshold;
            
            /// <summary>
            /// Threshold above which similar files will be considered copies.
            /// This is equivalent to the -C option. Defaults to 50.
            /// </summary>
            public ushort copy_threshold;
            
            /// <summary>
            /// Threshold below which similar files will be split into a delete/add pair.
            /// This is equivalent to the last part of the -B option. Defaults to 60.
            /// </summary>
            public ushort break_rewrite_threshold;
            
            /// <summary>
            /// Maximum number of matches to consider for a particular file.
            /// </summary>
            /// <remarks>
            /// This is a little different from the `-l` option from Git because we
            /// will still process up to this many matches before abandoning the search.
            /// Defaults to 1000.
            /// </remarks>
            public libgit2.size_t rename_limit;
            
            /// <summary>
            /// The `metric` option allows you to plug in a custom similarity metric.
            /// </summary>
            /// <remarks>
            /// Set it to NULL to use the default internal metric.The default metric is based on sampling hashes of ranges of data in
            /// the file, which is a pretty good similarity approximation that should
            /// work fairly well for both text and binary data while still being
            /// pretty fast with a fixed memory overhead.
            /// </remarks>
            public libgit2.git_diff_similarity_metric* metric;
        }
        
        /// <summary>
        /// Options for parsing a diff / patch file.
        /// </summary>
        public partial struct git_diff_parse_options
        {
            public uint version;
            
            public libgit2.git_oid_t oid_type;
        }
        
        /// <summary>
        /// This is an opaque structure which is allocated by `git_diff_get_stats`.
        /// You are responsible for releasing the object memory when done, using the
        /// `git_diff_stats_free()` function.
        /// </summary>
        public readonly partial struct git_diff_stats : IEquatable<git_diff_stats>
        {
            public git_diff_stats(nint handle) => Handle = handle;
            
            public nint Handle { get; }
            
            public bool Equals(git_diff_stats other) => Handle.Equals(other.Handle);
            
            public override bool Equals(object obj) => obj is git_diff_stats other && Equals(other);
            
            public override int GetHashCode() => Handle.GetHashCode();
            
            public override string ToString() => "0x" + (nint.Size == 8 ? Handle.ToString("X16") : Handle.ToString("X8"));
            
            public static bool operator ==(git_diff_stats left, git_diff_stats right) => left.Equals(right);
            
            public static bool operator !=(git_diff_stats left, git_diff_stats right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Patch ID options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_PATCHID_OPTIONS_INIT`. Alternatively, you can
        /// use `git_diff_patchid_options_init`.
        /// </remarks>
        public partial struct git_diff_patchid_options
        {
            public uint version;
        }
        
        /// <summary>
        /// When iterating over a diff, callback that will be made per file.
        /// </summary>
        /// <param name="delta">A pointer to the delta data for the file</param>
        /// <param name="progress">Goes from 0 to 1 over the diff</param>
        /// <param name="payload">User-specified pointer from foreach function</param>
        public readonly partial struct git_diff_file_cb : IEquatable<git_diff_file_cb>
        {
            public git_diff_file_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, float, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, float, void*, int> Value { get; }
            
            public bool Equals(git_diff_file_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_file_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, float, void*, int>(git_diff_file_cb from) => from.Value;
            
            public static implicit operator git_diff_file_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, float, void*, int> from) => new git_diff_file_cb(from);
            
            public static bool operator ==(git_diff_file_cb left, git_diff_file_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_file_cb left, git_diff_file_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// When iterating over a diff, callback that will be made for
        /// binary content within the diff.
        /// </summary>
        public readonly partial struct git_diff_binary_cb : IEquatable<git_diff_binary_cb>
        {
            public git_diff_binary_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_binary*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_binary*, void*, int> Value { get; }
            
            public bool Equals(git_diff_binary_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_binary_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_binary*, void*, int>(git_diff_binary_cb from) => from.Value;
            
            public static implicit operator git_diff_binary_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_binary*, void*, int> from) => new git_diff_binary_cb(from);
            
            public static bool operator ==(git_diff_binary_cb left, git_diff_binary_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_binary_cb left, git_diff_binary_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// When iterating over a diff, callback that will be made per hunk.
        /// </summary>
        public readonly partial struct git_diff_hunk_cb : IEquatable<git_diff_hunk_cb>
        {
            public git_diff_hunk_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, void*, int> Value { get; }
            
            public bool Equals(git_diff_hunk_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_hunk_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, void*, int>(git_diff_hunk_cb from) => from.Value;
            
            public static implicit operator git_diff_hunk_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, void*, int> from) => new git_diff_hunk_cb(from);
            
            public static bool operator ==(git_diff_hunk_cb left, git_diff_hunk_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_hunk_cb left, git_diff_hunk_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// When iterating over a diff, callback that will be made per text diff
        /// line. In this context, the provided range will be NULL.
        /// </summary>
        /// <remarks>
        /// When printing a diff, callback that will be made to output each line
        /// of text.  This uses some extra GIT_DIFF_LINE_... constants for output
        /// of lines of file and hunk headers.
        /// </remarks>
        public readonly partial struct git_diff_line_cb : IEquatable<git_diff_line_cb>
        {
            public git_diff_line_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, libgit2.git_diff_line*, void*, int> value) => this.Value = value;
            
            public delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, libgit2.git_diff_line*, void*, int> Value { get; }
            
            public bool Equals(git_diff_line_cb other) =>  Value == other.Value;
            
            public override bool Equals(object obj) => obj is git_diff_line_cb other && Equals(other);
            
            public override int GetHashCode() => ((nint)(void*)Value).GetHashCode();
            
            public override string ToString() => ((nint)(void*)Value).ToString();
            
            public static implicit operator delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, libgit2.git_diff_line*, void*, int>(git_diff_line_cb from) => from.Value;
            
            public static implicit operator git_diff_line_cb(delegate*unmanaged[Cdecl]<libgit2.git_diff_delta*, libgit2.git_diff_hunk*, libgit2.git_diff_line*, void*, int> from) => new git_diff_line_cb(from);
            
            public static bool operator ==(git_diff_line_cb left, git_diff_line_cb right) => left.Equals(right);
            
            public static bool operator !=(git_diff_line_cb left, git_diff_line_cb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Initialize git_diff_options structure
        /// </summary>
        /// <param name="opts">The `git_diff_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_DIFF_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_diff_options` with default values. Equivalent to creating
        /// an instance with GIT_DIFF_OPTIONS_INIT.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_options_init(out libgit2.git_diff_options opts, uint version);
        
        /// <summary>
        /// Initialize git_diff_find_options structure
        /// </summary>
        /// <param name="opts">The `git_diff_find_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_DIFF_FIND_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_diff_find_options` with default values. Equivalent to creating
        /// an instance with GIT_DIFF_FIND_OPTIONS_INIT.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_find_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_find_options_init(out libgit2.git_diff_find_options opts, uint version);
        
        /// <summary>
        /// Deallocate a diff.
        /// </summary>
        /// <param name="diff">The previously created diff; cannot be used after free.</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_diff_free(libgit2.git_diff diff);
        
        /// <summary>
        /// Create a diff with the difference between two tree objects.
        /// </summary>
        /// <param name="diff">Output pointer to a git_diff pointer to be allocated.</param>
        /// <param name="repo">The repository containing the trees.</param>
        /// <param name="old_tree">A git_tree object to diff from, or NULL for empty tree.</param>
        /// <param name="new_tree">A git_tree object to diff to, or NULL for empty tree.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This is equivalent to `git diff 
        /// &lt;old
        /// -tree&gt; 
        /// &lt;new
        /// -tree&gt;`The first tree will be used for the "old_file" side of the delta and the
        /// second tree will be used for the "new_file" side of the delta.  You can
        /// pass NULL to indicate an empty tree, although it is an error to pass
        /// NULL for both the `old_tree` and `new_tree`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_tree_to_tree")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_tree_to_tree(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_tree old_tree, libgit2.git_tree new_tree, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Create a diff between a tree and repository index.
        /// </summary>
        /// <param name="diff">Output pointer to a git_diff pointer to be allocated.</param>
        /// <param name="repo">The repository containing the tree and index.</param>
        /// <param name="old_tree">A git_tree object to diff from, or NULL for empty tree.</param>
        /// <param name="index">The index to diff with; repo index used if NULL.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This is equivalent to `git diff --cached 
        /// &lt;treeish
        /// &gt;` or if you pass
        /// the HEAD tree, then like `git diff --cached`.The tree you pass will be used for the "old_file" side of the delta, and
        /// the index will be used for the "new_file" side of the delta.If you pass NULL for the index, then the existing index of the `repo`
        /// will be used.  In this case, the index will be refreshed from disk
        /// (if it has changed) before the diff is generated.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_tree_to_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_tree_to_index(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_tree old_tree, libgit2.git_index index, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Create a diff between the repository index and the workdir directory.
        /// </summary>
        /// <param name="diff">Output pointer to a git_diff pointer to be allocated.</param>
        /// <param name="repo">The repository.</param>
        /// <param name="index">The index to diff from; repo index used if NULL.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This matches the `git diff` command.  See the note below on
        /// `git_diff_tree_to_workdir` for a discussion of the difference between
        /// `git diff` and `git diff HEAD` and how to emulate a `git diff 
        /// &lt;treeish
        /// &gt;`
        /// using libgit2.The index will be used for the "old_file" side of the delta, and the
        /// working directory will be used for the "new_file" side of the delta.If you pass NULL for the index, then the existing index of the `repo`
        /// will be used.  In this case, the index will be refreshed from disk
        /// (if it has changed) before the diff is generated.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_index_to_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_index_to_workdir(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_index index, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Create a diff between a tree and the working directory.
        /// </summary>
        /// <param name="diff">A pointer to a git_diff pointer that will be allocated.</param>
        /// <param name="repo">The repository containing the tree.</param>
        /// <param name="old_tree">A git_tree object to diff from, or NULL for empty tree.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The tree you provide will be used for the "old_file" side of the delta,
        /// and the working directory will be used for the "new_file" side.This is not the same as `git diff 
        /// &lt;treeish
        /// &gt;` or `git diff-index
        /// &lt;treeish
        /// &gt;`.  Those commands use information from the index, whereas this
        /// function strictly returns the differences between the tree and the files
        /// in the working directory, regardless of the state of the index.  Use
        /// `git_diff_tree_to_workdir_with_index` to emulate those commands.To see difference between this and `git_diff_tree_to_workdir_with_index`,
        /// consider the example of a staged file deletion where the file has then
        /// been put back into the working dir and further modified.  The
        /// tree-to-workdir diff for that file is 'modified', but `git diff` would
        /// show status 'deleted' since there is a staged delete.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_tree_to_workdir")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_tree_to_workdir(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_tree old_tree, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Create a diff between a tree and the working directory using index data
        /// to account for staged deletes, tracked files, etc.
        /// </summary>
        /// <param name="diff">A pointer to a git_diff pointer that will be allocated.</param>
        /// <param name="repo">The repository containing the tree.</param>
        /// <param name="old_tree">A git_tree object to diff from, or NULL for empty tree.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This emulates `git diff 
        /// &lt;tree
        /// &gt;` by diffing the tree to the index and
        /// the index to the working directory and blending the results into a
        /// single diff that includes staged deleted, etc.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_tree_to_workdir_with_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_tree_to_workdir_with_index(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_tree old_tree, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Create a diff with the difference between two index objects.
        /// </summary>
        /// <param name="diff">Output pointer to a git_diff pointer to be allocated.</param>
        /// <param name="repo">The repository containing the indexes.</param>
        /// <param name="old_index">A git_index object to diff from.</param>
        /// <param name="new_index">A git_index object to diff to.</param>
        /// <param name="opts">Structure with options to influence diff or NULL for defaults.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// The first index will be used for the "old_file" side of the delta and the
        /// second index will be used for the "new_file" side of the delta.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_index_to_index")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_index_to_index(out libgit2.git_diff diff, libgit2.git_repository repo, libgit2.git_index old_index, libgit2.git_index new_index, in libgit2.git_diff_options opts);
        
        /// <summary>
        /// Merge one diff into another.
        /// </summary>
        /// <param name="onto">Diff to merge into.</param>
        /// <param name="from">Diff to merge.</param>
        /// <returns>@return 0 or an error code.</returns>
        /// <remarks>
        /// This merges items from the "from" list into the "onto" list.  The
        /// resulting diff will have all items that appear in either list.
        /// If an item appears in both lists, then it will be "merged" to appear
        /// as if the old version was from the "onto" list and the new version
        /// is from the "from" list (with the exception that if the item has a
        /// pending DELETE in the middle, then it will show as deleted).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_merge")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_merge(libgit2.git_diff onto, libgit2.git_diff from);
        
        /// <summary>
        /// Transform a diff marking file renames, copies, etc.
        /// </summary>
        /// <param name="diff">diff to run detection algorithms on</param>
        /// <param name="options">Control how detection should be run, NULL for defaults</param>
        /// <returns>@return 0 on success, -1 on failure</returns>
        /// <remarks>
        /// This modifies a diff in place, replacing old entries that look
        /// like renames or copies with new entries reflecting those changes.
        /// This also will, if requested, break modified files into add/remove
        /// pairs if the amount of change is above a threshold.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_find_similar")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_find_similar(libgit2.git_diff diff, in libgit2.git_diff_find_options options);
        
        /// <summary>
        /// Query how many diff records are there in a diff.
        /// </summary>
        /// <param name="diff">A git_diff generated by one of the above functions</param>
        /// <returns>@return Count of number of deltas in the list</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_num_deltas")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_diff_num_deltas(libgit2.git_diff diff);
        
        /// <summary>
        /// Query how many diff deltas are there in a diff filtered by type.
        /// </summary>
        /// <param name="diff">A git_diff generated by one of the above functions</param>
        /// <param name="type">A git_delta_t value to filter the count</param>
        /// <returns>@return Count of number of deltas matching delta_t type</returns>
        /// <remarks>
        /// This works just like `git_diff_num_deltas()` with an extra parameter
        /// that is a `git_delta_t` and returns just the count of how many deltas
        /// match that particular type.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_num_deltas_of_type")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_diff_num_deltas_of_type(libgit2.git_diff diff, libgit2.git_delta_t type);
        
        /// <summary>
        /// Return the diff delta for an entry in the diff list.
        /// </summary>
        /// <param name="diff">Diff list object</param>
        /// <param name="idx">Index into diff list</param>
        /// <returns>@return Pointer to git_diff_delta (or NULL if `idx` out of range)</returns>
        /// <remarks>
        /// The `git_diff_delta` pointer points to internal data and you do not
        /// have to release it when you are done with it.  It will go away when
        /// the * `git_diff` (or any associated `git_patch`) goes away.Note that the flags on the delta related to whether it has binary
        /// content or not may not be set if there are no attributes set for the
        /// file and there has been no reason to load the file data at this point.
        /// For now, if you need those flags to be up to date, your only option is
        /// to either use `git_diff_foreach` or create a `git_patch`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_get_delta")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_diff_delta* git_diff_get_delta(libgit2.git_diff diff, libgit2.size_t idx);
        
        /// <summary>
        /// Check if deltas are sorted case sensitively or insensitively.
        /// </summary>
        /// <param name="diff">diff to check</param>
        /// <returns>@return 0 if case sensitive, 1 if case is ignored</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_is_sorted_icase")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial int git_diff_is_sorted_icase(libgit2.git_diff diff);
        
        /// <summary>
        /// Loop over all deltas in a diff issuing callbacks.
        /// </summary>
        /// <param name="diff">A git_diff generated by one of the above functions.</param>
        /// <param name="file_cb">Callback function to make per file in the diff.</param>
        /// <param name="binary_cb">Optional callback to make for binary files.</param>
        /// <param name="hunk_cb">Optional callback to make per hunk of text diff.  This
        /// callback is called to describe a range of lines in the
        /// diff.  It will not be issued for binary files.</param>
        /// <param name="line_cb">Optional callback to make per line of diff text.  This
        /// same callback will be made for context lines, added, and
        /// removed lines, and even for a deleted trailing newline.</param>
        /// <param name="payload">Reference pointer that will be passed to your callbacks.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// This will iterate through all of the files described in a diff.  You
        /// should provide a file callback to learn about each file.The "hunk" and "line" callbacks are optional, and the text diff of the
        /// files will only be calculated if they are not NULL.  Of course, these
        /// callbacks will not be invoked for binary files on the diff or for
        /// files whose only changed is a file mode change.Returning a non-zero value from any of the callbacks will terminate
        /// the iteration and return the value to the user.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_foreach")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_foreach(libgit2.git_diff diff, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Look up the single character abbreviation for a delta status code.
        /// </summary>
        /// <param name="status">The git_delta_t value to look up</param>
        /// <returns>@return The single character label for that code</returns>
        /// <remarks>
        /// When you run `git diff --name-status` it uses single letter codes in
        /// the output such as 'A' for added, 'D' for deleted, 'M' for modified,
        /// etc.  This function converts a git_delta_t value into these letters for
        /// your own purposes.  GIT_DELTA_UNTRACKED will return a space (i.e. ' ').
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_status_char")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial byte git_diff_status_char(libgit2.git_delta_t status);
        
        /// <summary>
        /// Iterate over a diff generating formatted text output.
        /// </summary>
        /// <param name="diff">A git_diff generated by one of the above functions.</param>
        /// <param name="format">A git_diff_format_t value to pick the text format.</param>
        /// <param name="print_cb">Callback to make per line of diff text.</param>
        /// <param name="payload">Reference pointer that will be passed to your callback.</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// Returning a non-zero value from the callbacks will terminate the
        /// iteration and return the non-zero value to the caller.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_print")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_print(libgit2.git_diff diff, libgit2.git_diff_format_t format, libgit2.git_diff_line_cb print_cb, void* payload);
        
        /// <summary>
        /// Produce the complete formatted text output from a diff into a
        /// buffer.
        /// </summary>
        /// <param name="out">A pointer to a user-allocated git_buf that will
        /// contain the diff text</param>
        /// <param name="diff">A git_diff generated by one of the above functions.</param>
        /// <param name="format">A git_diff_format_t value to pick the text format.</param>
        /// <returns>@return 0 on success or error code</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_to_buf")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_to_buf(out libgit2.git_buf @out, libgit2.git_diff diff, libgit2.git_diff_format_t format);
        
        /// <summary>
        /// Directly run a diff on two blobs.
        /// </summary>
        /// <param name="old_blob">Blob for old side of diff, or NULL for empty blob</param>
        /// <param name="old_as_path">Treat old blob as if it had this filename; can be NULL</param>
        /// <param name="new_blob">Blob for new side of diff, or NULL for empty blob</param>
        /// <param name="new_as_path">Treat new blob as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// Compared to a file, a blob lacks some contextual information. As such,
        /// the `git_diff_file` given to the callback will have some fake data; i.e.
        /// `mode` will be 0 and `path` will be NULL.NULL is allowed for either `old_blob` or `new_blob` and will be treated
        /// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
        /// Passing NULL for both blobs is a noop; no callbacks will be made at all.We do run a binary content check on the blob content and if either blob
        /// looks like binary data, the `git_diff_delta` binary attribute will be set
        /// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
        /// `GIT_DIFF_FORCE_TEXT` of course).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_blobs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_blobs(libgit2.git_blob old_blob, byte* old_as_path, libgit2.git_blob new_blob, byte* new_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Directly run a diff on two blobs.
        /// </summary>
        /// <param name="old_blob">Blob for old side of diff, or NULL for empty blob</param>
        /// <param name="old_as_path">Treat old blob as if it had this filename; can be NULL</param>
        /// <param name="new_blob">Blob for new side of diff, or NULL for empty blob</param>
        /// <param name="new_as_path">Treat new blob as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// Compared to a file, a blob lacks some contextual information. As such,
        /// the `git_diff_file` given to the callback will have some fake data; i.e.
        /// `mode` will be 0 and `path` will be NULL.NULL is allowed for either `old_blob` or `new_blob` and will be treated
        /// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
        /// Passing NULL for both blobs is a noop; no callbacks will be made at all.We do run a binary content check on the blob content and if either blob
        /// looks like binary data, the `git_diff_delta` binary attribute will be set
        /// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
        /// `GIT_DIFF_FORCE_TEXT` of course).
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_blobs")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_blobs(libgit2.git_blob old_blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> old_as_path, libgit2.git_blob new_blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> new_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Directly run a diff between a blob and a buffer.
        /// </summary>
        /// <param name="old_blob">Blob for old side of diff, or NULL for empty blob</param>
        /// <param name="old_as_path">Treat old blob as if it had this filename; can be NULL</param>
        /// <param name="buffer">Raw data for new side of diff, or NULL for empty</param>
        /// <param name="buffer_len">Length of raw data for new side of diff</param>
        /// <param name="buffer_as_path">Treat buffer as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
        /// so the `git_diff_file` parameters to the callbacks will be faked a la the
        /// rules for `git_diff_blobs()`.Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
        /// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
        /// entire content of the buffer added).  Passing NULL to the buffer will do
        /// the reverse, with GIT_DELTA_REMOVED and blob content removed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_blob_to_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_blob_to_buffer(libgit2.git_blob old_blob, byte* old_as_path, byte* buffer, libgit2.size_t buffer_len, byte* buffer_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Directly run a diff between a blob and a buffer.
        /// </summary>
        /// <param name="old_blob">Blob for old side of diff, or NULL for empty blob</param>
        /// <param name="old_as_path">Treat old blob as if it had this filename; can be NULL</param>
        /// <param name="buffer">Raw data for new side of diff, or NULL for empty</param>
        /// <param name="buffer_len">Length of raw data for new side of diff</param>
        /// <param name="buffer_as_path">Treat buffer as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
        /// so the `git_diff_file` parameters to the callbacks will be faked a la the
        /// rules for `git_diff_blobs()`.Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
        /// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
        /// entire content of the buffer added).  Passing NULL to the buffer will do
        /// the reverse, with GIT_DELTA_REMOVED and blob content removed.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_blob_to_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_blob_to_buffer(libgit2.git_blob old_blob, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> old_as_path, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> buffer, libgit2.size_t buffer_len, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> buffer_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Directly run a diff between two buffers.
        /// </summary>
        /// <param name="old_buffer">Raw data for old side of diff, or NULL for empty</param>
        /// <param name="old_len">Length of the raw data for old side of the diff</param>
        /// <param name="old_as_path">Treat old buffer as if it had this filename; can be NULL</param>
        /// <param name="new_buffer">Raw data for new side of diff, or NULL for empty</param>
        /// <param name="new_len">Length of raw data for new side of diff</param>
        /// <param name="new_as_path">Treat buffer as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// Even more than with `git_diff_blobs`, comparing two buffer lacks
        /// context, so the `git_diff_file` parameters to the callbacks will be
        /// faked a la the rules for `git_diff_blobs()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_buffers")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_buffers(void* old_buffer, libgit2.size_t old_len, byte* old_as_path, void* new_buffer, libgit2.size_t new_len, byte* new_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Directly run a diff between two buffers.
        /// </summary>
        /// <param name="old_buffer">Raw data for old side of diff, or NULL for empty</param>
        /// <param name="old_len">Length of the raw data for old side of the diff</param>
        /// <param name="old_as_path">Treat old buffer as if it had this filename; can be NULL</param>
        /// <param name="new_buffer">Raw data for new side of diff, or NULL for empty</param>
        /// <param name="new_len">Length of raw data for new side of diff</param>
        /// <param name="new_as_path">Treat buffer as if it had this filename; can be NULL</param>
        /// <param name="options">Options for diff, or NULL for default options</param>
        /// <param name="file_cb">Callback for "file"; made once if there is a diff; can be NULL</param>
        /// <param name="binary_cb">Callback for binary files; can be NULL</param>
        /// <param name="hunk_cb">Callback for each hunk in diff; can be NULL</param>
        /// <param name="line_cb">Callback for each line in diff; can be NULL</param>
        /// <param name="payload">Payload passed to each callback function</param>
        /// <returns>@return 0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// Even more than with `git_diff_blobs`, comparing two buffer lacks
        /// context, so the `git_diff_file` parameters to the callbacks will be
        /// faked a la the rules for `git_diff_blobs()`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_buffers")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_buffers(void* old_buffer, libgit2.size_t old_len, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> old_as_path, void* new_buffer, libgit2.size_t new_len, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> new_as_path, in libgit2.git_diff_options options, libgit2.git_diff_file_cb file_cb, libgit2.git_diff_binary_cb binary_cb, libgit2.git_diff_hunk_cb hunk_cb, libgit2.git_diff_line_cb line_cb, void* payload);
        
        /// <summary>
        /// Read the contents of a git patch file into a `git_diff` object.
        /// </summary>
        /// <param name="out">A pointer to a git_diff pointer that will be allocated.</param>
        /// <param name="content">The contents of a patch file</param>
        /// <param name="content_len">The length of the patch file contents</param>
        /// <returns>@return 0 or an error code</returns>
        /// <remarks>
        /// The diff object produced is similar to the one that would be
        /// produced if you actually produced it computationally by comparing
        /// two trees, however there may be subtle differences.  For example,
        /// a patch file likely contains abbreviated object IDs, so the
        /// object IDs in a `git_diff_delta` produced by this function will
        /// also be abbreviated.This function will only read patch files created by a git
        /// implementation, it will not read unified diffs produced by
        /// the `diff` program, nor any other types of patch files.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_from_buffer")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_from_buffer(out libgit2.git_diff @out, byte* content, libgit2.size_t content_len);
        
        /// <summary>
        /// Accumulate diff statistics for all patches.
        /// </summary>
        /// <param name="out">Structure containing the diff statistics.</param>
        /// <param name="diff">A git_diff generated by one of the above functions.</param>
        /// <returns>@return 0 on success; non-zero on error</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_get_stats")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_get_stats(out libgit2.git_diff_stats @out, libgit2.git_diff diff);
        
        /// <summary>
        /// Get the total number of files changed in a diff
        /// </summary>
        /// <param name="stats">A `git_diff_stats` generated by one of the above functions.</param>
        /// <returns>@return total number of files changed in the diff</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_stats_files_changed")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_diff_stats_files_changed(libgit2.git_diff_stats stats);
        
        /// <summary>
        /// Get the total number of insertions in a diff
        /// </summary>
        /// <param name="stats">A `git_diff_stats` generated by one of the above functions.</param>
        /// <returns>@return total number of insertions in the diff</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_stats_insertions")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_diff_stats_insertions(libgit2.git_diff_stats stats);
        
        /// <summary>
        /// Get the total number of deletions in a diff
        /// </summary>
        /// <param name="stats">A `git_diff_stats` generated by one of the above functions.</param>
        /// <returns>@return total number of deletions in the diff</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_stats_deletions")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.size_t git_diff_stats_deletions(libgit2.git_diff_stats stats);
        
        /// <summary>
        /// Print diff statistics to a `git_buf`.
        /// </summary>
        /// <param name="out">buffer to store the formatted diff statistics in.</param>
        /// <param name="stats">A `git_diff_stats` generated by one of the above functions.</param>
        /// <param name="format">Formatting option.</param>
        /// <param name="width">Target width for output (only affects GIT_DIFF_STATS_FULL)</param>
        /// <returns>@return 0 on success; non-zero on error</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_stats_to_buf")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_stats_to_buf(out libgit2.git_buf @out, libgit2.git_diff_stats stats, libgit2.git_diff_stats_format_t format, libgit2.size_t width);
        
        /// <summary>
        /// Deallocate a `git_diff_stats`.
        /// </summary>
        /// <param name="stats">The previously created statistics object;
        /// cannot be used after free.</param>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_stats_free")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial void git_diff_stats_free(libgit2.git_diff_stats stats);
        
        /// <summary>
        /// Initialize git_diff_patchid_options structure
        /// </summary>
        /// <param name="opts">The `git_diff_patchid_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_DIFF_PATCHID_OPTIONS_VERSION`.</param>
        /// <returns>@return Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_diff_patchid_options` with default values. Equivalent to
        /// creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_patchid_options_init")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_patchid_options_init(ref libgit2.git_diff_patchid_options opts, uint version);
        
        /// <summary>
        /// Calculate the patch ID for the given patch.
        /// </summary>
        /// <param name="out">Pointer where the calculated patch ID should be stored</param>
        /// <param name="diff">The diff to calculate the ID for</param>
        /// <param name="opts">Options for how to calculate the patch ID. This is
        /// intended for future changes, as currently no options are
        /// available.</param>
        /// <returns>@return 0 on success, an error code otherwise.</returns>
        /// <remarks>
        /// Calculate a stable patch ID for the given patch by summing the
        /// hash of the file diffs, ignoring whitespace and line numbers.
        /// This can be used to derive whether two diffs are the same with
        /// a high probability.Currently, this function only calculates stable patch IDs, as
        /// defined in git-patch-id(1), and should in fact generate the
        /// same IDs as the upstream git project does.
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "git_diff_patchid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial libgit2.git_result git_diff_patchid(out libgit2.git_oid @out, libgit2.git_diff diff, in libgit2.git_diff_patchid_options opts);
    }
}
